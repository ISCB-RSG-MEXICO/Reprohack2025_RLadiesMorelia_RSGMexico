[
  {
    "objectID": "datos.html",
    "href": "datos.html",
    "title": "Sobre los datos",
    "section": "",
    "text": "Asignada: Johana\nVariables (que dicen las filas y las columnas)"
  },
  {
    "objectID": "datos.html#estructura-de-los-datos",
    "href": "datos.html#estructura-de-los-datos",
    "title": "Sobre los datos",
    "section": "",
    "text": "Asignada: Johana\nVariables (que dicen las filas y las columnas)"
  },
  {
    "objectID": "datos.html#importar-datos-en-r",
    "href": "datos.html#importar-datos-en-r",
    "title": "Sobre los datos",
    "section": "Importar datos en R",
    "text": "Importar datos en R\nComo los importamos a R."
  },
  {
    "objectID": "Figura2.html",
    "href": "Figura2.html",
    "title": "Figura 2",
    "section": "",
    "text": "Figura 2. Censo integral de elementos genéticos móviles (MGEs) en procariotas\n\n\n\nContribución de cada una de las cinco principales familias de recombinasas a las seis categorías de MGEs, así como a las recombinasas celulares.\nNúmero de MGEs por categoría (gráfico de barras) y porcentaje de cada categoría (gráfico de dona) en 76,000 genomas de 3,000 especies, utilizando el flujo de trabajo descrito en la Figura 1.\nLongitudes predichas de MGEs no anidados en pares de bases. Los bigotes representan el rango entre los percentiles 10 y 90.\n\n\n\n\nUso de Archivos Comprimidos: Cuando trabajen con archivos comprimidos (por ejemplo, con extensión .gz), no es necesario descomprimirlos manualmente antes de cargarlos en R.\nCódigo Correcto para Cargar Archivos Comprimidos: Para cargar archivos comprimidos sin descomprimirlos previamente, utilicen el siguiente código:\n\n\nmge_pg &lt;- read_tsv(\"data/processed_data/mge_bins_per_genome_final.txt.gz\", col_names = T)\nmge_solitary &lt;- read_tsv(\"data/processed_data/solitary_mge_bins_final.txt.gz\", col_names = F)\nrec_class &lt;- read_tsv(\"data/raw_data/recombinase.list.gz\", col_names = F)\nglist &lt;- read_tsv(\"data/raw_data/genome_status_supplementary_tableS2.txt.gz\", col_names = T)\n\n\n\n\n\n\n\nDiferencia con el Código Original\n\n\n\nEn el código original, el archivo estaba descomprimido. Sin embargo, con la extensión .gz, se puede leer directamente el archivo comprimido sin la necesidad de usar herramientas adicionales para descomprimirlo.\n\n\n\n\n\n\n# Obtener los genomas con la mas alta calidad\nglist_high &lt;- glist %&gt;% \n  filter(genome_quality == \"high\")\n\n# Renombrar columnas en rec_class\nrec_class &lt;- rec_class %&gt;% \n  # Cambiar X1 por class y X2 por mgeR\n  dplyr::rename(class = X1, mgeR = X2)\n\n# Renombrar columnas en mge_solitary\nmge_solitary &lt;- mge_solitary %&gt;% \n  dplyr::rename(IS_Tn = X1, Phage = X2, Phage_like = X3, CE = X4, Integron = X5, MI = X6,   Hotspot = X7, UC = X8,  Cellular = X9, island = X10, island_size = X11, prot_count = X12,   phage_count = X13, CONJ_T4SS = X14, mgeR = X15)\n\n# Transformación y Filtrado de Datos de MGE Solitario\nmge_solitary_melted &lt;- mge_solitary %&gt;% \n  select(1:11,15) %&gt;% # Seleccionar columnas de la 1 a la 11, y la 15\n  # Convierte las columnas 1 a 9 de formato ancho a largo utilizando gather().\n    # - mge: Nombre de la nueva columna que contendrá los nombres originales de las variables.\n    # - mge_pa: Nueva columna que almacenará los valores de las celdas de las columnas originales.\n  gather(mge, mge_pa, 1:9) %&gt;% \n  filter(mge_pa ==1) %&gt;% # filtrar por valores igual a 1 en la columna mge_pa\n  filter(.,!grepl(\"UC\", mge)) %&gt;% # Elimina las filas donde la columna mge contenga la cadena \"UC\", usando grepl() con ! (negación lógica).\n  filter(.,!grepl(\"Hotspot\", mge)) %&gt;% # Elimina las filas donde mge contenga la palabra \"Hotspot\".\n  mutate(mgeRn = str_replace_all(mgeR,\"_\",\"\")) %&gt;% # Crea una nueva columna mgeRn, eliminando todos los guiones bajos (_) en la columna mgeR\n  filter(!str_detect(mgeRn, '[:alnum:] &{1,}')) %&gt;% # Filtra las filas donde mgeRn NO contenga un patrón de caracteres alfanuméricos seguidos de &.\n  select(-mgeRn) %&gt;% # Elimina la columna mgeRn\n  mutate(mgeR = str_replace_all(mgeR,\"&\",\"\")) # Modifica mgeR, eliminando todos los caracteres &.\n\n# Visualizar datos\nhead(mge_solitary_melted)\n\n# A tibble: 6 × 5\n  island                                       island_size mgeR           mge   mge_pa\n  &lt;chr&gt;                                              &lt;dbl&gt; &lt;chr&gt;          &lt;chr&gt;  &lt;dbl&gt;\n1 562.SAMN04376786.LVNY01000045:952-4426              3474 rve            IS_Tn      1\n2 1313.SAMEA1032643.CNPJ02000077:179268-184242        4974 huh_y1         IS_Tn      1\n3 90371.SAMN06345841.MVIX01000065:110-337              227 huh_y1         IS_Tn      1\n4 766148.SAMN00792444.AFGX01000029:22-9946            9924 rve            IS_Tn      1\n5 95486.SAMN05002005.MUWP01000187:1439-20561         19122 DDE_3          IS_Tn      1\n6 562.SAMN03075146.JRLD01000012:423-1556              1133 Transposase_20 IS_Tn      1\n\n\n\nmge_solitary_melted_dw &lt;- mge_solitary_melted %&gt;% \n  select(-mgeR,-mge_pa) %&gt;%  # Elimina las columnas mgeR y mge_pa\n  mutate(island1 = island) %&gt;% # Crea una nueva columna island1, duplicando el valor de la columna island.\n  separate(island1, c(\"g1\",\"g2\",\"g3\")) %&gt;% # Divide la columna island1 en tres nuevas columnas (g1, g2, g3), usando separate(). NOTA: Se asume que island1 contiene valores separados por un delimitador (por defecto, \"_\" o \".\").\n  mutate(genome = paste(g1, g2, sep = \".\")) %&gt;%  # Identificador del genoma. Crea una nueva columna genome, concatenando g1 y g2 con un punto (\".\") entre ellos.\n  select(-g1,-g2,-g3) %&gt;% # Elimina las columnas g1, g2 y g3\n  filter(genome %in% glist_high$genome) %&gt;% # Solo quedarse con genomas de alta calidad\n  select(-genome) # Eliminar columna genoma\n\nhead(mge_solitary_melted_dw)\n\n# A tibble: 6 × 3\n  island                                       island_size mge  \n  &lt;chr&gt;                                              &lt;dbl&gt; &lt;chr&gt;\n1 562.SAMN04376786.LVNY01000045:952-4426              3474 IS_Tn\n2 1313.SAMEA1032643.CNPJ02000077:179268-184242        4974 IS_Tn\n3 90371.SAMN06345841.MVIX01000065:110-337              227 IS_Tn\n4 766148.SAMN00792444.AFGX01000029:22-9946            9924 IS_Tn\n5 95486.SAMN05002005.MUWP01000187:1439-20561         19122 IS_Tn\n6 562.SAMN03075146.JRLD01000012:423-1556              1133 IS_Tn\n\n\nAlmacenar variable\n\nwrite.table(mge_solitary_melted_dw,file=\"processed_data/mge_bins_final_solitary_collapsed.txt\", sep = \"\\t\", row.names = F, col.names = T, quote = F)\n\n\n\n\nDistribución de diferentes clases de MGE y cuántas veces aparecen en el conjunto de datos.\n\n# Unir la informacion a traves de la columna mgeR\nmge_solitary_rclass_all &lt;- left_join(mge_solitary_melted, rec_class, by = \"mgeR\") %&gt;% \n  select(-island_size, -mge_pa, -mgeR) %&gt;% # Elimina las columnas island_size, mge_pa y mgeR\n  separate(island, c(\"g1\",\"g2\",\"g3\")) %&gt;% # Divide la columna island en tres nuevas columnas (g1, g2, g3).\n  mutate(genome = paste(g1, g2, sep = \".\")) %&gt;% # Crea una nueva columna genome, concatenando g1 y g2 con un punto (\".\") entre ellos.\n  select(-g1,-g2,-g3) %&gt;% # Elimina las columnas auxiliares (g1, g2, g3), ya que su información ahora está en genome.\n  group_by(class,mge) %&gt;% # Agrupa los datos por class y mge \n  summarise(count = n()) # Cuenta cuántas veces aparece cada combinación de class y mge\n\nhead(mge_solitary_rclass_all)\n\n# A tibble: 6 × 3\n# Groups:   class [3]\n  class mge         count\n  &lt;chr&gt; &lt;chr&gt;       &lt;int&gt;\n1 cas   IS_Tn       12184\n2 dde   CE            181\n3 dde   IS_Tn      913577\n4 dde   Phage       10154\n5 dde   Phage_like    131\n6 huh   CE          18627\n\n\nDistribución de diferentes clases de MGE en genomas de alta calidad.\n\n# Unir la informacion a traves de la columna mgeR\nmge_solitary_rclass &lt;- left_join(mge_solitary_melted,rec_class, by = \"mgeR\") %&gt;% \n  select(-island_size, -mge_pa, -mgeR) %&gt;% # Elimina las columnas island_size, mge_pa y mgeR\n  separate(island, c(\"g1\",\"g2\",\"g3\")) %&gt;% # Divide la columna island en tres nuevas columnas (g1, g2, g3).\n  mutate(genome = paste(g1, g2, sep = \".\")) %&gt;% # Crea una nueva columna genome, concatenando g1 y g2 con un punto (\".\") entre ellos.\n  select(-g1,-g2,-g3) %&gt;% # Elimina las columnas auxiliares (g1, g2, g3), ya que su información ahora está en genome.\n  filter(genome %in% glist_high$genome) %&gt;% # Solo quedarse con genomas de alta calidad\n  group_by(class,mge) %&gt;% # Agrupa los datos por class y mge \n  summarise(count = n()) # Cuenta cuántas veces aparece cada combinación de class y mge\n\nhead(mge_solitary_rclass)\n\n# A tibble: 6 × 3\n# Groups:   class [3]\n  class mge         count\n  &lt;chr&gt; &lt;chr&gt;       &lt;int&gt;\n1 cas   IS_Tn       12024\n2 dde   CE            180\n3 dde   IS_Tn      904177\n4 dde   Phage       10078\n5 dde   Phage_like    129\n6 huh   CE          18385"
  },
  {
    "objectID": "Figura2.html#censo-de-elementos-genéticos-móviles-en-procariotas",
    "href": "Figura2.html#censo-de-elementos-genéticos-móviles-en-procariotas",
    "title": "Figura 2",
    "section": "",
    "text": "Figura 2. Censo integral de elementos genéticos móviles (MGEs) en procariotas\n\n\n\nContribución de cada una de las cinco principales familias de recombinasas a las seis categorías de MGEs, así como a las recombinasas celulares.\nNúmero de MGEs por categoría (gráfico de barras) y porcentaje de cada categoría (gráfico de dona) en 76,000 genomas de 3,000 especies, utilizando el flujo de trabajo descrito en la Figura 1.\nLongitudes predichas de MGEs no anidados en pares de bases. Los bigotes representan el rango entre los percentiles 10 y 90.\n\n\n\n\nUso de Archivos Comprimidos: Cuando trabajen con archivos comprimidos (por ejemplo, con extensión .gz), no es necesario descomprimirlos manualmente antes de cargarlos en R.\nCódigo Correcto para Cargar Archivos Comprimidos: Para cargar archivos comprimidos sin descomprimirlos previamente, utilicen el siguiente código:\n\n\nmge_pg &lt;- read_tsv(\"data/processed_data/mge_bins_per_genome_final.txt.gz\", col_names = T)\nmge_solitary &lt;- read_tsv(\"data/processed_data/solitary_mge_bins_final.txt.gz\", col_names = F)\nrec_class &lt;- read_tsv(\"data/raw_data/recombinase.list.gz\", col_names = F)\nglist &lt;- read_tsv(\"data/raw_data/genome_status_supplementary_tableS2.txt.gz\", col_names = T)\n\n\n\n\n\n\n\nDiferencia con el Código Original\n\n\n\nEn el código original, el archivo estaba descomprimido. Sin embargo, con la extensión .gz, se puede leer directamente el archivo comprimido sin la necesidad de usar herramientas adicionales para descomprimirlo.\n\n\n\n\n\n\n# Obtener los genomas con la mas alta calidad\nglist_high &lt;- glist %&gt;% \n  filter(genome_quality == \"high\")\n\n# Renombrar columnas en rec_class\nrec_class &lt;- rec_class %&gt;% \n  # Cambiar X1 por class y X2 por mgeR\n  dplyr::rename(class = X1, mgeR = X2)\n\n# Renombrar columnas en mge_solitary\nmge_solitary &lt;- mge_solitary %&gt;% \n  dplyr::rename(IS_Tn = X1, Phage = X2, Phage_like = X3, CE = X4, Integron = X5, MI = X6,   Hotspot = X7, UC = X8,  Cellular = X9, island = X10, island_size = X11, prot_count = X12,   phage_count = X13, CONJ_T4SS = X14, mgeR = X15)\n\n# Transformación y Filtrado de Datos de MGE Solitario\nmge_solitary_melted &lt;- mge_solitary %&gt;% \n  select(1:11,15) %&gt;% # Seleccionar columnas de la 1 a la 11, y la 15\n  # Convierte las columnas 1 a 9 de formato ancho a largo utilizando gather().\n    # - mge: Nombre de la nueva columna que contendrá los nombres originales de las variables.\n    # - mge_pa: Nueva columna que almacenará los valores de las celdas de las columnas originales.\n  gather(mge, mge_pa, 1:9) %&gt;% \n  filter(mge_pa ==1) %&gt;% # filtrar por valores igual a 1 en la columna mge_pa\n  filter(.,!grepl(\"UC\", mge)) %&gt;% # Elimina las filas donde la columna mge contenga la cadena \"UC\", usando grepl() con ! (negación lógica).\n  filter(.,!grepl(\"Hotspot\", mge)) %&gt;% # Elimina las filas donde mge contenga la palabra \"Hotspot\".\n  mutate(mgeRn = str_replace_all(mgeR,\"_\",\"\")) %&gt;% # Crea una nueva columna mgeRn, eliminando todos los guiones bajos (_) en la columna mgeR\n  filter(!str_detect(mgeRn, '[:alnum:] &{1,}')) %&gt;% # Filtra las filas donde mgeRn NO contenga un patrón de caracteres alfanuméricos seguidos de &.\n  select(-mgeRn) %&gt;% # Elimina la columna mgeRn\n  mutate(mgeR = str_replace_all(mgeR,\"&\",\"\")) # Modifica mgeR, eliminando todos los caracteres &.\n\n# Visualizar datos\nhead(mge_solitary_melted)\n\n# A tibble: 6 × 5\n  island                                       island_size mgeR           mge   mge_pa\n  &lt;chr&gt;                                              &lt;dbl&gt; &lt;chr&gt;          &lt;chr&gt;  &lt;dbl&gt;\n1 562.SAMN04376786.LVNY01000045:952-4426              3474 rve            IS_Tn      1\n2 1313.SAMEA1032643.CNPJ02000077:179268-184242        4974 huh_y1         IS_Tn      1\n3 90371.SAMN06345841.MVIX01000065:110-337              227 huh_y1         IS_Tn      1\n4 766148.SAMN00792444.AFGX01000029:22-9946            9924 rve            IS_Tn      1\n5 95486.SAMN05002005.MUWP01000187:1439-20561         19122 DDE_3          IS_Tn      1\n6 562.SAMN03075146.JRLD01000012:423-1556              1133 Transposase_20 IS_Tn      1\n\n\n\nmge_solitary_melted_dw &lt;- mge_solitary_melted %&gt;% \n  select(-mgeR,-mge_pa) %&gt;%  # Elimina las columnas mgeR y mge_pa\n  mutate(island1 = island) %&gt;% # Crea una nueva columna island1, duplicando el valor de la columna island.\n  separate(island1, c(\"g1\",\"g2\",\"g3\")) %&gt;% # Divide la columna island1 en tres nuevas columnas (g1, g2, g3), usando separate(). NOTA: Se asume que island1 contiene valores separados por un delimitador (por defecto, \"_\" o \".\").\n  mutate(genome = paste(g1, g2, sep = \".\")) %&gt;%  # Identificador del genoma. Crea una nueva columna genome, concatenando g1 y g2 con un punto (\".\") entre ellos.\n  select(-g1,-g2,-g3) %&gt;% # Elimina las columnas g1, g2 y g3\n  filter(genome %in% glist_high$genome) %&gt;% # Solo quedarse con genomas de alta calidad\n  select(-genome) # Eliminar columna genoma\n\nhead(mge_solitary_melted_dw)\n\n# A tibble: 6 × 3\n  island                                       island_size mge  \n  &lt;chr&gt;                                              &lt;dbl&gt; &lt;chr&gt;\n1 562.SAMN04376786.LVNY01000045:952-4426              3474 IS_Tn\n2 1313.SAMEA1032643.CNPJ02000077:179268-184242        4974 IS_Tn\n3 90371.SAMN06345841.MVIX01000065:110-337              227 IS_Tn\n4 766148.SAMN00792444.AFGX01000029:22-9946            9924 IS_Tn\n5 95486.SAMN05002005.MUWP01000187:1439-20561         19122 IS_Tn\n6 562.SAMN03075146.JRLD01000012:423-1556              1133 IS_Tn\n\n\nAlmacenar variable\n\nwrite.table(mge_solitary_melted_dw,file=\"processed_data/mge_bins_final_solitary_collapsed.txt\", sep = \"\\t\", row.names = F, col.names = T, quote = F)\n\n\n\n\nDistribución de diferentes clases de MGE y cuántas veces aparecen en el conjunto de datos.\n\n# Unir la informacion a traves de la columna mgeR\nmge_solitary_rclass_all &lt;- left_join(mge_solitary_melted, rec_class, by = \"mgeR\") %&gt;% \n  select(-island_size, -mge_pa, -mgeR) %&gt;% # Elimina las columnas island_size, mge_pa y mgeR\n  separate(island, c(\"g1\",\"g2\",\"g3\")) %&gt;% # Divide la columna island en tres nuevas columnas (g1, g2, g3).\n  mutate(genome = paste(g1, g2, sep = \".\")) %&gt;% # Crea una nueva columna genome, concatenando g1 y g2 con un punto (\".\") entre ellos.\n  select(-g1,-g2,-g3) %&gt;% # Elimina las columnas auxiliares (g1, g2, g3), ya que su información ahora está en genome.\n  group_by(class,mge) %&gt;% # Agrupa los datos por class y mge \n  summarise(count = n()) # Cuenta cuántas veces aparece cada combinación de class y mge\n\nhead(mge_solitary_rclass_all)\n\n# A tibble: 6 × 3\n# Groups:   class [3]\n  class mge         count\n  &lt;chr&gt; &lt;chr&gt;       &lt;int&gt;\n1 cas   IS_Tn       12184\n2 dde   CE            181\n3 dde   IS_Tn      913577\n4 dde   Phage       10154\n5 dde   Phage_like    131\n6 huh   CE          18627\n\n\nDistribución de diferentes clases de MGE en genomas de alta calidad.\n\n# Unir la informacion a traves de la columna mgeR\nmge_solitary_rclass &lt;- left_join(mge_solitary_melted,rec_class, by = \"mgeR\") %&gt;% \n  select(-island_size, -mge_pa, -mgeR) %&gt;% # Elimina las columnas island_size, mge_pa y mgeR\n  separate(island, c(\"g1\",\"g2\",\"g3\")) %&gt;% # Divide la columna island en tres nuevas columnas (g1, g2, g3).\n  mutate(genome = paste(g1, g2, sep = \".\")) %&gt;% # Crea una nueva columna genome, concatenando g1 y g2 con un punto (\".\") entre ellos.\n  select(-g1,-g2,-g3) %&gt;% # Elimina las columnas auxiliares (g1, g2, g3), ya que su información ahora está en genome.\n  filter(genome %in% glist_high$genome) %&gt;% # Solo quedarse con genomas de alta calidad\n  group_by(class,mge) %&gt;% # Agrupa los datos por class y mge \n  summarise(count = n()) # Cuenta cuántas veces aparece cada combinación de class y mge\n\nhead(mge_solitary_rclass)\n\n# A tibble: 6 × 3\n# Groups:   class [3]\n  class mge         count\n  &lt;chr&gt; &lt;chr&gt;       &lt;int&gt;\n1 cas   IS_Tn       12024\n2 dde   CE            180\n3 dde   IS_Tn      904177\n4 dde   Phage       10078\n5 dde   Phage_like    129\n6 huh   CE          18385"
  },
  {
    "objectID": "Figura2.html#figura-2a-contribución-de-las-principales-familias-de-recombinasas",
    "href": "Figura2.html#figura-2a-contribución-de-las-principales-familias-de-recombinasas",
    "title": "Figura 2",
    "section": "Figura 2A: Contribución de las principales familias de recombinasas",
    "text": "Figura 2A: Contribución de las principales familias de recombinasas\n\nPASO 4: Selección de las familias de recombinasas\nDefinición de Colores para las Familias de Recombinasa (vector)\n\n\n\n\n\n\nNote\n\n\n\nCrea un vector colclass con códigos de color hexadecimales (en este caso, todos son \"CDCCCC\").\n\n\n\n# Paleta general de colores\ncolc &lt;- c(\"#D55E00\", \"#E69F00\", \"#F0E442\", \"#56B4E9\", \"#009E73\", \"#0072B2\",\"#CECCCC\")\nnames(colc) &lt;- c(\"IS_Tn\", \"Phage\", \"Phage_like\", \"CE\", \"Integron\", \"MI\", \"Cellular\") \n# Paleta de colores para recombinasas\ncolclass &lt;- c(\"CDCCCC\", \"CDCCCC\", \"CDCCCC\", \"CDCCCC\", \"CDCCCC\")\nnames(colclass) &lt;- c(\"cas\", \"dde\", \"huh\", \"ser\", \"tyr\")\ncolall &lt;- c(colclass, colc)\ncolall\n\n       cas        dde        huh        ser        tyr      IS_Tn      Phage Phage_like         CE   Integron \n  \"CDCCCC\"   \"CDCCCC\"   \"CDCCCC\"   \"CDCCCC\"   \"CDCCCC\"  \"#D55E00\"  \"#E69F00\"  \"#F0E442\"  \"#56B4E9\"  \"#009E73\" \n        MI   Cellular \n \"#0072B2\"  \"#CECCCC\" \n\n\nOrdenamiento de las Categorías\n\norder_class &lt;- c( \"cas\", \"dde\",\"huh\", \"ser\", \"tyr\")\norder_mge &lt;- c(\"IS_Tn\", \"Phage_like\", \"Phage\", \"CE\", \"MI\", \"Integron\", \"Cellular\")\n\nDefine el orden en el que se mostrarán las clases (order_class) y los tipos de MGE (order_mge).\n\norder_class organiza las familias de recombinasas.\norder_mge organiza los distintos tipos de elementos genéticos móviles.\n\nTransformación de Datos para Visualización\n\nmge_solitary_rclass$mge &lt;- factor(mge_solitary_rclass$mge, levels = order_mge) # Convierte la variable mge en un factor, asignándole el orden definido en order_mge\nmge_solitary_rclass_p &lt;- gather_set_data(mge_solitary_rclass, 1:2) # Reestructura los datos con gather_set_data(), seleccionando las primeras dos columnas (1:2). NOTA: Se asume que esta función organiza los datos en un formato adecuado para un gráfico tipo \"alluvial\" o \"sankey\".\nmge_solitary_rclass_p$y &lt;- factor(mge_solitary_rclass_p$y, levels = c(order_class, order_mge)) # Convierte la variable y en un factor con el orden de order_class y order_mge, asegurando que los datos se alineen correctamente en la visualización.\nmge_solitary_rclass_p &lt;- mge_solitary_rclass_p %&gt;% add_column(col = colall[match(.$y, names(colall))])\n\n\nAñade una columna col con colores según la correspondencia entre los valores de y y los nombres en colall.\n\nmatch(.$y, names(colall)) encuentra el color correspondiente a cada categoría en colall.\nadd_column() agrega esta información a mge_solitary_rclass_p.\n\n\n\nrclass_mge_alluvial &lt;- ggplot(mge_solitary_rclass_p, aes(x, id = id, split = y, value = count)) +\n  # x = categorias, id = identificador unico para cada flujo\n  # split = y conexión entre las categorías (clases de recombinasas y tipos de MGE).\n  # value = count: determina el ancho de los flujos según la cantidad de ocurrencias.\n  # Dibujar los flujos entre categorías, con un grosor proporcional a count.\n  geom_parallel_sets(aes(fill = mge), color = \"black\", lwd = 0.2, axis.width = 0.26) +\n  geom_parallel_sets_axes(axis.width = 0.22, fill = \"grey80\") + # Dibuja los ejes de las categorías con un ancho de 0.22 y color gris claro (\"grey80\").\n  geom_parallel_sets_labels( # Añade etiquetas a los ejes con color negro, tamaño ajustado (12/.pt), y sin rotación (angle = 0).\n    color = 'black',\n    size = 12/.pt,\n    angle = 0\n  ) +\n  # Configuración de Escalas\n  scale_x_discrete(\n    name = NULL,\n    expand = c(0, 0.12)\n  ) +\n  # Elimina marcas en el eje y y ajusta la escala para mejor distribución visual.\n  scale_y_continuous(breaks = NULL, expand = c(0.1, 0)) +\n  # Asigna colores a los MGE según el vector colc y oculta la leyenda (guide = \"none\").\n  scale_fill_manual(\n  values = colc,\n    guide = \"none\"\n  ) +\n  labs(fill = \"\") +\n  theme_minimal() +\n  theme(\n    axis.text.x = element_blank(),\n    axis.line = element_blank(),\n    axis.ticks = element_blank(),\n    plot.margin = margin(14, 1.5, 2, 1.5)\n  )\nrclass_mge_alluvial\n\n\n\n\nPero esto no se ve como el articulo, por lo que decidimos cambiar el estilo de los bloques de texto a blanco con bordes negros.\n\nrclass_mge_alluvial &lt;- ggplot(mge_solitary_rclass_p, aes(x, id = id, split = y, value = count)) +\n  # x = categorias, id = identificador unico para cada flujo\n  # split = y conexión entre las categorías (clases de recombinasas y tipos de MGE).\n  # value = count: determina el ancho de los flujos según la cantidad de ocurrencias.\n  # Dibujar los flujos entre categorías, con un grosor proporcional a count.\n  geom_parallel_sets(aes(fill = mge), color = \"black\", lwd = 0.2, axis.width = 0.26) +\n  geom_parallel_sets_axes(axis.width = 0.22, fill = \"white\", color = \"black\") + # Dibuja los ejes de las categorías con un ancho de 0.22 y color blanco y borde negro\n  geom_parallel_sets_labels( # Añade etiquetas a los ejes con color negro, tamaño ajustado (12/.pt), y sin rotación (angle = 0).\n    color = 'black',\n    size = 12/.pt,\n    angle = 0\n  ) +\n  # Configuración de Escalas\n  scale_x_discrete(\n    name = NULL,\n    expand = c(0, 0.12)\n  ) +\n  # Elimina marcas en el eje y y ajusta la escala para mejor distribución visual.\n  scale_y_continuous(breaks = NULL, expand = c(0.1, 0)) +\n  # Asigna colores a los MGE según el vector colc y oculta la leyenda (guide = \"none\").\n  scale_fill_manual(\n  values = colc,\n    guide = \"none\"\n  ) +\n  labs(fill = \"\") +\n  theme_minimal() +\n  theme(\n    axis.text.x = element_blank(),\n    axis.line = element_blank(),\n    axis.ticks = element_blank(),\n    plot.margin = margin(14, 1.5, 2, 1.5)\n  )\n\n# Agregar titulos superiores\nrclass_mge_alluvial &lt;- rclass_mge_alluvial +\n  annotate(\"text\", x = 1, y = max(mge_solitary_rclass_p$count) * 2.5, label = \"recombinase \\nfamilies\", size = 5) +\nannotate(\"text\", x = 2, y = max(mge_solitary_rclass_p$count) * 2.5, label = \"MGEs\", size = 5)\n\n# Figura 2A completa\nrclass_mge_alluvial"
  },
  {
    "objectID": "Figura2.html#figura-2b-distribucion-de-mges-por-categoría",
    "href": "Figura2.html#figura-2b-distribucion-de-mges-por-categoría",
    "title": "Figura 2",
    "section": "Figura 2B Distribucion de MGEs por categoría",
    "text": "Figura 2B Distribucion de MGEs por categoría\nNúmero de MGEs por categoría (gráfico de barras) y porcentaje de cada categoría (gráfico de dona) en 76,000 genomas de 3,000 especies, utilizando el flujo de trabajo descrito en la Figura 1.\n\nPASO 5: Calcular el total de MGEs en todos los genomas (sin filtrar por calidad)\n\nmge_pg_melt_all &lt;- mge_pg %&gt;% \n  # Reestructura el data frame en formato largo (long format)\n  reshape2::melt() %&gt;% \n  # Selecciona columnas: columna 1 (genoma), 7 y 8 (variable y valor)\n  select(1,7,8) %&gt;% \n  # Agrupa por tipo de MGE (almacenado en 'variable')\n  group_by(variable) %&gt;% \n  # Suma el total de ocurrencias por cada MGE\n  summarise(total = sum(value)) %&gt;% \n  # Filtra para excluir los elementos anotados como \"Hotspot\"\n  filter(., !grepl(\"Hotspot\", variable))\n\nhead(mge_pg_melt_all)\n\n# A tibble: 6 × 2\n  variable     total\n  &lt;fct&gt;        &lt;dbl&gt;\n1 IS_Tn      1818135\n2 Phage       110316\n3 Phage_like  247907\n4 CE          101625\n5 Integron      8357\n6 MI          155857\n\n\n\n\nPASO 6: Calcular el total de MGEs pero solo para genomas de alta calidad\n\nmge_pg_melt &lt;- mge_pg %&gt;% \n  # Filtra para conservar solo los genomas presentes en la lista de alta calidad (glist_high)\n  filter(Genome %in% glist_high$genome) %&gt;% \n  # Reestructura el data frame en formato largo\n  reshape2::melt() %&gt;% \n  # Selecciona columnas relevantes: genoma, tipo de MGE, valor\n  select(1,7,8) %&gt;% \n  # Agrupa por tipo de MGE\n  group_by(variable) %&gt;% \n  # Suma el total de ocurrencias de cada MGE\n  summarise(total = sum(value)) %&gt;% \n  # Excluye los elementos anotados como \"Hotspot\"\n  filter(., !grepl(\"Hotspot\", variable))\n\nhead(mge_pg_melt)\n\n# A tibble: 6 × 2\n  variable     total\n  &lt;fct&gt;        &lt;dbl&gt;\n1 IS_Tn      1798076\n2 Phage       109456\n3 Phage_like  245051\n4 CE          100480\n5 Integron      8251\n6 MI          154239\n\n\n\n\nPASO 7: Generar un gráfico de barras para visualizar el total de MGEs en genomas de alta calidad\n\nbarplot_2b &lt;- ggplot(mge_pg_melt, aes(x = reorder(variable, total, sum), y = total, fill = variable)) +\n  # Crea barras con altura según el total\n  geom_bar(stat = 'identity') +\n  # Añade etiquetas con el valor total encima de cada barra\n  geom_text(aes(label = total)) + \n  # Invierte los ejes para una mejor visualización (barras horizontales)\n  coord_flip() +\n  # Aplica una paleta de colores personalizada (definida en 'colc') sin leyenda\n  scale_fill_manual(\"MGE\", values = colc, guide = FALSE) +\n  # Aplica el tema de cowplot para estilo limpio\n  theme_cowplot() + \n  # Añade etiquetas a los ejes\n  labs(x = \"\", y = \"Counts\")\n\n# Muestra el gráfico\nbarplot_2b\n\n\n\n\n\n\nPASO 8: Calcular la proporción relativa de cada MGE (excluyendo los de tipo “Cellular”) y genera etiquetas para graficar\n\nmge_pg_relative &lt;- mge_pg_melt %&gt;% \n  # Excluye las variables que contienen la palabra \"Cellular\"\n  filter(., !grepl(\"Cellular\", variable)) %&gt;% \n  # Calcula el porcentaje relativo de cada MGE respecto al total\n  mutate(\n    rel = round((total / sum(total)) * 100, digits = 2),\n    # Crea etiquetas con el nombre del MGE y su porcentaje\n    labs = paste0(variable, \" (\", rel, \"%)\")\n  ) %&gt;%\n  # Ordena por total ascendente para mejor visualización en la gráfica\n  arrange(total)\n\nhead(mge_pg_relative)\n\n# A tibble: 6 × 4\n  variable     total   rel labs               \n  &lt;fct&gt;        &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;              \n1 Integron      8251  0.34 Integron (0.34%)   \n2 CE          100480  4.16 CE (4.16%)         \n3 Phage       109456  4.53 Phage (4.53%)      \n4 MI          154239  6.39 MI (6.39%)         \n5 Phage_like  245051 10.1  Phage_like (10.14%)\n6 IS_Tn      1798076 74.4  IS_Tn (74.44%)     \n\n\n\n\nPASO 9: Generar un gráfico de dona (donut chart) para visualizar proporciones relativas de MGEs\n\ndonutchart_2b &lt;- ggdonutchart(\n  mge_pg_relative,     # Data frame con los porcentajes\n  \"rel\",               # Variable a usar como valor (porcentaje)\n  label = \"labs\",      # Etiquetas que se mostrarán en la gráfica\n  lab.pos = \"in\",      # Posición de etiquetas dentro del gráfico\n  fill = \"variable\",   # Colores de relleno asignados por tipo de MGE\n  color = \"white\",     # Color del borde de cada sección de la dona\n  # Paleta personalizada de colores para los MGEs\n  palette = c(\"#D55E00\", \"#E69F00\", \"#F0E442\", \"#56B4E9\", \"#009E73\", \"#0072B2\", \"#CECCCC\")\n)\n\n# Muestra el gráfico de dona\ndonutchart_2b\n\n\n\n\n\n\nPASO 10: Modificaciones de la Figura 2B\nEn esta versión del gráfico de barras, se hicieron dos ajustes importantes para mejorar la legibilidad de los números que aparecen al lado de cada barra:\n\nbarplot_2b &lt;- ggplot(mge_pg_melt, aes(x = reorder(variable, total, sum), y = total, fill = variable)) +\n  # Crea barras con altura según el total\n  geom_bar(stat = 'identity') +\n  # Añade etiquetas con el valor total encima de cada barra\n  geom_text(aes(label = total), hjust = -0.05) + \n  # Invierte los ejes para una mejor visualización (barras horizontales)\n  coord_flip() +\n  # Aplica una paleta de colores personalizada (definida en 'colc') sin leyenda\n  scale_fill_manual(\"MGE\", values = colc, guide = FALSE) +\n  # Aumentar el espacio extra a la derecha para que no se corten las etiquetas\n  scale_y_continuous(expand = expansion(mult = c(0, 0.2))) +\n  # Aplica el tema de cowplot para estilo limpio\n  theme_cowplot() + \n  # Añade etiquetas a los ejes\n  labs(x = \"\", y = \"Counts\")\n\n# Muestra el gráfico\nbarplot_2b\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nEl parámetro hjust = -0.05 mueve las etiquetas hacia la derecha del final de cada barra.\nSin esta modificación, los números podrían quedar demasiado pegados a la barra, o incluso encimarse o cortarse.\n💡 hjust controla la alineación horizontal:\n\nhjust = 1: texto alineado al final de la barra.\nhjust = 0: alineado al inicio de la barra.\nhjust &lt; 0: mueve el texto más allá del final, hacia la derecha.\n\n\n\n\nEn esta versión del gráfico de donut plot, se hicieron ajusto el texto para mejorar la legibilidad de las proporciones que aparecen al lado del plot:\n\n# Calcular proporciones y posiciones\nmge_pg_relative &lt;- mge_pg_melt %&gt;%\n  filter(!grepl(\"Cellular\", variable)) %&gt;%\n  mutate(\n    rel = round((total / sum(total)) * 100, 2),\n    labs = paste0(variable, \" (\", rel, \"%)\")\n  ) %&gt;%\n  arrange(desc(variable)) %&gt;%\n  mutate(\n    ymax = cumsum(rel),\n    ymin = c(0, head(ymax, n = -1)),\n    label_pos = (ymin + ymax) / 2\n  )\n\n# Gráfico de dona con etiquetas visibles y repelentes\ndonutchart_custom &lt;- ggplot(mge_pg_relative, aes(ymax = ymax, ymin = ymin, xmax = 4.5, xmin = 2.8, fill = variable)) +\n  geom_rect(color = \"white\") +\n  coord_polar(theta = \"y\") +\n  xlim(c(2.5, 5)) +  # Aumentamos espacio a la derecha para las etiquetas\n  theme_void() +\n  scale_fill_manual(values = c(\"#D55E00\", \"#E69F00\", \"#F0E442\", \"#56B4E9\", \"#009E73\", \"#0072B2\", \"#CECCCC\")) +\n  geom_text_repel(\n    aes(x = 4.5, y = label_pos, label = labs),\n    size = 4,\n    nudge_x = 0.5,\n    direction = \"y\",\n    segment.size = 0.3,\n    show.legend = FALSE,\n    min.segment.length = 0,\n    box.padding = 0.3\n  ) +\n  theme(legend.position = \"none\")\n\ndonutchart_custom\n\n\n\n\nUnir graficas\n\n# Insertar el donut plot dentro del barplot\nFig2B_combined_plot &lt;- ggdraw() +\n  draw_plot(barplot_2b) +  # Gráfico base\n  draw_plot(donutchart_custom, \n            x = 0.35, y = 0.05,       # Posición dentro del lienzo (ajustable)\n            width = 0.8, height = 0.8)  # Tamaño del donut ployt (ajustable)\n\nFig2B_combined_plot"
  },
  {
    "objectID": "Figura2.html#figura-2c-análisis-de-longitudes-de-mge-solitarios",
    "href": "Figura2.html#figura-2c-análisis-de-longitudes-de-mge-solitarios",
    "title": "Figura 2",
    "section": "Figura 2C Análisis de longitudes de MGE solitarios",
    "text": "Figura 2C Análisis de longitudes de MGE solitarios\n\nPASO 11: Obtener las longitudes (todos los genomas)\n\nmge_solitary_length_all &lt;- mge_solitary %&gt;% \n  select(1:11) %&gt;%  # Selecciona las primeras 11 columnas\n  gather(mge, mge_pa, 1:9) %&gt;%  # Convierte las columnas 1 a 9 a formato largo\n  filter(mge_pa == 1) %&gt;%  # Filtra solo las filas donde el MGE está presente\n  filter(., !grepl(\"UC\", mge)) %&gt;%  # Elimina filas con \"UC\" en el nombre del MGE\n  filter(., !grepl(\"Hotspot\", mge))  # Elimina filas con \"Hotspot\" en el nombre del MGE\n\n\n\nPASO 12: Obtener la longitud de MGEs de los genomas de alta calidad\n\nmge_solitary_length &lt;- mge_solitary %&gt;% \n  select(1:11) %&gt;%  # Selecciona las primeras 11 columnas\n  gather(mge, mge_pa, 1:9) %&gt;%  # Convierte las columnas 1 a 9 a formato largo\n  filter(mge_pa == 1) %&gt;%  # Filtra solo las filas donde el MGE está presente\n  filter(., !grepl(\"UC\", mge)) %&gt;%  # Elimina filas con \"UC\" en el nombre del MGE\n  filter(., !grepl(\"Hotspot\", mge)) %&gt;%  # Elimina filas con \"Hotspot\" en el nombre del MGE\n  separate(island, c(\"g1\", \"g2\", \"g3\")) %&gt;%  # Divide el nombre de la isla en tres partes\n  mutate(genome = paste(g1, g2, sep = \".\")) %&gt;%  # Re-crea el nombre del genoma usando g1 y g2\n  select(-g1, -g2, -g3) %&gt;%  # Elimina las columnas g1, g2 y g3\n  filter(genome %in% glist_high$genome)  # Filtra solo los genomas de alta calidad\n\n# Eliminar filas con NA\nmge_solitary_length_clean &lt;- mge_solitary_length %&gt;% na.omit()\n\n\n\nPASO 13: Graficar de caja de las longitudes de islas por tipo de MGE\n\nmge_length_boxplot &lt;- ggplot(mge_solitary_length, aes(x = reorder(mge, -island_size, median), y = island_size, fill = mge)) + \n  geom_boxplot(outlier.shape = NA, notch = FALSE, lwd = 1) +  # Crea un gráfico de caja sin mostrar los valores atípicos\n  scale_fill_manual(\"MGE\", values = colc, guide = FALSE) +  # Asigna colores personalizados para cada tipo de MGE\n  scale_y_continuous(limits = quantile(mge_solitary_length$island_size, c(0.1, 0.9))) +  # Limita el eje Y entre el percentil 10 y 90\n  coord_flip() +  # Rota el gráfico para que las categorías estén en el eje Y\n  labs(y = \"Length (bp)\", x = \"\") +  # Añade etiquetas a los ejes\n  theme_cowplot(font_size = 20)  # Aplica un tema limpio y ajusta el tamaño de fuente\n\n# Mostrar el gráfico\nmge_length_boxplot\n\n\n\n\n\n\nPASO 14: Unir la grafica final\n\n # Figura A en el lado izquierdo\nizquierda_plot &lt;- plot_grid(rclass_mge_alluvial, \n                            labels = 'A', label_size = 12,\n                            ncol = 1)# Establecer una sola columna para B y C\n\n# Figura B y C en el lado derecho\nderecha_plot &lt;- plot_grid(Fig2B_combined_plot, mge_length_boxplot, \n                            labels = c('B', 'C'), label_size = 12,\n                            ncol = 1)# Establecer una sola columna para B y C\n\n# Unir los gráficos\nFigura2_final_plot &lt;- plot_grid(\n  izquierda_plot,                      # Figura A en el lado izquierdo\n  derecha_plot,                    # Figura B y C en el lado derecho\n  ncol = 2,                         # Diseño en dos columnas\n  rel_widths = c(1, 1.5)        # Ajustar las proporciones de los anchos (A es más pequeño)\n)\n\n# Mostrar el gráfico final\nFigura2_final_plot\n\n\n\n\nPuedes encontrar el script completo en Figura2_modificado.R."
  },
  {
    "objectID": "Figura3.html",
    "href": "Figura3.html",
    "title": "Figura 3",
    "section": "",
    "text": "Figura 3. Distribución taxonómica de los MGEs\n\n\nA. Prevalencia de las categorías de MGEs y predominio de los elementos transponibles en distintas clases taxonómicas (con al menos 10 genomas), ordenadas según la filogenia basada en genes marcadores taxonómicos (38).\nB. Asociación de las categorías de MGEs (promedio de MGEs por especie) con diferentes clases taxonómicas (prueba de rango de Wilcoxon, * indica un valor de P &lt; 0.05 después de la corrección de Bonferroni).\n\nlibrary(tidyverse) # Manipulacion de datos\nlibrary(reshape2)\nlibrary(phytools)  # Manipulacion de arboles filogeneticos\nlibrary(ape)\nlibrary(viridisLite)\nlibrary(viridis)\nlibrary(scales)\nlibrary(cowplot)"
  },
  {
    "objectID": "Figura3.html#distribución-taxonómica-de-los-elementos-genéticos-móviles",
    "href": "Figura3.html#distribución-taxonómica-de-los-elementos-genéticos-móviles",
    "title": "Figura 3",
    "section": "",
    "text": "Figura 3. Distribución taxonómica de los MGEs\n\n\nA. Prevalencia de las categorías de MGEs y predominio de los elementos transponibles en distintas clases taxonómicas (con al menos 10 genomas), ordenadas según la filogenia basada en genes marcadores taxonómicos (38).\nB. Asociación de las categorías de MGEs (promedio de MGEs por especie) con diferentes clases taxonómicas (prueba de rango de Wilcoxon, * indica un valor de P &lt; 0.05 después de la corrección de Bonferroni).\n\nlibrary(tidyverse) # Manipulacion de datos\nlibrary(reshape2)\nlibrary(phytools)  # Manipulacion de arboles filogeneticos\nlibrary(ape)\nlibrary(viridisLite)\nlibrary(viridis)\nlibrary(scales)\nlibrary(cowplot)"
  },
  {
    "objectID": "Figura3.html#figura-3a",
    "href": "Figura3.html#figura-3a",
    "title": "Figura 3",
    "section": "Figura 3A",
    "text": "Figura 3A"
  },
  {
    "objectID": "Figura3.html#figura-3b",
    "href": "Figura3.html#figura-3b",
    "title": "Figura 3",
    "section": "Figura 3B",
    "text": "Figura 3B"
  },
  {
    "objectID": "Figura4.html",
    "href": "Figura4.html",
    "title": "Figura 4",
    "section": "",
    "text": "Figura 4. Transferencia horizontal de genes mediada por MGEs (HGT)\n\n\n\nLa ocurrencia de eventos recientes de HGT mediada por MGEs disminuye considerablemente con la distancia taxonómica.\nResumen de los eventos de HGT mediada por MGEs a través de un árbol filogenético (basado en genes marcadores filogenéticos) de clases taxonómicas. El mapa de calor cuantifica los eventos de HGT (coloreados según la leyenda en la parte inferior) entre las clases taxonómicas y los arcos indican la contribución de los elementos transponibles (en rojo) sobre otras categorías de MGEs (en gris).\nAnálisis de anidamiento de integrones con diferentes categorías de MGEs muestra su anidamiento significativo con CE-Elementos conjugativos (razón de probabilidades de Fisher 4.3, valor P = 2.9e−86) en el subconjunto de HGT en comparación con todas las ocurrencias anidadas.\nMapas de calor que ilustran la transferencia horizontal promiscuosa de elementos transponibles a través de hábitats en comparación con otras categorías de MGEs. Todas las categorías de MGEs muestran una alta dinámica de MGE"
  },
  {
    "objectID": "Figura4.html#transferencia-horizontal-de-genes-mediado-por-mges-hgt",
    "href": "Figura4.html#transferencia-horizontal-de-genes-mediado-por-mges-hgt",
    "title": "Figura 4",
    "section": "",
    "text": "Figura 4. Transferencia horizontal de genes mediada por MGEs (HGT)\n\n\n\nLa ocurrencia de eventos recientes de HGT mediada por MGEs disminuye considerablemente con la distancia taxonómica.\nResumen de los eventos de HGT mediada por MGEs a través de un árbol filogenético (basado en genes marcadores filogenéticos) de clases taxonómicas. El mapa de calor cuantifica los eventos de HGT (coloreados según la leyenda en la parte inferior) entre las clases taxonómicas y los arcos indican la contribución de los elementos transponibles (en rojo) sobre otras categorías de MGEs (en gris).\nAnálisis de anidamiento de integrones con diferentes categorías de MGEs muestra su anidamiento significativo con CE-Elementos conjugativos (razón de probabilidades de Fisher 4.3, valor P = 2.9e−86) en el subconjunto de HGT en comparación con todas las ocurrencias anidadas.\nMapas de calor que ilustran la transferencia horizontal promiscuosa de elementos transponibles a través de hábitats en comparación con otras categorías de MGEs. Todas las categorías de MGEs muestran una alta dinámica de MGE"
  },
  {
    "objectID": "Figura4.html#figura-4a",
    "href": "Figura4.html#figura-4a",
    "title": "Figura 4",
    "section": "Figura 4A",
    "text": "Figura 4A"
  },
  {
    "objectID": "Figura4.html#figura-4b",
    "href": "Figura4.html#figura-4b",
    "title": "Figura 4",
    "section": "Figura 4B",
    "text": "Figura 4B"
  },
  {
    "objectID": "Figura4.html#figura-4c",
    "href": "Figura4.html#figura-4c",
    "title": "Figura 4",
    "section": "Figura 4C",
    "text": "Figura 4C"
  },
  {
    "objectID": "Figura4.html#figura-4d",
    "href": "Figura4.html#figura-4d",
    "title": "Figura 4",
    "section": "Figura 4D",
    "text": "Figura 4D"
  },
  {
    "objectID": "Figura5.html",
    "href": "Figura5.html",
    "title": "Figura 5",
    "section": "",
    "text": "NOTA: Agregar el diagrama con descripcion del analisis.\n\n\n\n\nFigure 5.Antibiotic Resistance Genes (ARGs) carrying potential of MGEs.\n\n\n\nEl análisis de MGEs (por categoría) que transportan ARGs muestra un enriquecimiento de ARGs en elementos transponibles en comparación con otras regiones genómicas, lo que indica a los elementos transponibles como los principales transportadores de ARGs asociados a MGEs.\nAsociación de los mecanismos de resistencia a antibióticos con diferentes categorías de MGEs. Los asteriscos indican un enriquecimiento significativo según la prueba exacta de Fisher unilateral (valor P &lt; 0.05 después de la corrección de Bonferroni)."
  },
  {
    "objectID": "Figura5.html#potencial-de-los-mges-para-transportar-genes-de-resistencia-a-antibióticos-args",
    "href": "Figura5.html#potencial-de-los-mges-para-transportar-genes-de-resistencia-a-antibióticos-args",
    "title": "Figura 5",
    "section": "",
    "text": "NOTA: Agregar el diagrama con descripcion del analisis.\n\n\n\n\nFigure 5.Antibiotic Resistance Genes (ARGs) carrying potential of MGEs.\n\n\n\nEl análisis de MGEs (por categoría) que transportan ARGs muestra un enriquecimiento de ARGs en elementos transponibles en comparación con otras regiones genómicas, lo que indica a los elementos transponibles como los principales transportadores de ARGs asociados a MGEs.\nAsociación de los mecanismos de resistencia a antibióticos con diferentes categorías de MGEs. Los asteriscos indican un enriquecimiento significativo según la prueba exacta de Fisher unilateral (valor P &lt; 0.05 después de la corrección de Bonferroni)."
  },
  {
    "objectID": "Figura5.html#figura-5a",
    "href": "Figura5.html#figura-5a",
    "title": "Figura 5",
    "section": "Figura 5A",
    "text": "Figura 5A"
  },
  {
    "objectID": "Figura5.html#figura-5b",
    "href": "Figura5.html#figura-5b",
    "title": "Figura 5",
    "section": "Figura 5B",
    "text": "Figura 5B"
  },
  {
    "objectID": "glosario.html",
    "href": "glosario.html",
    "title": "Glosario",
    "section": "",
    "text": "Asignadas: Diana Barcelo y Marisol Navarro\nHola, soy Sol Hola, soy johanna"
  },
  {
    "objectID": "glosario.html#conceptos-importantes-del-articulo",
    "href": "glosario.html#conceptos-importantes-del-articulo",
    "title": "Glosario",
    "section": "",
    "text": "Asignadas: Diana Barcelo y Marisol Navarro\nHola, soy Sol Hola, soy johanna"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Sobre nosotras",
    "section": "",
    "text": "Esta sesión promueve la reproducibilidad del código, la buena documentación del código y buenas prácticas para generar un mejor futuro en la ciencia con acceso libre a la información. Siendo parte del Reprohack2025 de R-Ladies Morelia y RSG_Mexico."
  },
  {
    "objectID": "index.html#un-enfoque-computacional-para-el-estudio-de-los-elementos-genéticos-móviles-en-procariotas",
    "href": "index.html#un-enfoque-computacional-para-el-estudio-de-los-elementos-genéticos-móviles-en-procariotas",
    "title": "Sobre nosotras",
    "section": "Un enfoque computacional para el estudio de los elementos genéticos móviles en procariotas",
    "text": "Un enfoque computacional para el estudio de los elementos genéticos móviles en procariotas\nEl artículo explora cómo los elementos genéticos móviles (MGEs), como transposones, integrones, fagos y plásmidos, contribuyen a la evolución procariota y a la dispersión de resistencia a antibióticos. Usando un enfoque computacional basado en recombinasas y datos de pangenomas, analizaron ~84,000 genomas, identificando 2.8 millones de MGEs. Descubrieron que los elementos transponibles son los más abundantes y los principales portadores de genes de resistencia. Además, presentan una base de datos (http://promge.embl.de/) para futuras investigaciones.\nAquí puedes encontrar el artículo completo: Landscape of mobile genetic elements and their antibiotic resistance cargo in prokaryotic genomes"
  },
  {
    "objectID": "index.html#integrantes",
    "href": "index.html#integrantes",
    "title": "Sobre nosotras",
    "section": "Integrantes",
    "text": "Integrantes\n\nEvelia Coss - posdoctoral LIIGH-UNAM. Miembro de LupusRGMX, Project JAGUAR, RiaBio, CDSB-Mexico, RSG-México y RLadies Morelia. Coordinadora de los VieRnes de Bioinformatica en el LIIGH. Instructora Certificada de The Carpentries. Contacto: correo, pagina web\nMarisol Navarro - RSG-México y RLadies Morelia.\nDiana Barceló - Profesor investigador de tiempo completo de la Escuela de Medicina de la Universidad Quetzalcoatl. Editora en Jefe de la revista INVESMED (Investigación y Educación Médica). Miembro del cuerpo académico del AMFEM (Asociación Mexicana de Facultades y Escuelas de Medicina, A.C.)\nJohana Castelán - RSG-México y RLadies Morelia."
  },
  {
    "objectID": "index.html#citar-y-reutilizar-el-material-del-curso",
    "href": "index.html#citar-y-reutilizar-el-material-del-curso",
    "title": "Sobre nosotras",
    "section": "Citar y reutilizar el material del curso",
    "text": "Citar y reutilizar el material del curso\nLos datos del curso se pueden reutilizar y adaptar libremente con la debida atribución. Todos los datos de los cursos de estos repositorios están sujetos a la licencia Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)."
  },
  {
    "objectID": "index.html#patrocinadores",
    "href": "index.html#patrocinadores",
    "title": "Sobre nosotras",
    "section": "Patrocinadores",
    "text": "Patrocinadores\n\n    \n\n\nCursos hechos con amor 💜"
  },
  {
    "objectID": "resumen.html",
    "href": "resumen.html",
    "title": "Resumen",
    "section": "",
    "text": "Resumen: Diana Barcelo\nAquí puedes encontrar el artículo completo: Landscape of mobile genetic elements and their antibiotic resistance cargo in prokaryotic genomes"
  },
  {
    "objectID": "resumen.html#reprohack-landscape-of-mobile-genetic-elements-and-their-antibiotic-resistance-cargo-in-prokaryotic-genomes",
    "href": "resumen.html#reprohack-landscape-of-mobile-genetic-elements-and-their-antibiotic-resistance-cargo-in-prokaryotic-genomes",
    "title": "Resumen",
    "section": "",
    "text": "Resumen: Diana Barcelo\nAquí puedes encontrar el artículo completo: Landscape of mobile genetic elements and their antibiotic resistance cargo in prokaryotic genomes"
  },
  {
    "objectID": "retos.html",
    "href": "retos.html",
    "title": "Retos y problemas con el código",
    "section": "",
    "text": "Notas clave:\n\nUso de Archivos Comprimidos: Cuando trabajen con archivos comprimidos (por ejemplo, con extensión .gz), no es necesario descomprimirlos manualmente antes de cargarlos en R.\nCódigo Correcto para Cargar Archivos Comprimidos: Para cargar archivos comprimidos sin descomprimirlos previamente, utilicen el siguiente código:\n\n\nmge_pg &lt;- read_tsv(\"data/processed_data/mge_bins_per_genome_final.txt.gz\", col_names = TRUE)\n\n\nDiferencia con el Código Original: En el código original, el archivo estaba descomprimido. Sin embargo, con la extensión .gz, se puede leer directamente el archivo comprimido sin la necesidad de usar herramientas adicionales para descomprimirlo."
  },
  {
    "objectID": "retos.html#carga-de-archivos-comprimidos-en-r",
    "href": "retos.html#carga-de-archivos-comprimidos-en-r",
    "title": "Retos y problemas con el código",
    "section": "",
    "text": "Notas clave:\n\nUso de Archivos Comprimidos: Cuando trabajen con archivos comprimidos (por ejemplo, con extensión .gz), no es necesario descomprimirlos manualmente antes de cargarlos en R.\nCódigo Correcto para Cargar Archivos Comprimidos: Para cargar archivos comprimidos sin descomprimirlos previamente, utilicen el siguiente código:\n\n\nmge_pg &lt;- read_tsv(\"data/processed_data/mge_bins_per_genome_final.txt.gz\", col_names = TRUE)\n\n\nDiferencia con el Código Original: En el código original, el archivo estaba descomprimido. Sin embargo, con la extensión .gz, se puede leer directamente el archivo comprimido sin la necesidad de usar herramientas adicionales para descomprimirlo."
  },
  {
    "objectID": "tema2.html",
    "href": "tema2.html",
    "title": "Buenas prácticas en la bioinformática",
    "section": "",
    "text": "La bioinformática, en relación con la genética y la genómica 🔬, es una subdisciplina científica que implica el uso de ciencias informáticas 📈 para recopilar, almacenar, analizar y diseminar datos biológicos, como secuencias de ADN y aminoácidos o anotaciones sobre esas secuencias NIH, 2023.\nUno de sus objetivos es: Aumentar el entendimiento de la salud y la enfermedad, en ciertos casos, se usan para proveer mejor atención médica NIH, 2023.\nNIH: National Human Genome Research Institute\n\n\nHacia una biología computacional más reproducible, transparente y colaborativa 💜\n\n“Los hechos individuales no reproducibles no tienen ninguna importancia para la ciencia”\nKarl Popper\n\nMás información aquí."
  },
  {
    "objectID": "tema2.html#bioinformática-se-conforma-de-la-computación-biológica-matemáticas-y-estadística",
    "href": "tema2.html#bioinformática-se-conforma-de-la-computación-biológica-matemáticas-y-estadística",
    "title": "Buenas prácticas en la bioinformática",
    "section": "",
    "text": "La bioinformática, en relación con la genética y la genómica 🔬, es una subdisciplina científica que implica el uso de ciencias informáticas 📈 para recopilar, almacenar, analizar y diseminar datos biológicos, como secuencias de ADN y aminoácidos o anotaciones sobre esas secuencias NIH, 2023.\nUno de sus objetivos es: Aumentar el entendimiento de la salud y la enfermedad, en ciertos casos, se usan para proveer mejor atención médica NIH, 2023.\nNIH: National Human Genome Research Institute\n\n\nHacia una biología computacional más reproducible, transparente y colaborativa 💜\n\n“Los hechos individuales no reproducibles no tienen ninguna importancia para la ciencia”\nKarl Popper\n\nMás información aquí."
  },
  {
    "objectID": "tema2.html#un-algoritmo-nos-permite-resolver-un-problema",
    "href": "tema2.html#un-algoritmo-nos-permite-resolver-un-problema",
    "title": "Buenas prácticas en la bioinformática",
    "section": "Un algoritmo nos permite resolver un problema ⭐",
    "text": "Un algoritmo nos permite resolver un problema ⭐\nUn algoritmo es un método para resolver un problema mediante una serie de pasos definidos, precisos y finitos.\n\nDefinido: si se sigue dos veces, se obtiene el mismo resultado. Es reproducible.\nPreciso: implica el orden de realización de cada uno de los pasos.\nFinito: Tiene un numero determinado de pasos, implica que tiene un fin.\n\n\nUn algoritmo podemos definirlo como un programa o software."
  },
  {
    "objectID": "tema2.html#para-escribir-un-buen-software-necesitas",
    "href": "tema2.html#para-escribir-un-buen-software-necesitas",
    "title": "Buenas prácticas en la bioinformática",
    "section": "Para escribir un buen software necesitas:",
    "text": "Para escribir un buen software necesitas:\n\nEscribir código mantenible (maintainable code), usar control de versiones (version control) y rastreadores de problemas (issue trackers), revisiones de código (code reviews), pruebas unitarias (unit testing) y automatización de tareas (task automation).\nWilson, et al. 2014. PLOS Biology\n\nCon el fin de previnir retracciones.\nMás información en Best Practices for Scientific Computing - The Carpentries."
  },
  {
    "objectID": "tema2.html#código-reproducible",
    "href": "tema2.html#código-reproducible",
    "title": "Buenas prácticas en la bioinformática",
    "section": "Código reproducible 🌟",
    "text": "Código reproducible 🌟\n\nContenedores ⚡\n\nDocker\nSingularity\nApptainer\n\nSe puede almacenar todo el workflow, archivos, generando codigo reproducible y cooperativo.\n\nMinicurso del uso de Docker.\n\n\n\nCrear pipelines completos 🌀\n\nNextflow\nSnakemake"
  },
  {
    "objectID": "tema2.html#pasos-para-escribir-un-buen-software",
    "href": "tema2.html#pasos-para-escribir-un-buen-software",
    "title": "Buenas prácticas en la bioinformática",
    "section": "Pasos para escribir un buen software",
    "text": "Pasos para escribir un buen software\n\nAnálisis del problema / Definir el problema\nDiseño del algoritmo / Diseño del programa\nCodificación / Escribir el código\nCompilación y ejecución del programa\nVerificación / Realizar pruebas\nDepuración / Detectar los errores y corregirlos\n\n\nProgramacion defensiva\n\n\nDocumentación"
  },
  {
    "objectID": "tema2.html#puntos-claves-para-buenas-practicas-en-bioinfo",
    "href": "tema2.html#puntos-claves-para-buenas-practicas-en-bioinfo",
    "title": "Buenas prácticas en la bioinformática",
    "section": "Puntos claves para buenas practicas en bioinfo ⭐",
    "text": "Puntos claves para buenas practicas en bioinfo ⭐\n\nEscriba programas para personas, no para computadoras (Documenta qué hace y por qué). - Se coherente en la nomenclatura, indentación y otros aspectos del estilo.\nDivide los programas en *funciones cortas de un solo propósito. 💻 📚\nNo repitas tu código. Crea pasos reproducibles o que se repitan por si solas. ➰\nPlanifique los errores (Programacion defensiva) 🚩\nOptimice el software sólo después de que funcione correctamente. - Si funciona no lo modifiques, simplificalo.\nColaborar - Busque siempre bibliotecas de software bien mantenidas que hagan lo que necesita. 👥"
  },
  {
    "objectID": "tema3.html",
    "href": "tema3.html",
    "title": "Reprocesamiento de los datos",
    "section": "",
    "text": "A partir de la pagina web de Git proMGE realizamos modificaciones de los scripts para mejorar la documentación de los mismos."
  },
  {
    "objectID": "tema3.html#datos",
    "href": "tema3.html#datos",
    "title": "Reprocesamiento de los datos",
    "section": "Datos",
    "text": "Datos\n\nModificado por Evelia Coss\n\nTodos los datos utilizados en este estudio están publicados y a disposición del público, como se indica en la sección de material y métodos del manuscrito.\n\nLos datos de todos los genomas procariotas utilizados en el estudio están disponibles en https://progenomes.embl.de/.\nLa información sobre el hábitat está disponible en GMGC.\n\n\n\n\nFlujo de trabajo para la identificación de elementos genéticos móviles (MGEs) en procariotas y análisis de carga genética. (A) Se anotaron cinco familias principales de recombinasas en proGenomes2 usando HMMs a nivel de subfamilia y validación con EggNOG y RefSeq. (B) Se asignaron recombinasas a seis categorías de MGEs y se diferenciaron de recombinasas celulares mediante análisis de límites de pangenomas, asociación con subfamilias y la presencia de genes accesorios específicos. (C) Se presentan ejemplos de MGEs con genes de resistencia a antibióticos (ARG), destacando su novedad en aspectos como diversificación funcional, MGEs anidados, transferencia horizontal de genes entre dominios de vida y nuevas asociaciones de dominios proteicos."
  },
  {
    "objectID": "tema3.html#procesamiento-de-datos-para-la-figuras",
    "href": "tema3.html#procesamiento-de-datos-para-la-figuras",
    "title": "Reprocesamiento de los datos",
    "section": "Procesamiento de datos para la Figuras",
    "text": "Procesamiento de datos para la Figuras\nLos autores nos informan que se realizaron modificacione sobre los inputs para generar las Figuras 2 a 5 empleando codigo de perl. Para mas informacion vista la fuente original del Git."
  },
  {
    "objectID": "tema4.html",
    "href": "tema4.html",
    "title": "Reproducción de figuras",
    "section": "",
    "text": "A partir de la pagina web de Git proMGE realizamos modificaciones de los scripts para mejorar la documentación de los mismos."
  },
  {
    "objectID": "tema4.html#figuras-y-scripts",
    "href": "tema4.html#figuras-y-scripts",
    "title": "Reproducción de figuras",
    "section": "Figuras y scripts",
    "text": "Figuras y scripts\n\nModificado por Johana\n\n\n\n\nFigura\nScript original\nScript modificado (en español)\nInput\n\n\n\n\nFigura 2\nR/Figure2.R\n\n\n\n\nFigura 3\nR/Figure3.R\n\n\n\n\nFigura 4\nR/Figure4.R\n\n\n\n\nFigura 5\nR/Figure5.R"
  },
  {
    "objectID": "Figura3.html#mapa-de-colores-para-filogenia",
    "href": "Figura3.html#mapa-de-colores-para-filogenia",
    "title": "Figura 3",
    "section": "Mapa de colores para filogenia",
    "text": "Mapa de colores para filogenia\n\n## Crear el mapa de calor filogenético con normalización de los valores\nnormalize &lt;- function(x) {  # Función para normalizar los valores entre 0 y 1\n  x/max(x)\n}\n\n# Crear la matriz de datos para el mapa de calor filogenético\nphylo_heatmap_mat &lt;- all_avg_cnt_tax_class_sel1 %&gt;% \n  # Filtrar clases que no contienen \"NA\"\n  filter(!grepl(\"NA \", class)) %&gt;%  \n  # Convertir los datos en formato ancho (cada variable como columna)\n  spread(variable, avg_class) %&gt;%  \n  # Seleccionar las variables de interés\n  dplyr::select(class, IS_Tn, Phage, Phage_like, CE, Integron, MI) %&gt;%  \n  # Establecer las clases como nombres de fila\n  column_to_rownames(var = \"class\")  \n\n\n# Crear el árbol filogenético manteniendo solo las especies que están en la matriz de datos del mapa de calor\nclass_tree_w_g9 &lt;- keep.tip(class_tree, tip = rownames(phylo_heatmap_mat))\n\n## Ajuste de colores para el mapa de calor filogenético para datos sesgados\nsmall_value &lt;- unique(sort(unlist(phylo_heatmap_mat)))[2]  # Encuentra el segundo valor más pequeño en la matriz de datos para establecer un umbral\nsmall_value &lt;- small_value - small_value %% 0.001  # Redondea el valor a 3 decimales para crear un valor pequeño ajustado\n\n# Histograma para visualizar la distribución de los datos en la matriz\nhist(unlist(phylo_heatmap_mat), nclass = 50)\n\n\n\n# Definir los puntos de corte para el mapa de calor según la distribución de los datos\nheatmap_breaks &lt;- c(0, small_value, 1, 2, 3, 4, seq(5, 55, 10))\n\n# Histograma con los puntos de corte definidos para el mapa de calor\nhist(unlist(phylo_heatmap_mat), breaks = heatmap_breaks, freq = T)\n\n\n\n# Definir una paleta de colores basada en viridis, con un sesgo hacia valores más bajos\nplot_colors &lt;- c(\"white\", colorRampPalette((viridis(10)), bias = 5)(length(heatmap_breaks) - 2))\n\n# Crear una matriz de significancia (signP) para etiquetar el mapa de calor\nsig_mat &lt;- plot_table_w_g9 %&gt;% \n  select(class, variable, signP)  # Selecciona las columnas relevantes de los datos\n\n# Filtra las filas que contienen \"NA\" en la columna \"class\" y transforma los datos a formato ancho\nsig_mat &lt;- sig_mat %&gt;% \n  filter(!grepl(\"NA \", class)) %&gt;%\n  spread(variable, signP) %&gt;%  # Transforma los datos para que las variables sean columnas\n  column_to_rownames(var = \"class\")  # Establece la columna \"class\" como nombres de fila\n\n# Alinea la matriz de significancia con el árbol filogenético\nsig_mat &lt;- sig_mat[class_tree_w_g9$tip.label, colnames(phylo_heatmap_mat)]"
  },
  {
    "objectID": "Figura3.html#paso-9-cargar-funciones",
    "href": "Figura3.html#paso-9-cargar-funciones",
    "title": "Figura 3",
    "section": "PASO 9: Cargar funciones",
    "text": "PASO 9: Cargar funciones\n\nsource(\"scripts/phylo_function.R\")\n\n\nPASO 10: Obtener las coordenadas\n\n# 1. Extraer coordenadas del heatmap filogenético para añadir anotaciones manuales posteriormente\nxx_yy &lt;- phylo.heatmap.coords(\n  class_tree_w_g9,           # árbol filogenético de clases\n  phylo_heatmap_mat,         # matriz de abundancias promedio por clase y MGE\n  fsize = c(0.8, 0.9, 0.7),  # tamaños de fuente (árbol, heatmap, leyenda)\n  colors = plot_colors,      # colores personalizados para el heatmap\n  grid = TRUE,               # mostrar rejilla en el heatmap\n  split = c(0.7, 0.3),       # proporción de espacio entre árbol y heatmap\n  lwd = 1,                   # grosor de líneas\n  breaks = heatmap_breaks,   # puntos de corte para los colores\n  mar = c(1.2,1.2,1.2,1.2)   # márgenes\n)\n\n## 2. Generar el heatmap con leyenda incluida, usando los mismos parámetros que el paso anterior\nphylo.heatmap.legendmod(\n  class_tree_w_g9,\n  phylo_heatmap_mat,\n  fsize = c(0.8, 0.9, 0.7),\n  colors = plot_colors,\n  grid = TRUE,\n  split = c(0.7, 0.3),\n  lwd = 1,\n  breaks = heatmap_breaks,\n  mar = c(1.2,1.2,1.2,1.2)\n)\n\n## 3. Añadir símbolos de significancia (\"*\") en cada celda de la matriz que lo indique (en 'sig_mat')\nfor(i in 1:nrow(sig_mat)) {\n  for(j in 1:ncol(sig_mat)) {\n    if(sig_mat[i,j] == \"*\") {\n      rnm &lt;- rownames(sig_mat)[i]  # nombre de la fila (clase taxonómica)\n      cnm &lt;- colnames(sig_mat)[j]  # nombre de la columna (MGE)\n      \n      # Añadir el símbolo \"*\" en la posición correspondiente del heatmap\n      points(\n        xx_yy$xx[j], xx_yy$yy[i],   # coordenadas x, y para esa celda\n        cex = 1.5,                  # tamaño del símbolo\n        col = if (phylo_heatmap_mat[rnm, cnm] &lt; heatmap_breaks[3]) \"white\" else \"black\", \n        pch = \"*\"                   # símbolo a dibujar\n      )\n    }\n  }\n}"
  },
  {
    "objectID": "Figura3.html#figura-3a-barplot-de-abundancia-relativa-de-mges-por-clase-taxonómica",
    "href": "Figura3.html#figura-3a-barplot-de-abundancia-relativa-de-mges-por-clase-taxonómica",
    "title": "Figura 3",
    "section": "Figura 3A Barplot de abundancia relativa de MGEs por clase taxonómica",
    "text": "Figura 3A Barplot de abundancia relativa de MGEs por clase taxonómica\n\n# 1. Seleccionar clases que aparecen al menos 10 veces para asegurar una representación confiable.\nallclass_all &lt;- all_avg_cnt_tax_class %&gt;%\n  # Usar una sola MGE como referencia para el conteo por clase\n  filter(mge == all_avg_cnt_tax_class$mge[1]) %&gt;%          \n  group_by(class) %&gt;%\n  summarise(cntclass = n()) %&gt;%\n  # Incluir solo clases con al menos 10 ocurrencias\n  filter(cntclass &gt; 9)                                     \n\n# 2. Filtrar datos: eliminar MGEs de tipo \"Cellular\" o \"Hotspot\" y mantener solo las clases seleccionadas previamente.\nall_avg_cnt_tax_class_sel_all &lt;- all_avg_cnt_tax_class %&gt;%\n  filter(!grepl(\"Cellular\", mge)) %&gt;%\n  filter(!grepl(\"Hotspot\", mge)) %&gt;%\n  filter(class %in% allclass_all$class) %&gt;%\n  group_by(mge, class) %&gt;%\n  # Promediar por combinación de clase y MGE\n  summarise(avg_class = mean(avg_cnt), .groups = \"drop\")   \n\n# 3. Calcular la suma total de abundancia de MGEs por clase (para obtener proporciones después)\nall_avg_cnt_tax_class_sel_all_mge_all &lt;- all_avg_cnt_tax_class_sel_all %&gt;%\n  group_by(class) %&gt;%\n  summarise(total_mge = sum(avg_class), .groups = \"drop\")\n\n# 4. Combinar abundancia promedio por clase y MGE con el total por clase\n#    Calcular la fracción relativa de cada MGE dentro de cada clase\nall_avg_cnt_tax_class_sel_4bar_all &lt;- left_join(\n  all_avg_cnt_tax_class_sel_all,\n  all_avg_cnt_tax_class_sel_all_mge_all,\n  by = \"class\"\n) %&gt;%\n  group_by(class, mge, total_mge) %&gt;%\n  summarise(frac = avg_class / total_mge, .groups = \"drop\")\n\n# 5. Limpiar datos y ordenar clases según el orden filogenético del árbol\nbarplot_mat &lt;- all_avg_cnt_tax_class_sel_4bar_all %&gt;%\n  # Eliminar clases no identificadas\n  filter(!grepl(\"NA \", class))  \n\n# Mantener orden del árbol filogenético\nbarplot_mat$class &lt;- factor(barplot_mat$class,\n                            levels = species_labels)  \n\n# 6. Preparar datos auxiliares para anotaciones en el barplot (por ejemplo, totales por clase)\nbarplot_mat_for_n &lt;- all_avg_cnt_tax_class_sel_all_mge_all %&gt;%\n  filter(!grepl(\"NA \", class))\nbarplot_mat_for_n$class &lt;- factor(barplot_mat_for_n$class,\n                                  levels = species_labels)\n\nCrear barplot apilado (horizontal) de la proporción relativa de MGEs por clase taxonómica\n\n# Define el orden deseado de las categorías en la leyenda (de MI a IS_Tn)\ncategory_order &lt;- c(\"MI\", \"Integron\", \"CE\", \"Phage_like\", \"Phage\", \"IS_Tn\")\n\n# Generar la grafica base\nbarplot_specI_class_count_all &lt;- ggplot(barplot_mat, aes(y = class, x = frac, fill = mge)) +  \n   # Barras horizontales, borde gris\n  geom_bar(stat = \"identity\", color = \"grey60\") +                         \n  # Colores personalizados para los MGEs\n  scale_fill_manual(\"MGE\", values = colc)                                   \n\n## Añadir detalles estéticos y anotaciones\nFig3A_barplot &lt;- barplot_specI_class_count_all +\n  # Límite extendido para espacio de anotaciones\n  scale_x_continuous(\n    breaks = c(0, 0.25, 0.5, 0.75, 1.0),\n    limits = c(0, 1.1)                                                     \n  ) +\n  geom_text(\n    data = barplot_mat_for_n,\n    # Mostrar suma total de MGEs por clase\n    mapping = aes(y = class, x = 1.05, label = paste(\"\", round(total_mge))), \n    inherit.aes = FALSE,\n    col = \"black\",\n    size = 6) +\n  # Agregar un título en una posición personalizada\n  annotate(\"text\", x = 1.05, y = 23.5, label = \"Avg. MGE\", size = 6, fontface = \"bold\", color = \"black\") +\n  # etiquetas\n  labs(title = \"Relative proportion\",y = \"\",  x = \"\") +\n   # Estética limpia estilo Cowplot\n  theme_cowplot(font_size = 20) + \n  # Etiquetas del eje X horizontales\n  theme(\n    axis.text.y = element_blank(), #  axis.text.y = element_text(hjust = 0, vjust = 0.5) # Alinear texto del eje Y\n    axis.text.x = element_text(angle = 0),   \n    legend.position = \"bottom\",       # Leyenda abajo \n    legend.direction = \"horizontal\",  # Disposición horizontal de la leyenda\n    plot.title = element_text(hjust = 0.5, size = 24)  # Centrar y estilizar el título\n    ) +  \n  # Asegura que las categorías estén en una sola fila\n guides(fill = guide_legend(ncol = length(category_order)))  \n\nFig3A_barplot\n\n\n\n\n\nUnir figura\n\nFig3A_final_plot &lt;- plot_grid(p_phylo_heatmap, Fig3A_barplot, ncol = 2, align = \"v\", rel_widths = c(1.5, 1))\nFig3A_final_plot\n\n\n\n\nPuedes encontrar el script completo en Figura3_modificado.R."
  },
  {
    "objectID": "Figura3.html#datos-para-mapa-de-colores-para-filogenia",
    "href": "Figura3.html#datos-para-mapa-de-colores-para-filogenia",
    "title": "Figura 3",
    "section": "Datos para Mapa de colores para filogenia",
    "text": "Datos para Mapa de colores para filogenia\n\n## Crear el mapa de calor filogenético con normalización de los valores\nnormalize &lt;- function(x) {  # Función para normalizar los valores entre 0 y 1\n  x/max(x)\n}\n\n# Crear la matriz de datos para el mapa de calor filogenético\nphylo_heatmap_mat &lt;- all_avg_cnt_tax_class_sel1 %&gt;% \n  # Filtrar clases que no contienen \"NA\"\n  filter(!grepl(\"NA \", class)) %&gt;%  \n  # Convertir los datos en formato ancho (cada variable como columna)\n  spread(variable, avg_class) %&gt;%  \n  # Seleccionar las variables de interés\n  dplyr::select(class, IS_Tn, Phage, Phage_like, CE, Integron, MI) %&gt;%  \n  # Establecer las clases como nombres de fila\n  column_to_rownames(var = \"class\")  \n\n\n# Crear el árbol filogenético manteniendo solo las especies que están en la matriz de datos del mapa de calor\nclass_tree_w_g9 &lt;- keep.tip(class_tree, tip = rownames(phylo_heatmap_mat))\n\n## Ajuste de colores para el mapa de calor filogenético para datos sesgados\nsmall_value &lt;- unique(sort(unlist(phylo_heatmap_mat)))[2]  # Encuentra el segundo valor más pequeño en la matriz de datos para establecer un umbral\nsmall_value &lt;- small_value - small_value %% 0.001  # Redondea el valor a 3 decimales para crear un valor pequeño ajustado\n\n# Definir los puntos de corte para el mapa de calor según la distribución de los datos\nheatmap_breaks &lt;- c(0, small_value, 1, 2, 3, 4, seq(5, 55, 10))\n\n# Definir una paleta de colores basada en viridis, con un sesgo hacia valores más bajos\nplot_colors &lt;- c(\"white\", colorRampPalette((viridis(10)), bias = 5)(length(heatmap_breaks) - 2))\n\n# Crear una matriz de significancia (signP) para etiquetar el mapa de calor\nsig_mat &lt;- plot_table_w_g9 %&gt;% \n  select(class, variable, signP)  # Selecciona las columnas relevantes de los datos\n\n# Filtra las filas que contienen \"NA\" en la columna \"class\" y transforma los datos a formato ancho\nsig_mat &lt;- sig_mat %&gt;% \n  filter(!grepl(\"NA \", class)) %&gt;%\n  spread(variable, signP) %&gt;%  # Transforma los datos para que las variables sean columnas\n  column_to_rownames(var = \"class\")  # Establece la columna \"class\" como nombres de fila\n\n# Alinea la matriz de significancia con el árbol filogenético\nsig_mat &lt;- sig_mat[class_tree_w_g9$tip.label, colnames(phylo_heatmap_mat)]"
  },
  {
    "objectID": "Figura3.html#paso-1-importar-datos",
    "href": "Figura3.html#paso-1-importar-datos",
    "title": "Figura 3",
    "section": "PASO 1: Importar datos",
    "text": "PASO 1: Importar datos\n\ntax &lt;- read_tsv(\"data/raw_data/species_with_atleast_2genomes.list.gz\", col_names=F)\ndb &lt;-read_tsv(\"data/processed_data/mge_bins_per_genome_final.txt.gz\", col_names = T)\ngs &lt;-read_tsv(\"data/raw_data/genome_size.txt.gz\", col_names = T)\nclass_tree &lt;- read.tree(\"data/raw_data/progenomes2_class_tree.nwk\")\nglist &lt;- read_tsv(\"data/raw_data/genome_status_supplementary_tableS2.txt.gz\", col_names = T)\n\nCargar paleta de colores\n\n# Paleta general de colores\ncolc &lt;- c(\"#D55E00\", \"#E69F00\", \"#F0E442\", \"#56B4E9\", \"#009E73\", \"#0072B2\",\"#CECCCC\")\nnames(colc) &lt;- c(\"IS_Tn\", \"Phage\", \"Phage_like\", \"CE\", \"Integron\", \"MI\", \"Cellular\")"
  },
  {
    "objectID": "Figura3.html#paso-2-manipulación-y-limpieza-de-los-datos",
    "href": "Figura3.html#paso-2-manipulación-y-limpieza-de-los-datos",
    "title": "Figura 3",
    "section": "PASO 2: Manipulación y Limpieza de los datos",
    "text": "PASO 2: Manipulación y Limpieza de los datos\n\n# Obtener los genomas con la mas alta calidad\nglist_high &lt;- glist %&gt;% \n  filter(genome_quality == \"high\")\n\n\n# Renombra las columnas del dataframe tax para un nombre más legible\ncolnames(tax) &lt;- c(\"specI\", \"genomeID\", \"kingdom\", \"phylum\", \"class\", \"genus\")\n\n# Reestructura la base de datos 'db' de formato ancho a largo usando reshape2::melt\nmdb &lt;- db %&gt;% reshape2::melt() \n\n# Renombra las columnas de la base de datos reestructurada para claridad\nmdb &lt;- mdb %&gt;% \n  dplyr::rename(mge = variable, count = value, genomeID = 'Genome') %&gt;% \n  # Filtra para incluir solo los genomas de alta calidad (genomas en glist_high$genome)\n  filter(genomeID %in% glist_high$genome)"
  },
  {
    "objectID": "Figura3.html#paso-3-data.frame-con-combinaciones",
    "href": "Figura3.html#paso-3-data.frame-con-combinaciones",
    "title": "Figura 3",
    "section": "PASO 3: Data.frame con combinaciones",
    "text": "PASO 3: Data.frame con combinaciones\n\nDatos de formato\nCrear un data.frame que contenga para cada specI para cada MGE: recuentos genómicos (genomeCnt),\n\nconteos totales (cnt_tot),\npromedio de recuentos entre genomas (avg_cnt),\nnúmero de genomas en los que estaba presente el MGE (pa),\nla fracción de genomas con el MGE presente (frac) más información taxonómica\n\n\n# Selecciona las columnas necesarias para trabajar con los datos\nmdb_cnt &lt;- mdb %&gt;% select(1, 7, 8)\n# Obtiene los valores únicos de MGE\nall_mge &lt;- unique(mdb$mge)\n\n# Inicializa un data.frame vacío donde se almacenarán las combinaciones\ndb_tax &lt;- NULL       \n\n# Itera sobre todos los valores únicos de MGE\nfor(i in 1:length(all_mge)){\n  # Para cada MGE, se agrega una nueva columna 'mge' con el valor del MGE actual\n  db_tax_sing &lt;- tax %&gt;% add_column(mge = all_mge[i])\n  # Une el data.frame actual con el anterior (rbind), creando una tabla con todas las combinaciones\n  db_tax &lt;- rbind(db_tax, db_tax_sing)\n}\n# Muestra las primeras filas del data.frame resultante\nhead(db_tax)\n\n# A tibble: 6 × 7\n  specI               genomeID             kingdom  phylum         class               genus            mge  \n  &lt;chr&gt;               &lt;chr&gt;                &lt;chr&gt;    &lt;chr&gt;          &lt;chr&gt;               &lt;chr&gt;            &lt;fct&gt;\n1 specI_v3_Cluster1   100053.SAMN02947772  Bacteria Spirochaetes   Spirochaetia        Leptospirales    IS_Tn\n2 specI_v3_Cluster201 1000561.SAMN02471202 Bacteria Proteobacteria Gammaproteobacteria Pseudomonadales  IS_Tn\n3 specI_v3_Cluster361 1000562.SAMN03114893 Bacteria Firmicutes     Bacilli             Lactobacillales  IS_Tn\n4 specI_v3_Cluster371 1000565.SAMN02471991 Bacteria Proteobacteria Betaproteobacteria  Nitrosomonadales IS_Tn\n5 specI_v3_Cluster564 1000568.SAMN00255229 Bacteria Firmicutes     Negativicutes       Veillonellales   IS_Tn\n6 specI_v3_Cluster565 1000569.SAMN00255226 Bacteria Firmicutes     Negativicutes       Veillonellales   IS_Tn"
  },
  {
    "objectID": "Figura3.html#paso-4-contar-el-número-de-genomas-por-especie-y-clase-taxonómica",
    "href": "Figura3.html#paso-4-contar-el-número-de-genomas-por-especie-y-clase-taxonómica",
    "title": "Figura 3",
    "section": "PASO 4: Contar el número de genomas por especie y clase taxonómica",
    "text": "PASO 4: Contar el número de genomas por especie y clase taxonómica\n\n# Filtra los genomas que están en 'glist_high$genome' y los combina con los recuentos de MGE\ndb_cnt_all &lt;- db_tax %&gt;% \n  filter(genomeID %in% glist_high$genome) %&gt;%   # Filtra para obtener solo los genomas que están en 'glist_high$genome'\n  left_join(., mdb_cnt, by = c(\"genomeID\", \"mge\"))  # Realiza una unión de izquierda con 'mdb_cnt' usando 'genomeID' y 'mge'\n\n# Reemplaza todos los valores NA en el data.frame por 0\ndb_cnt_all[is.na(db_cnt_all)] &lt;- 0\n\n# Contar el número de genomas por especie y clase taxonómica\ndb_cnt_all %&gt;% \n  # Selecciona las columnas relevantes: 'specI', 'genomeID', y 'class'\n  select(specI, genomeID, class) %&gt;%\n  # Elimina duplicados, dejando solo combinaciones únicas de especie, genoma y clase\n  unique() %&gt;%    \n  # Agrupa los datos por clase taxonómica ('class')\n  group_by(class) %&gt;%   \n  # Cuenta el número de genomas por cada clase\n  summarise(count = n()) %&gt;%       \n  # Filtra para solo mostrar las clases que tienen más de 9 genomas\n  filter(count &gt; 9) %&gt;%                  \n  head()\n\n# A tibble: 6 × 2\n  class               count\n  &lt;chr&gt;               &lt;int&gt;\n1 Acidithiobacillia      18\n2 Actinobacteria       9859\n3 Alphaproteobacteria  2001\n4 Bacilli             25644\n5 Bacteroidia           570\n6 Betaproteobacteria   3998\n\n# Crear un data.frame de presencia y ausencia\n## Agregar información de presencia y ausencia\ndb_pa_all &lt;- db_cnt_all %&gt;% mutate(presAbs = ifelse(count &gt; 0, 1, 0))\n\nhead(db_pa_all)\n\n# A tibble: 6 × 9\n  specI               genomeID             kingdom  phylum         class               genus         mge   count presAbs\n  &lt;chr&gt;               &lt;chr&gt;                &lt;chr&gt;    &lt;chr&gt;          &lt;chr&gt;               &lt;chr&gt;         &lt;fct&gt; &lt;dbl&gt;   &lt;dbl&gt;\n1 specI_v3_Cluster1   100053.SAMN02947772  Bacteria Spirochaetes   Spirochaetia        Leptospirales IS_Tn    22       1\n2 specI_v3_Cluster201 1000561.SAMN02471202 Bacteria Proteobacteria Gammaproteobacteria Pseudomonada… IS_Tn     5       1\n3 specI_v3_Cluster361 1000562.SAMN03114893 Bacteria Firmicutes     Bacilli             Lactobacilla… IS_Tn     5       1\n4 specI_v3_Cluster371 1000565.SAMN02471991 Bacteria Proteobacteria Betaproteobacteria  Nitrosomonad… IS_Tn    24       1\n5 specI_v3_Cluster564 1000568.SAMN00255229 Bacteria Firmicutes     Negativicutes       Veillonellal… IS_Tn     3       1\n6 specI_v3_Cluster565 1000569.SAMN00255226 Bacteria Firmicutes     Negativicutes       Veillonellal… IS_Tn     2       1"
  },
  {
    "objectID": "Figura3.html#paso-5-agrupar-todos-los-genomas-por-especie-speci",
    "href": "Figura3.html#paso-5-agrupar-todos-los-genomas-por-especie-speci",
    "title": "Figura 3",
    "section": "PASO 5: Agrupar todos los genomas por especie (specI)",
    "text": "PASO 5: Agrupar todos los genomas por especie (specI)\n\n## Resumir: avg_cnt = promedio de recuento por MGE por especie (specI), frac = fracción de genomas por especie con cada MGE\ndb_specI &lt;- db_pa_all %&gt;% \n  # Agrupar los datos por especie (specI) y MGE\n  group_by(specI, mge) %&gt;%\n  # Contar el número de genomas por combinación de 'specI' y 'mge'\n  summarise(genomeCnt = n(),   \n            # Calcular el promedio de recuento por MGE por especie\n            avg_cnt = mean(count),      \n            # Calcular la presencia (1) total para cada MGE por especie\n            pa = sum(presAbs),    \n            # Calcular el total de recuentos para cada MGE por especie\n            cnt_tot = sum(count)) %&gt;% \n   # Calcular la fracción de genomas por especie que tienen el MGE\n  mutate(frac = pa / genomeCnt) %&gt;%        \n  # Unir los datos con la información taxonómica de 'tax' utilizando 'specI'\n  left_join(., tax, by = \"specI\") %&gt;%  \n  # Eliminar la columna 'genomeID' que no es necesaria\n  select(-genomeID) %&gt;%         \n  # Eliminar filas duplicadas\n  unique(.)                                 \n\n\n## Resumir: avg_cnt = promedio de recuento por MGE por genoma, frac = fracción de genomas con cada MGE\ndb_genome &lt;- db_pa_all %&gt;% \n  # Agrupar los datos por genoma (genomeID) y MGE\n  group_by(genomeID, mge) %&gt;%       \n  # Contar el número de combinaciones de genoma y MGE\n  summarise(genomeCnt = n(),   \n            # Calcular el promedio de recuento de cada MGE por genoma\n            avg_cnt = mean(count),  \n            # Calcular la presencia total de MGE en cada genoma\n            pa = sum(presAbs),         \n            # Calcular el total de recuentos de MGE por genoma\n            cnt_tot = sum(count)) %&gt;%  \n  # Calcular la fracción de genomas con el MGE\n  mutate(frac = pa / genomeCnt) %&gt;%       \n  # Unir los datos con la información taxonómica utilizando 'genomeID'\n  left_join(., tax, by = \"genomeID\") %&gt;%     \n  # Eliminar filas duplicadas\n  unique(.)                                  \n\nCrear data frames separados para los recuentos de MGE y las fracciones de MGE.\n\n# Promedio de recuentos de cada MGE por especie (specI), donde los MGEs son las columnas y las especies (specI) las filas\nall_cnt_specI &lt;- db_specI %&gt;% \n  select(specI, mge, avg_cnt)   # Selecciona las columnas 'specI' (especie), 'mge' (MGE), y 'avg_cnt' (promedio de recuentos)\n\nall_frac_specI &lt;- db_specI %&gt;% \n  select(specI, mge, frac)      # Selecciona las columnas 'specI' (especie), 'mge' (MGE), y 'frac' (fracción de genomas con el MGE)\n\nall_cnt_genome &lt;- db_genome %&gt;% \n  select(genomeID, mge, avg_cnt) # Selecciona las columnas 'genomeID' (ID de genoma), 'mge' (MGE), y 'avg_cnt' (promedio de recuentos)"
  },
  {
    "objectID": "Figura3.html#paso-6-análisis-por-especie-speci-a-nivel-de-clase",
    "href": "Figura3.html#paso-6-análisis-por-especie-speci-a-nivel-de-clase",
    "title": "Figura 3",
    "section": "PASO 6: Análisis por especie (specI) a nivel de clase",
    "text": "PASO 6: Análisis por especie (specI) a nivel de clase\nSe utiliza la prueba de Mann-Whitney para analizar asociaciones de los MGEs a nivel de clase. El análisis se basa en la fracción de genomas por especiación (SpecI) que contiene el MGE para evitar sesgos de muestreo.\n\n# entrada de datos\nall_avg_cnt_tax_class &lt;-  db_specI %&gt;% \n  select(specI, mge, avg_cnt, class) %&gt;%   # Selecciona las columnas: 'specI', 'mge', 'avg_cnt' y 'class'\n  filter(., !grepl(\"Hotspot\", mge)) %&gt;%    # Filtra para excluir los MGEs que contienen \"Hotspot\" en su nombre\n  filter(., !grepl(\"Cellular\", mge))       # Filtra para excluir los MGEs que contienen \"Cellular\" en su nombre\n\nallMges &lt;- unique(all_avg_cnt_tax_class$mge)  # Extrae los valores únicos de MGEs\n\n# Filtrar para clases con al menos 10 genomas\nallClasses &lt;- all_avg_cnt_tax_class %&gt;% \n  filter(mge == all_avg_cnt_tax_class$mge[1]) %&gt;%  # Filtra para mantener solo el primer MGE\n  group_by(class) %&gt;%   # Agrupa los datos por clase\n  summarise(cntClass = n()) %&gt;%  # Cuenta cuántos genomas existen por clase\n  filter(cntClass &gt; 9)   # Filtra las clases con más de 9 genomas\n\n# Selección final de datos para el análisis\nall_avg_cnt_tax_class_sel_pre &lt;- all_avg_cnt_tax_class %&gt;% \n  filter(class %in% allClasses$class)   # Filtra las especies para incluir solo aquellas pertenecientes a clases con al menos 10 genomas"
  },
  {
    "objectID": "Figura3.html#paso-7-normalización-por-tamaño-de-genoma",
    "href": "Figura3.html#paso-7-normalización-por-tamaño-de-genoma",
    "title": "Figura 3",
    "section": "PASO 7: Normalización por tamaño de genoma",
    "text": "PASO 7: Normalización por tamaño de genoma\nSe calcula el tamaño promedio del genoma por cada especie (SpecI) y se normaliza el recuento de MGEs por el tamaño del genoma.\n\n# Promedio de tamaño de genoma por especie (SpecI)\ngs_int &lt;- gs %&gt;% \n  group_by(SpecI_id_v3) %&gt;% \n  summarise(avg_gs = mean(ProteinGeneCounts)) %&gt;% \n  dplyr::rename(specI = SpecI_id_v3)\n\n# Unir la información de tamaño de genoma con el promedio de recuentos de MGEs por especie y normalizar los recuentos por tamaño de genoma\nall_avg_cnt_tax_class_sel &lt;- left_join(all_avg_cnt_tax_class_sel_pre, gs_int, by = \"specI\") %&gt;% \n  mutate(norm_count = avg_cnt / avg_gs) %&gt;%  # Normalización: se divide el recuento promedio por el tamaño del genoma\n  dplyr::rename(count = avg_cnt, avg_cnt = norm_count)  # Renombrar las columnas para mayor claridad\n\nRealizar la prueba de Mann-Whitney para comparar recuentos de MGE entre clases.\n\nMW_all &lt;- NULL\nfor(i in 1:length(allMges)){  # Iterar sobre todos los MGEs\n  mgeX &lt;- allMges[i]  # Seleccionar el MGE actual\n  mgeDat &lt;- all_avg_cnt_tax_class_sel %&gt;% filter(mge == mgeX)  # Filtrar los datos para el MGE seleccionado\n  \n  MW &lt;- sapply(seq_along(allClasses$class), function(j){\n    class_sel &lt;- allClasses$class[j]  # Seleccionar la clase actual\n    ingroup &lt;- mgeDat %&gt;% filter(class == class_sel)  # Filtrar datos de la clase seleccionada (ingroup)\n    outgroup &lt;- mgeDat %&gt;% filter(class != class_sel)  # Filtrar datos de las clases no seleccionadas (outgroup)\n    \n    # Realizar la prueba de Mann-Whitney para comparar los recuentos promedio de MGE entre las clases\n    MWout &lt;- wilcox.test(ingroup$avg_cnt, outgroup$avg_cnt, alternative = \"greater\")\n    out &lt;- c(class_sel, MWout$p.value)  # Guardar el resultado de la prueba (clase y p-value)\n    return(out)\n  })\n  \n  MWOut &lt;- as.data.frame(t(MW[2,]))  # Convertir los resultados de la prueba en un data frame\n  colnames(MWOut) &lt;- MW[1,]  # Asignar los nombres de las clases como nombres de columna\n  rownames(MWOut) &lt;- mgeX  # Asignar el nombre del MGE como nombre de fila\n  MW_all &lt;- rbind(MW_all, MWOut)  # Unir los resultados de la prueba para todos los MGEs\n}\n\n# Transponer los resultados finales de la prueba\nMW_all_mod &lt;- as.data.frame(t(MW_all))\n\nhead(MW_all_mod)\n\n                                   IS_Tn                Phage           Phage_like                   CE\nActinobacteria         0.999999917916124                    1                    1                    1\nAlphaproteobacteria   0.0178414060867117   0.0001231858382891   0.0588004481841716 8.61021742019938e-11\nBacilli             1.98748444995478e-06 8.27765421556004e-16 7.42579596027798e-13    0.854734318526737\nBacteroidia          0.00833722978655579                    1    0.902740265915529 1.19966727801307e-41\nBetaproteobacteria     0.107452414634065 2.00283676907074e-05    0.746214226095515    0.999999817280502\nChlamydiia             0.997521561347641     0.99991406834231    0.988672166822885    0.999936175938603\n                                Integron                   MI\nActinobacteria                         1    0.999999678245156\nAlphaproteobacteria  0.00014653261414839    0.999997587920911\nBacilli                                1 2.06109350055861e-10\nBacteroidia         9.34842687990597e-06 9.19715441949629e-44\nBetaproteobacteria  0.000506083290088997    0.788218472081803\nChlamydiia             0.962626875393123    0.999998724073782\n\n\nAjuste de valores p para múltiples comparaciones.\n\nMW_all_adj &lt;- NULL  # Inicializar un objeto vacío para almacenar los resultados ajustados\n\n# Iterar sobre cada columna de los resultados de la prueba de Mann-Whitney\nfor(k in 1:ncol(MW_all_mod)){\n  MW_all_mod2 &lt;- as.matrix(MW_all_mod)  # Convertir el data frame en una matriz para facilitar el acceso a las columnas\n  pVec &lt;- c(MW_all_mod2[,k])  # Extraer la columna k, que contiene los valores p de la prueba de Mann-Whitney\n  adjP &lt;- p.adjust(pVec, \"BH\")  # Ajustar los valores p utilizando el método de Benjamini-Hochberg (\"BH\")\n  MW_all_adj &lt;- cbind(MW_all_adj, adjP)  # Unir los valores p ajustados a la matriz final\n}\n\n# Asignar los nombres de las columnas originales a los resultados ajustados\ncolnames(MW_all_adj) &lt;- colnames(MW_all_mod)\n\n# Convertir el resultado final en un data frame\nMW_all_fin &lt;- as.data.frame(MW_all_adj)\n\nCrear una tabla binaria con valores p &lt; 0.1 --&gt; 1, de lo contrario 0\n\nMW_all_stat &lt;- NULL  # Inicializar un objeto vacío para almacenar los resultados binarios\n\n# Iterar sobre cada columna de los resultados ajustados (MW_all_fin)\nfor(l in 1:ncol(MW_all_fin)){\n  # Crear una columna \"signP\" con valor 1 si el valor p es menor a 0.1, y 0 en caso contrario\n  MW_test &lt;- MW_all_fin %&gt;% mutate(signP=ifelse(MW_all_fin[,l]&gt;0.1,0,1))  \n  MW_all_stat &lt;- cbind(MW_all_stat, MW_test$signP)  # Unir los resultados binarios\n}\n\n# Convertir la matriz a un data frame\nMW_all_stat &lt;- as.data.frame(MW_all_stat)\n\n# Asignar los nombres de las columnas y filas a la tabla binaria\ncolnames(MW_all_stat) &lt;- colnames(MW_all_fin)\nrownames(MW_all_stat) &lt;- rownames(MW_all_fin)\n\n# Sumar los valores de \"signP\" por fila para obtener el número total de pruebas significativas por MGE\nMW_all_stat_sum &lt;- MW_all_stat %&gt;% mutate(sumSign=rowSums(.))\n\n# Agregar los nombres de las filas a la tabla para obtener un formato adecuado\nMW_all_stat2 &lt;- cbind(rownames(MW_all_stat), MW_all_stat)\ncolnames(MW_all_stat2)[1] &lt;- \"class\"  # Renombrar la primera columna como \"class\"\n\nMW_all_fin2 &lt;- cbind(rownames(MW_all_fin), MW_all_fin)\ncolnames(MW_all_fin2)[1] &lt;- \"class\""
  },
  {
    "objectID": "Figura3.html#paso-8-tabla-con-pvalues-y-especies",
    "href": "Figura3.html#paso-8-tabla-con-pvalues-y-especies",
    "title": "Figura 3",
    "section": "PASO 8: Tabla con pvalues y especies",
    "text": "PASO 8: Tabla con pvalues y especies\n\n#  1. Reorganizar el dataframe 'MW_all_fin2' de formato ancho a largo (long format).\n# Esto es útil para preparar los datos para ggplot o análisis por variable.\nmelted_specI_class &lt;- reshape2::melt(MW_all_fin2)\n\n# 2. Añadir una columna 'signP' que marque con \"*\" si el valor (p-valor) es significativo (menor o igual a 0.05).\n# Si el valor es mayor a 0.05, deja la celda vacía.\nmelted_specI_class1 &lt;- melted_specI_class %&gt;%\n  mutate(signP = ifelse(value &gt; 0.05, \"\", \"*\"))\n\n# 3. Calcular el promedio de 'count' por combinación de clase taxonómica ('class') y elemento genético móvil ('mge'),\n# y renombrar la columna 'mge' como 'variable' para que coincida con el dataframe anterior.\nall_avg_cnt_tax_class_sel1 &lt;- all_avg_cnt_tax_class_sel %&gt;%\n  group_by(class, mge) %&gt;%\n  summarise(avg_class = mean(count), .groups = \"drop\") %&gt;%\n  dplyr::rename(variable = mge)\n\n# 4. Unir los datos con los valores derretidos y la información de significancia.\n# La unión se hace por las columnas 'class' y 'variable'.\nplot_table_w_g9 &lt;- left_join(melted_specI_class1, all_avg_cnt_tax_class_sel1, by = c(\"class\", \"variable\"))\n\n# 5. (Redundante) Se repite la unión anterior. Puedes eliminar esta línea si no necesitas tener dos versiones del mismo objeto.\nplot_table &lt;- left_join(melted_specI_class1, all_avg_cnt_tax_class_sel1, by = c(\"class\", \"variable\"))"
  },
  {
    "objectID": "Figura3.html#paso-9-datos-para-mapa-de-colores-para-filogenia",
    "href": "Figura3.html#paso-9-datos-para-mapa-de-colores-para-filogenia",
    "title": "Figura 3",
    "section": "PASO 9: Datos para Mapa de colores para filogenia",
    "text": "PASO 9: Datos para Mapa de colores para filogenia\nCrear el mapa de calor filogenético con normalización de los valores\n\nnormalize &lt;- function(x) {  # Función para normalizar los valores entre 0 y 1\n  x/max(x)\n}\n\n# Crear la matriz de datos para el mapa de calor filogenético\nphylo_heatmap_mat &lt;- all_avg_cnt_tax_class_sel1 %&gt;% \n  # Filtrar clases que no contienen \"NA\"\n  filter(!grepl(\"NA \", class)) %&gt;%  \n  # Convertir los datos en formato ancho (cada variable como columna)\n  spread(variable, avg_class) %&gt;%  \n  # Seleccionar las variables de interés\n  dplyr::select(class, IS_Tn, Phage, Phage_like, CE, Integron, MI) %&gt;%  \n  # Establecer las clases como nombres de fila\n  column_to_rownames(var = \"class\")  \n\n\n# Crear el árbol filogenético manteniendo solo las especies que están en la matriz de datos del mapa de calor\nclass_tree_w_g9 &lt;- keep.tip(class_tree, tip = rownames(phylo_heatmap_mat))\n\n## Ajuste de colores para el mapa de calor filogenético para datos sesgados\nsmall_value &lt;- unique(sort(unlist(phylo_heatmap_mat)))[2]  # Encuentra el segundo valor más pequeño en la matriz de datos para establecer un umbral\nsmall_value &lt;- small_value - small_value %% 0.001  # Redondea el valor a 3 decimales para crear un valor pequeño ajustado\n\n# Definir los puntos de corte para el mapa de calor según la distribución de los datos\nheatmap_breaks &lt;- c(0, small_value, 1, 2, 3, 4, seq(5, 55, 10))\n\n# Definir una paleta de colores basada en viridis, con un sesgo hacia valores más bajos\nplot_colors &lt;- c(\"white\", colorRampPalette((viridis(10)), bias = 5)(length(heatmap_breaks) - 2))\n\n# Crear una matriz de significancia (signP) para etiquetar el mapa de calor\nsig_mat &lt;- plot_table_w_g9 %&gt;% \n  select(class, variable, signP)  # Selecciona las columnas relevantes de los datos\n\n# Filtra las filas que contienen \"NA\" en la columna \"class\" y transforma los datos a formato ancho\nsig_mat &lt;- sig_mat %&gt;% \n  filter(!grepl(\"NA \", class)) %&gt;%\n  spread(variable, signP) %&gt;%  # Transforma los datos para que las variables sean columnas\n  column_to_rownames(var = \"class\")  # Establece la columna \"class\" como nombres de fila\n\n# Alinea la matriz de significancia con el árbol filogenético\nsig_mat &lt;- sig_mat[class_tree_w_g9$tip.label, colnames(phylo_heatmap_mat)]"
  },
  {
    "objectID": "Figura3.html#paso-10-cargar-funciones",
    "href": "Figura3.html#paso-10-cargar-funciones",
    "title": "Figura 3",
    "section": "PASO 10: Cargar funciones",
    "text": "PASO 10: Cargar funciones\n\nsource(\"scripts/phylo_function.R\")"
  },
  {
    "objectID": "Figura3.html#figura-3b.-mapa-de-colores",
    "href": "Figura3.html#figura-3b.-mapa-de-colores",
    "title": "Figura 3",
    "section": "Figura 3B. Mapa de colores",
    "text": "Figura 3B. Mapa de colores\n\n# 1. Extraer coordenadas del heatmap filogenético para añadir anotaciones manuales posteriormente\nxx_yy &lt;- phylo.heatmap.coords(\n  class_tree_w_g9,           # árbol filogenético de clases\n  phylo_heatmap_mat,         # matriz de abundancias promedio por clase y MGE\n  fsize = c(0.8, 0.9, 0.7),  # tamaños de fuente (árbol, heatmap, leyenda)\n  colors = plot_colors,      # colores personalizados para el heatmap\n  grid = TRUE,               # mostrar rejilla en el heatmap\n  split = c(0.7, 0.3),       # proporción de espacio entre árbol y heatmap\n  lwd = 1,                   # grosor de líneas\n  breaks = heatmap_breaks,   # puntos de corte para los colores\n  mar = c(1.2,1.2,1.2,1.2)   # márgenes\n)\n\n## 2. Generar el heatmap con leyenda incluida, usando los mismos parámetros que el paso anterior\nphylo.heatmap.legendmod(\n  class_tree_w_g9,\n  phylo_heatmap_mat,\n  fsize = c(0.8, 0.9, 0.7),\n  colors = plot_colors,\n  grid = TRUE,\n  split = c(0.7, 0.3),\n  lwd = 1,\n  breaks = heatmap_breaks,\n  mar = c(1.2,1.2,1.2,1.2)\n)\n\n## 3. Añadir símbolos de significancia (\"*\") en cada celda de la matriz que lo indique (en 'sig_mat')\nfor(i in 1:nrow(sig_mat)) {\n  for(j in 1:ncol(sig_mat)) {\n    if(sig_mat[i,j] == \"*\") {\n      rnm &lt;- rownames(sig_mat)[i]  # nombre de la fila (clase taxonómica)\n      cnm &lt;- colnames(sig_mat)[j]  # nombre de la columna (MGE)\n      \n      # Añadir el símbolo \"*\" en la posición correspondiente del heatmap\n      points(\n        xx_yy$xx[j], xx_yy$yy[i],   # coordenadas x, y para esa celda\n        cex = 1.5,                  # tamaño del símbolo\n        col = if (phylo_heatmap_mat[rnm, cnm] &lt; heatmap_breaks[3]) \"white\" else \"black\", \n        pch = \"*\"                   # símbolo a dibujar\n      )\n    }\n  }\n}"
  },
  {
    "objectID": "Figura3.html#figura-3a-filogenia",
    "href": "Figura3.html#figura-3a-filogenia",
    "title": "Figura 3",
    "section": "Figura 3A: Filogenia",
    "text": "Figura 3A: Filogenia\nObtener el numero de genomas por Class:\n\ngenomes_per_class &lt;- db_genome %&gt;%\n  distinct(genomeID, class) %&gt;%  # eliminar duplicados por genomeID y class\n  group_by(class) %&gt;%\n  summarise(n_genomes = n()) %&gt;%\n  arrange(desc(n_genomes))\n\ngenomes_per_class\n\n# A tibble: 60 × 2\n   class                 n_genomes\n   &lt;chr&gt;                     &lt;int&gt;\n 1 Gammaproteobacteria       27249\n 2 Bacilli                   25644\n 3 Actinobacteria             9859\n 4 Betaproteobacteria         3998\n 5 Epsilonproteobacteria      2693\n 6 Alphaproteobacteria        2001\n 7 Clostridia                 1621\n 8 Bacteroidia                 570\n 9 Spirochaetia                501\n10 Flavobacteriia              375\n# ℹ 50 more rows\n\n\nModificar los nombres en el árbol:\n\n# -------------- Modificaciones de las etiquetas de las especies (numero de geneomas) -------------\n\nspecies_labels &lt;- class_tree_w_g9$tip.label\n# Crear nombres con el número de genomas\nnew_labels &lt;- paste0(genomes_per_class$class, \" (\", genomes_per_class$n_genomes, \")\")\n\n# Cambiar nombres en el árbol\nmatch_idx &lt;- match(class_tree_w_g9$tip.label, genomes_per_class$class)\n\n# Asegúrate que no hay NA antes de continuar\nclass_tree_w_g9$tip.label &lt;- ifelse(\n  !is.na(match_idx),\n  new_labels[match_idx],\n  class_tree_w_g9$tip.label\n)\n\n# -------------- Obtener el nodo más reciente común (MRCA) para cada grupo -------------------------\n\n# &gt; Obtener el numero del nodo Archaea\nnode_archaea &lt;- getMRCA(class_tree_w_g9, c(\"Halobacteria (95)\", \"Methanomicrobia (89)\"))\n\n# &gt; Obtener el numero del nodo Bacterias\n# Obtener todos los nodos\nall_classes &lt;- class_tree_w_g9$tip.label\n\n# 2. Excluir los que no quieres\nexcluded &lt;- c(\"Halobacteria (95)\", \"Methanomicrobia (89)\")\nincluded_classes &lt;- setdiff(all_classes, excluded)\n\n# 3. Obtener el nodo común para los restantes\nnode_bacteria &lt;- getMRCA(class_tree_w_g9, included_classes)\n\nExtraer coordenadas del heatmap filogenético para añadir anotaciones manuales posteriormente:\n\n# Guardar la figura como archivo temporal\ntmp_file &lt;- tempfile(fileext = \".png\")\n\n# Crear la imagen del árbol + heatmap\npng(tmp_file, width = 1000, height = 1500, res = 150)  \n\n# Filogenia\nxx_yy &lt;- phylo.heatmap.coords(\n  class_tree_w_g9,\n  phylo_heatmap_mat,\n  fsize = c(0.8, 0.9, 0.7),\n  colors = plot_colors,\n  grid = TRUE,\n  split = c(0.7, 0.3),\n  lwd = 1,\n  breaks = heatmap_breaks,\n  mar = c(1.2,1.2,1.2,1.2)\n)\n# Agregar titulos de los nodos\nnodelabels(\"Bacteria\", node = node_bacteria, frame = \"none\", adj = c(1.1, -0.1), font = 2, cex = 1)\nnodelabels(\"Archaea\", node = node_archaea, frame = \"none\", adj = c(1.1, -0.1), font = 2, cex = 1)\n\ndev.off()\n\npng \n  2 \n\n# Leer imagen y convertirla en un objeto ggdraw\np_phylo_heatmap &lt;- ggdraw() + draw_image(tmp_file)\np_phylo_heatmap"
  }
]