[
  {
    "objectID": "datos.html",
    "href": "datos.html",
    "title": "Sobre los datos",
    "section": "",
    "text": "Creado por: Johana CastelÃ¡n"
  },
  {
    "objectID": "datos.html#clonar-el-repositorio-desde-r",
    "href": "datos.html#clonar-el-repositorio-desde-r",
    "title": "Sobre los datos",
    "section": "Clonar el repositorio desde R",
    "text": "Clonar el repositorio desde R\nPuedes descargar el repositorio completo empleando git clone y el link SSH, solo si ya cuentas con la llave de SSH enlazado a tu github.\ngit clone git@github.com:ISCB-RSG-MEXICO/Reprohack2025_RLadiesMorelia_RSGMexico.git"
  },
  {
    "objectID": "datos.html#descargar-los-datos",
    "href": "datos.html#descargar-los-datos",
    "title": "Sobre los datos",
    "section": "Descargar los datos",
    "text": "Descargar los datos\nDe igual manera, podemos descargar los archivos necesarios a nuestra computadora y colocarlos en la carpeta â€œdataâ€\n\n# Define la carpeta donde quieres guardar\ncarpeta_destino &lt;- \"data\"\n\n# &gt; raw_data\n# Define el nombre que quieres para el archivo\nnombre_archivo &lt;- \"processed_data.tar.gz\"\n# Construye la ruta completa\nruta_completa &lt;- file.path(carpeta_destino, nombre_archivo)\n\n# URL de descarga directa\nurl &lt;- \"https://git.embl.de/khedkar/promge/-/raw/main/raw_data.tar.gz\"\n\n# Aumentar timeout\noptions(timeout = 600)  # 10 minutos\n\n# Descarga\ndownload.file(url, destfile = ruta_completa, mode = \"wb\")\n\n\n# &gt; Proccessed_data\n# Define el nombre que quieres para el archivo\nnombre_archivo &lt;- \"processed_data.tar.gz\"\n\n# Construye la ruta completa\nruta_completa &lt;- file.path(carpeta_destino, nombre_archivo)\n\n# URL de descarga directa\nurl &lt;- \"https://git.embl.de/khedkar/promge/-/raw/main/processed_data.tar.gz\"\n\n# Descarga\ndownload.file(url, destfile = ruta_completa, mode = \"wb\")\n\n\n\n\n\n\n\nNote\n\n\n\nLos archivos pesan 94.2 Mb y 2280.8 Mb de manera comprimida, processed_data.tar.gz y raw_data.tar.gz, respectivamente."
  },
  {
    "objectID": "datos.html#descomprimir-los-archivos-desde-r",
    "href": "datos.html#descomprimir-los-archivos-desde-r",
    "title": "Sobre los datos",
    "section": "Descomprimir los archivos desde R",
    "text": "Descomprimir los archivos desde R\n\nlibrary(R.utils)\n\nuntar('data/processed_data.tar.gz')\nuntar('data/raw_data.tar.gz')"
  },
  {
    "objectID": "datos.html#importar-datos-en-r",
    "href": "datos.html#importar-datos-en-r",
    "title": "Sobre los datos",
    "section": "Importar datos en R",
    "text": "Importar datos en R\n\nFigura 2\nDatos de la Figura 2A:\n\nmge_solitary &lt;- read_tsv(\"processed_data/solitary_mge_bins_final.txt\", col_names = F)\n\nRows: 1647630 Columns: 15                                  s\nâ”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nDelimiter: \"\\t\"\nchr  (2): X10, X15\ndbl (13): X1, X2, X3, X4, X5, X6, X7, X8, X9, X11, X12,...\nDatos de la Figura 2B:\n\nmge_pg &lt;- read_tsv(\"processed_data/mge_bins_per_genome_final.txt\", col_names = T)\n\nRows: 76902 Columns: 14                                                                \nâ”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nDelimiter: \"\\t\"\nchr (6): Genome, specI, kingdom, phylum, class, genus\ndbl (8): IS_Tn, Phage, Phage_like, CE, Integron, MI, Hotspot, Cellular\n\n\nFigura 3\n\ntax &lt;- read_tsv(\"raw_data/species_with_atleast_2genomes.list\", col_names=F)\n\nRows: 77107 Columns: 6                                                                \nâ”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nDelimiter: \"\\t\"\nchr (6): X1, X2, X3, X4, X5, X6\n\ndb &lt;-read_tsv(\"processed_data/mge_bins_per_genome_final.txt\", col_names = T)\n\nRows: 76902 Columns: 14                                                               \nâ”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nDelimiter: \"\\t\"\nchr (6): Genome, specI, kingdom, phylum, class, genus\ndbl (8): IS_Tn, Phage, Phage_like, CE, Integron, MI, Hotspot, Cellular\n\ngs &lt;-read_tsv(\"raw_data/genome_size.txt\", col_names = T)\n\nRows: 84022 Columns: 3                                                                \nâ”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nDelimiter: \"\\t\"\nchr (2): strain, SpecI_id_v3\ndbl (1): ProteinGeneCounts\n\nclass_tree &lt;- read.tree(\"raw_data/progenomes2_class_tree.nwk\")\n\nEs un archivo Newick (.nwk).\n\nglist &lt;- read_tsv(\"raw_data/genome_status_supplementary_tableS2.txt\", col_names = T)\n\nRows: 84022 Columns: 7                                                                \nâ”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nDelimiter: \"\\t\"\nchr (5): genome, assembly_status, Marker_lineage, genome_quality, species_with_atl...\ndbl (2): Completeness, Contamination\n\n\nFigura 4\n\ndata_mf &lt;- read_tsv(\"raw_data/recombinase_hgt_cluster_master_file.txt\", col_names = F)\n\nRows: 1807030 Columns: 9                                              0s\nâ”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nDelimiter: \"\\t\"\nchr (9): X1, X2, X3, X4, X5, X6, X7, X8, X9\n\nmge_bins &lt;- read_tsv(\"raw_data/mge_bins_final.txt\",col_names = T)\n\nRows: 1953569 Columns: 15                                             \nâ”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nDelimiter: \"\\t\"\nchr  (2): island, mgeR\ndbl (13): IS_Tn, Phage, Phage_like, CE, Integron, MI, Hotspot, UC,...\n\ntax &lt;- read_tsv(\"raw_data/hgt_species.list\", col_names = F)\n\nRows: 61959 Columns: 6                                                \nâ”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nDelimiter: \"\\t\"\nchr (6): X1, X2, X3, X4, X5, X6\n\nclass_tree &lt;- read.tree(\"raw_data/progenomes2_class_tree.nwk\")\n\nRows: 61959 Columns: 6                                                \nâ”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nDelimiter: \"\\t\"\nchr (6): X1, X2, X3, X4, X5, X6\n\nglist &lt;- read_tsv(\"raw_data/genome_status_supplementary_tableS2.txt\", col_names = T)\n\nRows: 84022 Columns: 7                                                0s\nâ”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nDelimiter: \"\\t\"\nchr (5): genome, assembly_status, Marker_lineage, genome_quality, ...\ndbl (2): Completeness, Contamination"
  },
  {
    "objectID": "datos.html#referencias",
    "href": "datos.html#referencias",
    "title": "Sobre los datos",
    "section": "Referencias",
    "text": "Referencias\n\nClone an existing GitHub project to new RStudio project - explicacion\nConectar a GitHub con SSH - explicacion"
  },
  {
    "objectID": "Figura2.html",
    "href": "Figura2.html",
    "title": "Figura 2",
    "section": "",
    "text": "Figura 2. Censo integral de elementos genÃ©ticos mÃ³viles (MGEs) en procariotas\n\n\n\nContribuciÃ³n de cada una de las cinco principales familias de recombinasas a las seis categorÃ­as de MGEs, asÃ­ como a las recombinasas celulares.\nNÃºmero de MGEs por categorÃ­a (grÃ¡fico de barras) y porcentaje de cada categorÃ­a (grÃ¡fico de dona) en 76,000 genomas de 3,000 especies, utilizando el flujo de trabajo descrito en la Figura 1.\nLongitudes predichas de MGEs no anidados en pares de bases. Los bigotes representan el rango entre los percentiles 10 y 90.\n\n\n\n\nUso de Archivos Comprimidos: Cuando trabajen con archivos comprimidos (por ejemplo, con extensiÃ³n .gz), no es necesario descomprimirlos manualmente antes de cargarlos en R.\nCÃ³digo Correcto para Cargar Archivos Comprimidos: Para cargar archivos comprimidos sin descomprimirlos previamente, utilicen el siguiente cÃ³digo:\n\n\nmge_pg &lt;- read_tsv(\"data/processed_data/mge_bins_per_genome_final.txt.gz\", col_names = T)\nmge_solitary &lt;- read_tsv(\"data/processed_data/solitary_mge_bins_final.txt.gz\", col_names = F)\nrec_class &lt;- read_tsv(\"data/raw_data/recombinase.list.gz\", col_names = F)\nglist &lt;- read_tsv(\"data/raw_data/genome_status_supplementary_tableS2.txt.gz\", col_names = T)\n\n\n\n\n\n\n\nDiferencia con el CÃ³digo Original\n\n\n\nEn el cÃ³digo original, el archivo estaba descomprimido. Sin embargo, con la extensiÃ³n .gz, se puede leer directamente el archivo comprimido sin la necesidad de usar herramientas adicionales para descomprimirlo.\n\n\n\n\n\n\n# Obtener los genomas con la mas alta calidad\nglist_high &lt;- glist %&gt;% \n  filter(genome_quality == \"high\")\n\n# Renombrar columnas en rec_class\nrec_class &lt;- rec_class %&gt;% \n  # Cambiar X1 por class y X2 por mgeR\n  dplyr::rename(class = X1, mgeR = X2)\n\n# Renombrar columnas en mge_solitary\nmge_solitary &lt;- mge_solitary %&gt;% \n  dplyr::rename(IS_Tn = X1, Phage = X2, Phage_like = X3, CE = X4, Integron = X5, MI = X6,   Hotspot = X7, UC = X8,  Cellular = X9, island = X10, island_size = X11, prot_count = X12,   phage_count = X13, CONJ_T4SS = X14, mgeR = X15)\n\n# TransformaciÃ³n y Filtrado de Datos de MGE Solitario\nmge_solitary_melted &lt;- mge_solitary %&gt;% \n  select(1:11,15) %&gt;% # Seleccionar columnas de la 1 a la 11, y la 15\n  # Convierte las columnas 1 a 9 de formato ancho a largo utilizando gather().\n    # - mge: Nombre de la nueva columna que contendrÃ¡ los nombres originales de las variables.\n    # - mge_pa: Nueva columna que almacenarÃ¡ los valores de las celdas de las columnas originales.\n  gather(mge, mge_pa, 1:9) %&gt;% \n  filter(mge_pa ==1) %&gt;% # filtrar por valores igual a 1 en la columna mge_pa\n  filter(.,!grepl(\"UC\", mge)) %&gt;% # Elimina las filas donde la columna mge contenga la cadena \"UC\", usando grepl() con ! (negaciÃ³n lÃ³gica).\n  filter(.,!grepl(\"Hotspot\", mge)) %&gt;% # Elimina las filas donde mge contenga la palabra \"Hotspot\".\n  mutate(mgeRn = str_replace_all(mgeR,\"_\",\"\")) %&gt;% # Crea una nueva columna mgeRn, eliminando todos los guiones bajos (_) en la columna mgeR\n  filter(!str_detect(mgeRn, '[:alnum:] &{1,}')) %&gt;% # Filtra las filas donde mgeRn NO contenga un patrÃ³n de caracteres alfanumÃ©ricos seguidos de &.\n  select(-mgeRn) %&gt;% # Elimina la columna mgeRn\n  mutate(mgeR = str_replace_all(mgeR,\"&\",\"\")) # Modifica mgeR, eliminando todos los caracteres &.\n\n# Visualizar datos\nhead(mge_solitary_melted)\n\n# A tibble: 6 Ã— 5\n  island                                       island_size mgeR           mge   mge_pa\n  &lt;chr&gt;                                              &lt;dbl&gt; &lt;chr&gt;          &lt;chr&gt;  &lt;dbl&gt;\n1 562.SAMN04376786.LVNY01000045:952-4426              3474 rve            IS_Tn      1\n2 1313.SAMEA1032643.CNPJ02000077:179268-184242        4974 huh_y1         IS_Tn      1\n3 90371.SAMN06345841.MVIX01000065:110-337              227 huh_y1         IS_Tn      1\n4 766148.SAMN00792444.AFGX01000029:22-9946            9924 rve            IS_Tn      1\n5 95486.SAMN05002005.MUWP01000187:1439-20561         19122 DDE_3          IS_Tn      1\n6 562.SAMN03075146.JRLD01000012:423-1556              1133 Transposase_20 IS_Tn      1\n\n\n\nmge_solitary_melted_dw &lt;- mge_solitary_melted %&gt;% \n  select(-mgeR,-mge_pa) %&gt;%  # Elimina las columnas mgeR y mge_pa\n  mutate(island1 = island) %&gt;% # Crea una nueva columna island1, duplicando el valor de la columna island.\n  separate(island1, c(\"g1\",\"g2\",\"g3\")) %&gt;% # Divide la columna island1 en tres nuevas columnas (g1, g2, g3), usando separate(). NOTA: Se asume que island1 contiene valores separados por un delimitador (por defecto, \"_\" o \".\").\n  mutate(genome = paste(g1, g2, sep = \".\")) %&gt;%  # Identificador del genoma. Crea una nueva columna genome, concatenando g1 y g2 con un punto (\".\") entre ellos.\n  select(-g1,-g2,-g3) %&gt;% # Elimina las columnas g1, g2 y g3\n  filter(genome %in% glist_high$genome) %&gt;% # Solo quedarse con genomas de alta calidad\n  select(-genome) # Eliminar columna genoma\n\nhead(mge_solitary_melted_dw)\n\n# A tibble: 6 Ã— 3\n  island                                       island_size mge  \n  &lt;chr&gt;                                              &lt;dbl&gt; &lt;chr&gt;\n1 562.SAMN04376786.LVNY01000045:952-4426              3474 IS_Tn\n2 1313.SAMEA1032643.CNPJ02000077:179268-184242        4974 IS_Tn\n3 90371.SAMN06345841.MVIX01000065:110-337              227 IS_Tn\n4 766148.SAMN00792444.AFGX01000029:22-9946            9924 IS_Tn\n5 95486.SAMN05002005.MUWP01000187:1439-20561         19122 IS_Tn\n6 562.SAMN03075146.JRLD01000012:423-1556              1133 IS_Tn\n\n\nAlmacenar variable\n\nwrite.table(mge_solitary_melted_dw,file=\"processed_data/mge_bins_final_solitary_collapsed.txt\", sep = \"\\t\", row.names = F, col.names = T, quote = F)\n\n\n\n\nDistribuciÃ³n de diferentes clases de MGE y cuÃ¡ntas veces aparecen en el conjunto de datos.\n\n# Unir la informacion a traves de la columna mgeR\nmge_solitary_rclass_all &lt;- left_join(mge_solitary_melted, rec_class, by = \"mgeR\") %&gt;% \n  select(-island_size, -mge_pa, -mgeR) %&gt;% # Elimina las columnas island_size, mge_pa y mgeR\n  separate(island, c(\"g1\",\"g2\",\"g3\")) %&gt;% # Divide la columna island en tres nuevas columnas (g1, g2, g3).\n  mutate(genome = paste(g1, g2, sep = \".\")) %&gt;% # Crea una nueva columna genome, concatenando g1 y g2 con un punto (\".\") entre ellos.\n  select(-g1,-g2,-g3) %&gt;% # Elimina las columnas auxiliares (g1, g2, g3), ya que su informaciÃ³n ahora estÃ¡ en genome.\n  group_by(class,mge) %&gt;% # Agrupa los datos por class y mge \n  summarise(count = n()) # Cuenta cuÃ¡ntas veces aparece cada combinaciÃ³n de class y mge\n\nhead(mge_solitary_rclass_all)\n\n# A tibble: 6 Ã— 3\n# Groups:   class [3]\n  class mge         count\n  &lt;chr&gt; &lt;chr&gt;       &lt;int&gt;\n1 cas   IS_Tn       12184\n2 dde   CE            181\n3 dde   IS_Tn      913577\n4 dde   Phage       10154\n5 dde   Phage_like    131\n6 huh   CE          18627\n\n\nDistribuciÃ³n de diferentes clases de MGE en genomas de alta calidad.\n\n# Unir la informacion a traves de la columna mgeR\nmge_solitary_rclass &lt;- left_join(mge_solitary_melted,rec_class, by = \"mgeR\") %&gt;% \n  select(-island_size, -mge_pa, -mgeR) %&gt;% # Elimina las columnas island_size, mge_pa y mgeR\n  separate(island, c(\"g1\",\"g2\",\"g3\")) %&gt;% # Divide la columna island en tres nuevas columnas (g1, g2, g3).\n  mutate(genome = paste(g1, g2, sep = \".\")) %&gt;% # Crea una nueva columna genome, concatenando g1 y g2 con un punto (\".\") entre ellos.\n  select(-g1,-g2,-g3) %&gt;% # Elimina las columnas auxiliares (g1, g2, g3), ya que su informaciÃ³n ahora estÃ¡ en genome.\n  filter(genome %in% glist_high$genome) %&gt;% # Solo quedarse con genomas de alta calidad\n  group_by(class,mge) %&gt;% # Agrupa los datos por class y mge \n  summarise(count = n()) # Cuenta cuÃ¡ntas veces aparece cada combinaciÃ³n de class y mge\n\nhead(mge_solitary_rclass)\n\n# A tibble: 6 Ã— 3\n# Groups:   class [3]\n  class mge         count\n  &lt;chr&gt; &lt;chr&gt;       &lt;int&gt;\n1 cas   IS_Tn       12024\n2 dde   CE            180\n3 dde   IS_Tn      904177\n4 dde   Phage       10078\n5 dde   Phage_like    129\n6 huh   CE          18385"
  },
  {
    "objectID": "Figura2.html#censo-de-elementos-genÃ©ticos-mÃ³viles-en-procariotas",
    "href": "Figura2.html#censo-de-elementos-genÃ©ticos-mÃ³viles-en-procariotas",
    "title": "Figura 2",
    "section": "",
    "text": "Figura 2. Censo integral de elementos genÃ©ticos mÃ³viles (MGEs) en procariotas\n\n\n\nContribuciÃ³n de cada una de las cinco principales familias de recombinasas a las seis categorÃ­as de MGEs, asÃ­ como a las recombinasas celulares.\nNÃºmero de MGEs por categorÃ­a (grÃ¡fico de barras) y porcentaje de cada categorÃ­a (grÃ¡fico de dona) en 76,000 genomas de 3,000 especies, utilizando el flujo de trabajo descrito en la Figura 1.\nLongitudes predichas de MGEs no anidados en pares de bases. Los bigotes representan el rango entre los percentiles 10 y 90.\n\n\n\n\nUso de Archivos Comprimidos: Cuando trabajen con archivos comprimidos (por ejemplo, con extensiÃ³n .gz), no es necesario descomprimirlos manualmente antes de cargarlos en R.\nCÃ³digo Correcto para Cargar Archivos Comprimidos: Para cargar archivos comprimidos sin descomprimirlos previamente, utilicen el siguiente cÃ³digo:\n\n\nmge_pg &lt;- read_tsv(\"data/processed_data/mge_bins_per_genome_final.txt.gz\", col_names = T)\nmge_solitary &lt;- read_tsv(\"data/processed_data/solitary_mge_bins_final.txt.gz\", col_names = F)\nrec_class &lt;- read_tsv(\"data/raw_data/recombinase.list.gz\", col_names = F)\nglist &lt;- read_tsv(\"data/raw_data/genome_status_supplementary_tableS2.txt.gz\", col_names = T)\n\n\n\n\n\n\n\nDiferencia con el CÃ³digo Original\n\n\n\nEn el cÃ³digo original, el archivo estaba descomprimido. Sin embargo, con la extensiÃ³n .gz, se puede leer directamente el archivo comprimido sin la necesidad de usar herramientas adicionales para descomprimirlo.\n\n\n\n\n\n\n# Obtener los genomas con la mas alta calidad\nglist_high &lt;- glist %&gt;% \n  filter(genome_quality == \"high\")\n\n# Renombrar columnas en rec_class\nrec_class &lt;- rec_class %&gt;% \n  # Cambiar X1 por class y X2 por mgeR\n  dplyr::rename(class = X1, mgeR = X2)\n\n# Renombrar columnas en mge_solitary\nmge_solitary &lt;- mge_solitary %&gt;% \n  dplyr::rename(IS_Tn = X1, Phage = X2, Phage_like = X3, CE = X4, Integron = X5, MI = X6,   Hotspot = X7, UC = X8,  Cellular = X9, island = X10, island_size = X11, prot_count = X12,   phage_count = X13, CONJ_T4SS = X14, mgeR = X15)\n\n# TransformaciÃ³n y Filtrado de Datos de MGE Solitario\nmge_solitary_melted &lt;- mge_solitary %&gt;% \n  select(1:11,15) %&gt;% # Seleccionar columnas de la 1 a la 11, y la 15\n  # Convierte las columnas 1 a 9 de formato ancho a largo utilizando gather().\n    # - mge: Nombre de la nueva columna que contendrÃ¡ los nombres originales de las variables.\n    # - mge_pa: Nueva columna que almacenarÃ¡ los valores de las celdas de las columnas originales.\n  gather(mge, mge_pa, 1:9) %&gt;% \n  filter(mge_pa ==1) %&gt;% # filtrar por valores igual a 1 en la columna mge_pa\n  filter(.,!grepl(\"UC\", mge)) %&gt;% # Elimina las filas donde la columna mge contenga la cadena \"UC\", usando grepl() con ! (negaciÃ³n lÃ³gica).\n  filter(.,!grepl(\"Hotspot\", mge)) %&gt;% # Elimina las filas donde mge contenga la palabra \"Hotspot\".\n  mutate(mgeRn = str_replace_all(mgeR,\"_\",\"\")) %&gt;% # Crea una nueva columna mgeRn, eliminando todos los guiones bajos (_) en la columna mgeR\n  filter(!str_detect(mgeRn, '[:alnum:] &{1,}')) %&gt;% # Filtra las filas donde mgeRn NO contenga un patrÃ³n de caracteres alfanumÃ©ricos seguidos de &.\n  select(-mgeRn) %&gt;% # Elimina la columna mgeRn\n  mutate(mgeR = str_replace_all(mgeR,\"&\",\"\")) # Modifica mgeR, eliminando todos los caracteres &.\n\n# Visualizar datos\nhead(mge_solitary_melted)\n\n# A tibble: 6 Ã— 5\n  island                                       island_size mgeR           mge   mge_pa\n  &lt;chr&gt;                                              &lt;dbl&gt; &lt;chr&gt;          &lt;chr&gt;  &lt;dbl&gt;\n1 562.SAMN04376786.LVNY01000045:952-4426              3474 rve            IS_Tn      1\n2 1313.SAMEA1032643.CNPJ02000077:179268-184242        4974 huh_y1         IS_Tn      1\n3 90371.SAMN06345841.MVIX01000065:110-337              227 huh_y1         IS_Tn      1\n4 766148.SAMN00792444.AFGX01000029:22-9946            9924 rve            IS_Tn      1\n5 95486.SAMN05002005.MUWP01000187:1439-20561         19122 DDE_3          IS_Tn      1\n6 562.SAMN03075146.JRLD01000012:423-1556              1133 Transposase_20 IS_Tn      1\n\n\n\nmge_solitary_melted_dw &lt;- mge_solitary_melted %&gt;% \n  select(-mgeR,-mge_pa) %&gt;%  # Elimina las columnas mgeR y mge_pa\n  mutate(island1 = island) %&gt;% # Crea una nueva columna island1, duplicando el valor de la columna island.\n  separate(island1, c(\"g1\",\"g2\",\"g3\")) %&gt;% # Divide la columna island1 en tres nuevas columnas (g1, g2, g3), usando separate(). NOTA: Se asume que island1 contiene valores separados por un delimitador (por defecto, \"_\" o \".\").\n  mutate(genome = paste(g1, g2, sep = \".\")) %&gt;%  # Identificador del genoma. Crea una nueva columna genome, concatenando g1 y g2 con un punto (\".\") entre ellos.\n  select(-g1,-g2,-g3) %&gt;% # Elimina las columnas g1, g2 y g3\n  filter(genome %in% glist_high$genome) %&gt;% # Solo quedarse con genomas de alta calidad\n  select(-genome) # Eliminar columna genoma\n\nhead(mge_solitary_melted_dw)\n\n# A tibble: 6 Ã— 3\n  island                                       island_size mge  \n  &lt;chr&gt;                                              &lt;dbl&gt; &lt;chr&gt;\n1 562.SAMN04376786.LVNY01000045:952-4426              3474 IS_Tn\n2 1313.SAMEA1032643.CNPJ02000077:179268-184242        4974 IS_Tn\n3 90371.SAMN06345841.MVIX01000065:110-337              227 IS_Tn\n4 766148.SAMN00792444.AFGX01000029:22-9946            9924 IS_Tn\n5 95486.SAMN05002005.MUWP01000187:1439-20561         19122 IS_Tn\n6 562.SAMN03075146.JRLD01000012:423-1556              1133 IS_Tn\n\n\nAlmacenar variable\n\nwrite.table(mge_solitary_melted_dw,file=\"processed_data/mge_bins_final_solitary_collapsed.txt\", sep = \"\\t\", row.names = F, col.names = T, quote = F)\n\n\n\n\nDistribuciÃ³n de diferentes clases de MGE y cuÃ¡ntas veces aparecen en el conjunto de datos.\n\n# Unir la informacion a traves de la columna mgeR\nmge_solitary_rclass_all &lt;- left_join(mge_solitary_melted, rec_class, by = \"mgeR\") %&gt;% \n  select(-island_size, -mge_pa, -mgeR) %&gt;% # Elimina las columnas island_size, mge_pa y mgeR\n  separate(island, c(\"g1\",\"g2\",\"g3\")) %&gt;% # Divide la columna island en tres nuevas columnas (g1, g2, g3).\n  mutate(genome = paste(g1, g2, sep = \".\")) %&gt;% # Crea una nueva columna genome, concatenando g1 y g2 con un punto (\".\") entre ellos.\n  select(-g1,-g2,-g3) %&gt;% # Elimina las columnas auxiliares (g1, g2, g3), ya que su informaciÃ³n ahora estÃ¡ en genome.\n  group_by(class,mge) %&gt;% # Agrupa los datos por class y mge \n  summarise(count = n()) # Cuenta cuÃ¡ntas veces aparece cada combinaciÃ³n de class y mge\n\nhead(mge_solitary_rclass_all)\n\n# A tibble: 6 Ã— 3\n# Groups:   class [3]\n  class mge         count\n  &lt;chr&gt; &lt;chr&gt;       &lt;int&gt;\n1 cas   IS_Tn       12184\n2 dde   CE            181\n3 dde   IS_Tn      913577\n4 dde   Phage       10154\n5 dde   Phage_like    131\n6 huh   CE          18627\n\n\nDistribuciÃ³n de diferentes clases de MGE en genomas de alta calidad.\n\n# Unir la informacion a traves de la columna mgeR\nmge_solitary_rclass &lt;- left_join(mge_solitary_melted,rec_class, by = \"mgeR\") %&gt;% \n  select(-island_size, -mge_pa, -mgeR) %&gt;% # Elimina las columnas island_size, mge_pa y mgeR\n  separate(island, c(\"g1\",\"g2\",\"g3\")) %&gt;% # Divide la columna island en tres nuevas columnas (g1, g2, g3).\n  mutate(genome = paste(g1, g2, sep = \".\")) %&gt;% # Crea una nueva columna genome, concatenando g1 y g2 con un punto (\".\") entre ellos.\n  select(-g1,-g2,-g3) %&gt;% # Elimina las columnas auxiliares (g1, g2, g3), ya que su informaciÃ³n ahora estÃ¡ en genome.\n  filter(genome %in% glist_high$genome) %&gt;% # Solo quedarse con genomas de alta calidad\n  group_by(class,mge) %&gt;% # Agrupa los datos por class y mge \n  summarise(count = n()) # Cuenta cuÃ¡ntas veces aparece cada combinaciÃ³n de class y mge\n\nhead(mge_solitary_rclass)\n\n# A tibble: 6 Ã— 3\n# Groups:   class [3]\n  class mge         count\n  &lt;chr&gt; &lt;chr&gt;       &lt;int&gt;\n1 cas   IS_Tn       12024\n2 dde   CE            180\n3 dde   IS_Tn      904177\n4 dde   Phage       10078\n5 dde   Phage_like    129\n6 huh   CE          18385"
  },
  {
    "objectID": "Figura2.html#figura-2a-contribuciÃ³n-de-las-principales-familias-de-recombinasas",
    "href": "Figura2.html#figura-2a-contribuciÃ³n-de-las-principales-familias-de-recombinasas",
    "title": "Figura 2",
    "section": "Figura 2A: ContribuciÃ³n de las principales familias de recombinasas",
    "text": "Figura 2A: ContribuciÃ³n de las principales familias de recombinasas\n\nPASO 4: SelecciÃ³n de las familias de recombinasas\nDefiniciÃ³n de Colores para las Familias de Recombinasa (vector)\n\n\n\n\n\n\nNote\n\n\n\nCrea un vector colclass con cÃ³digos de color hexadecimales (en este caso, todos son \"CDCCCC\").\n\n\n\n# Paleta general de colores\ncolc &lt;- c(\"#D55E00\", \"#E69F00\", \"#F0E442\", \"#56B4E9\", \"#009E73\", \"#0072B2\",\"#CECCCC\")\nnames(colc) &lt;- c(\"IS_Tn\", \"Phage\", \"Phage_like\", \"CE\", \"Integron\", \"MI\", \"Cellular\") \n# Paleta de colores para recombinasas\ncolclass &lt;- c(\"CDCCCC\", \"CDCCCC\", \"CDCCCC\", \"CDCCCC\", \"CDCCCC\")\nnames(colclass) &lt;- c(\"cas\", \"dde\", \"huh\", \"ser\", \"tyr\")\ncolall &lt;- c(colclass, colc)\ncolall\n\n       cas        dde        huh        ser        tyr      IS_Tn      Phage Phage_like         CE   Integron \n  \"CDCCCC\"   \"CDCCCC\"   \"CDCCCC\"   \"CDCCCC\"   \"CDCCCC\"  \"#D55E00\"  \"#E69F00\"  \"#F0E442\"  \"#56B4E9\"  \"#009E73\" \n        MI   Cellular \n \"#0072B2\"  \"#CECCCC\" \n\n\nOrdenamiento de las CategorÃ­as\n\norder_class &lt;- c( \"cas\", \"dde\",\"huh\", \"ser\", \"tyr\")\norder_mge &lt;- c(\"IS_Tn\", \"Phage_like\", \"Phage\", \"CE\", \"MI\", \"Integron\", \"Cellular\")\n\nDefine el orden en el que se mostrarÃ¡n las clases (order_class) y los tipos de MGE (order_mge).\n\norder_class organiza las familias de recombinasas.\norder_mge organiza los distintos tipos de elementos genÃ©ticos mÃ³viles.\n\nTransformaciÃ³n de Datos para VisualizaciÃ³n\n\nmge_solitary_rclass$mge &lt;- factor(mge_solitary_rclass$mge, levels = order_mge) # Convierte la variable mge en un factor, asignÃ¡ndole el orden definido en order_mge\nmge_solitary_rclass_p &lt;- gather_set_data(mge_solitary_rclass, 1:2) # Reestructura los datos con gather_set_data(), seleccionando las primeras dos columnas (1:2). NOTA: Se asume que esta funciÃ³n organiza los datos en un formato adecuado para un grÃ¡fico tipo \"alluvial\" o \"sankey\".\nmge_solitary_rclass_p$y &lt;- factor(mge_solitary_rclass_p$y, levels = c(order_class, order_mge)) # Convierte la variable y en un factor con el orden de order_class y order_mge, asegurando que los datos se alineen correctamente en la visualizaciÃ³n.\nmge_solitary_rclass_p &lt;- mge_solitary_rclass_p %&gt;% add_column(col = colall[match(.$y, names(colall))])\n\n\nAÃ±ade una columna col con colores segÃºn la correspondencia entre los valores de y y los nombres en colall.\n\nmatch(.$y, names(colall)) encuentra el color correspondiente a cada categorÃ­a en colall.\nadd_column() agrega esta informaciÃ³n a mge_solitary_rclass_p.\n\n\n\nrclass_mge_alluvial &lt;- ggplot(mge_solitary_rclass_p, aes(x, id = id, split = y, value = count)) +\n  # x = categorias, id = identificador unico para cada flujo\n  # split = y conexiÃ³n entre las categorÃ­as (clases de recombinasas y tipos de MGE).\n  # value = count: determina el ancho de los flujos segÃºn la cantidad de ocurrencias.\n  # Dibujar los flujos entre categorÃ­as, con un grosor proporcional a count.\n  geom_parallel_sets(aes(fill = mge), color = \"black\", lwd = 0.2, axis.width = 0.26) +\n  geom_parallel_sets_axes(axis.width = 0.22, fill = \"grey80\") + # Dibuja los ejes de las categorÃ­as con un ancho de 0.22 y color gris claro (\"grey80\").\n  geom_parallel_sets_labels( # AÃ±ade etiquetas a los ejes con color negro, tamaÃ±o ajustado (12/.pt), y sin rotaciÃ³n (angle = 0).\n    color = 'black',\n    size = 12/.pt,\n    angle = 0\n  ) +\n  # ConfiguraciÃ³n de Escalas\n  scale_x_discrete(\n    name = NULL,\n    expand = c(0, 0.12)\n  ) +\n  # Elimina marcas en el eje y y ajusta la escala para mejor distribuciÃ³n visual.\n  scale_y_continuous(breaks = NULL, expand = c(0.1, 0)) +\n  # Asigna colores a los MGE segÃºn el vector colc y oculta la leyenda (guide = \"none\").\n  scale_fill_manual(\n  values = colc,\n    guide = \"none\"\n  ) +\n  labs(fill = \"\") +\n  theme_minimal() +\n  theme(\n    axis.text.x = element_blank(),\n    axis.line = element_blank(),\n    axis.ticks = element_blank(),\n    plot.margin = margin(14, 1.5, 2, 1.5)\n  )\nrclass_mge_alluvial\n\n\n\n\nPero esto no se ve como el articulo, por lo que decidimos cambiar el estilo de los bloques de texto a blanco con bordes negros.\n\nrclass_mge_alluvial &lt;- ggplot(mge_solitary_rclass_p, aes(x, id = id, split = y, value = count)) +\n  # x = categorias, id = identificador unico para cada flujo\n  # split = y conexiÃ³n entre las categorÃ­as (clases de recombinasas y tipos de MGE).\n  # value = count: determina el ancho de los flujos segÃºn la cantidad de ocurrencias.\n  # Dibujar los flujos entre categorÃ­as, con un grosor proporcional a count.\n  geom_parallel_sets(aes(fill = mge), color = \"black\", lwd = 0.2, axis.width = 0.26) +\n  geom_parallel_sets_axes(axis.width = 0.22, fill = \"white\", color = \"black\") + # Dibuja los ejes de las categorÃ­as con un ancho de 0.22 y color blanco y borde negro\n  geom_parallel_sets_labels( # AÃ±ade etiquetas a los ejes con color negro, tamaÃ±o ajustado (12/.pt), y sin rotaciÃ³n (angle = 0).\n    color = 'black',\n    size = 12/.pt,\n    angle = 0\n  ) +\n  # ConfiguraciÃ³n de Escalas\n  scale_x_discrete(\n    name = NULL,\n    expand = c(0, 0.12)\n  ) +\n  # Elimina marcas en el eje y y ajusta la escala para mejor distribuciÃ³n visual.\n  scale_y_continuous(breaks = NULL, expand = c(0.1, 0)) +\n  # Asigna colores a los MGE segÃºn el vector colc y oculta la leyenda (guide = \"none\").\n  scale_fill_manual(\n  values = colc,\n    guide = \"none\"\n  ) +\n  labs(fill = \"\") +\n  theme_minimal() +\n  theme(\n    axis.text.x = element_blank(),\n    axis.line = element_blank(),\n    axis.ticks = element_blank(),\n    plot.margin = margin(14, 1.5, 2, 1.5)\n  )\n\n# Agregar titulos superiores\nrclass_mge_alluvial &lt;- rclass_mge_alluvial +\n  annotate(\"text\", x = 1, y = max(mge_solitary_rclass_p$count) * 2.5, label = \"recombinase \\nfamilies\", size = 5) +\nannotate(\"text\", x = 2, y = max(mge_solitary_rclass_p$count) * 2.5, label = \"MGEs\", size = 5)\n\n# Figura 2A completa\nrclass_mge_alluvial"
  },
  {
    "objectID": "Figura2.html#figura-2b-distribucion-de-mges-por-categorÃ­a",
    "href": "Figura2.html#figura-2b-distribucion-de-mges-por-categorÃ­a",
    "title": "Figura 2",
    "section": "Figura 2B Distribucion de MGEs por categorÃ­a",
    "text": "Figura 2B Distribucion de MGEs por categorÃ­a\nNÃºmero de MGEs por categorÃ­a (grÃ¡fico de barras) y porcentaje de cada categorÃ­a (grÃ¡fico de dona) en 76,000 genomas de 3,000 especies, utilizando el flujo de trabajo descrito en la Figura 1.\n\nPASO 5: Calcular el total de MGEs en todos los genomas (sin filtrar por calidad)\n\nmge_pg_melt_all &lt;- mge_pg %&gt;% \n  # Reestructura el data frame en formato largo (long format)\n  reshape2::melt() %&gt;% \n  # Selecciona columnas: columna 1 (genoma), 7 y 8 (variable y valor)\n  select(1,7,8) %&gt;% \n  # Agrupa por tipo de MGE (almacenado en 'variable')\n  group_by(variable) %&gt;% \n  # Suma el total de ocurrencias por cada MGE\n  summarise(total = sum(value)) %&gt;% \n  # Filtra para excluir los elementos anotados como \"Hotspot\"\n  filter(., !grepl(\"Hotspot\", variable))\n\nhead(mge_pg_melt_all)\n\n# A tibble: 6 Ã— 2\n  variable     total\n  &lt;fct&gt;        &lt;dbl&gt;\n1 IS_Tn      1818135\n2 Phage       110316\n3 Phage_like  247907\n4 CE          101625\n5 Integron      8357\n6 MI          155857\n\n\n\n\nPASO 6: Calcular el total de MGEs pero solo para genomas de alta calidad\n\nmge_pg_melt &lt;- mge_pg %&gt;% \n  # Filtra para conservar solo los genomas presentes en la lista de alta calidad (glist_high)\n  filter(Genome %in% glist_high$genome) %&gt;% \n  # Reestructura el data frame en formato largo\n  reshape2::melt() %&gt;% \n  # Selecciona columnas relevantes: genoma, tipo de MGE, valor\n  select(1,7,8) %&gt;% \n  # Agrupa por tipo de MGE\n  group_by(variable) %&gt;% \n  # Suma el total de ocurrencias de cada MGE\n  summarise(total = sum(value)) %&gt;% \n  # Excluye los elementos anotados como \"Hotspot\"\n  filter(., !grepl(\"Hotspot\", variable))\n\nhead(mge_pg_melt)\n\n# A tibble: 6 Ã— 2\n  variable     total\n  &lt;fct&gt;        &lt;dbl&gt;\n1 IS_Tn      1798076\n2 Phage       109456\n3 Phage_like  245051\n4 CE          100480\n5 Integron      8251\n6 MI          154239\n\n\n\n\nPASO 7: Generar un grÃ¡fico de barras para visualizar el total de MGEs en genomas de alta calidad\n\nbarplot_2b &lt;- ggplot(mge_pg_melt, aes(x = reorder(variable, total, sum), y = total, fill = variable)) +\n  # Crea barras con altura segÃºn el total\n  geom_bar(stat = 'identity') +\n  # AÃ±ade etiquetas con el valor total encima de cada barra\n  geom_text(aes(label = total)) + \n  # Invierte los ejes para una mejor visualizaciÃ³n (barras horizontales)\n  coord_flip() +\n  # Aplica una paleta de colores personalizada (definida en 'colc') sin leyenda\n  scale_fill_manual(\"MGE\", values = colc, guide = FALSE) +\n  # Aplica el tema de cowplot para estilo limpio\n  theme_cowplot() + \n  # AÃ±ade etiquetas a los ejes\n  labs(x = \"\", y = \"Counts\")\n\n# Muestra el grÃ¡fico\nbarplot_2b\n\n\n\n\n\n\nPASO 8: Calcular la proporciÃ³n relativa de cada MGE (excluyendo los de tipo â€œCellularâ€) y genera etiquetas para graficar\n\nmge_pg_relative &lt;- mge_pg_melt %&gt;% \n  # Excluye las variables que contienen la palabra \"Cellular\"\n  filter(., !grepl(\"Cellular\", variable)) %&gt;% \n  # Calcula el porcentaje relativo de cada MGE respecto al total\n  mutate(\n    rel = round((total / sum(total)) * 100, digits = 2),\n    # Crea etiquetas con el nombre del MGE y su porcentaje\n    labs = paste0(variable, \" (\", rel, \"%)\")\n  ) %&gt;%\n  # Ordena por total ascendente para mejor visualizaciÃ³n en la grÃ¡fica\n  arrange(total)\n\nhead(mge_pg_relative)\n\n# A tibble: 6 Ã— 4\n  variable     total   rel labs               \n  &lt;fct&gt;        &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;              \n1 Integron      8251  0.34 Integron (0.34%)   \n2 CE          100480  4.16 CE (4.16%)         \n3 Phage       109456  4.53 Phage (4.53%)      \n4 MI          154239  6.39 MI (6.39%)         \n5 Phage_like  245051 10.1  Phage_like (10.14%)\n6 IS_Tn      1798076 74.4  IS_Tn (74.44%)     \n\n\n\n\nPASO 9: Generar un grÃ¡fico de dona (donut chart) para visualizar proporciones relativas de MGEs\n\ndonutchart_2b &lt;- ggdonutchart(\n  mge_pg_relative,     # Data frame con los porcentajes\n  \"rel\",               # Variable a usar como valor (porcentaje)\n  label = \"labs\",      # Etiquetas que se mostrarÃ¡n en la grÃ¡fica\n  lab.pos = \"in\",      # PosiciÃ³n de etiquetas dentro del grÃ¡fico\n  fill = \"variable\",   # Colores de relleno asignados por tipo de MGE\n  color = \"white\",     # Color del borde de cada secciÃ³n de la dona\n  # Paleta personalizada de colores para los MGEs\n  palette = c(\"#D55E00\", \"#E69F00\", \"#F0E442\", \"#56B4E9\", \"#009E73\", \"#0072B2\", \"#CECCCC\")\n)\n\n# Muestra el grÃ¡fico de dona\ndonutchart_2b\n\n\n\n\n\n\nPASO 10: Modificaciones de la Figura 2B\nEn esta versiÃ³n del grÃ¡fico de barras, se hicieron dos ajustes importantes para mejorar la legibilidad de los nÃºmeros que aparecen al lado de cada barra:\n\nbarplot_2b &lt;- ggplot(mge_pg_melt, aes(x = reorder(variable, total, sum), y = total, fill = variable)) +\n  # Crea barras con altura segÃºn el total\n  geom_bar(stat = 'identity') +\n  # AÃ±ade etiquetas con el valor total encima de cada barra\n  geom_text(aes(label = total), hjust = -0.05) + \n  # Invierte los ejes para una mejor visualizaciÃ³n (barras horizontales)\n  coord_flip() +\n  # Aplica una paleta de colores personalizada (definida en 'colc') sin leyenda\n  scale_fill_manual(\"MGE\", values = colc, guide = FALSE) +\n  # Aumentar el espacio extra a la derecha para que no se corten las etiquetas\n  scale_y_continuous(expand = expansion(mult = c(0, 0.2))) +\n  # Aplica el tema de cowplot para estilo limpio\n  theme_cowplot() + \n  # AÃ±ade etiquetas a los ejes\n  labs(x = \"\", y = \"Counts\")\n\n# Muestra el grÃ¡fico\nbarplot_2b\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nEl parÃ¡metro hjust = -0.05 mueve las etiquetas hacia la derecha del final de cada barra.\nSin esta modificaciÃ³n, los nÃºmeros podrÃ­an quedar demasiado pegados a la barra, o incluso encimarse o cortarse.\nğŸ’¡ hjust controla la alineaciÃ³n horizontal:\n\nhjust = 1: texto alineado al final de la barra.\nhjust = 0: alineado al inicio de la barra.\nhjust &lt; 0: mueve el texto mÃ¡s allÃ¡ del final, hacia la derecha.\n\n\n\n\nEn esta versiÃ³n del grÃ¡fico de donut plot, se hicieron ajusto el texto para mejorar la legibilidad de las proporciones que aparecen al lado del plot:\n\n# Calcular proporciones y posiciones\nmge_pg_relative &lt;- mge_pg_melt %&gt;%\n  filter(!grepl(\"Cellular\", variable)) %&gt;%\n  mutate(\n    rel = round((total / sum(total)) * 100, 2),\n    labs = paste0(variable, \" (\", rel, \"%)\")\n  ) %&gt;%\n  arrange(desc(variable)) %&gt;%\n  mutate(\n    ymax = cumsum(rel),\n    ymin = c(0, head(ymax, n = -1)),\n    label_pos = (ymin + ymax) / 2\n  )\n\n# GrÃ¡fico de dona con etiquetas visibles y repelentes\ndonutchart_custom &lt;- ggplot(mge_pg_relative, aes(ymax = ymax, ymin = ymin, xmax = 4.5, xmin = 2.8, fill = variable)) +\n  geom_rect(color = \"white\") +\n  coord_polar(theta = \"y\") +\n  xlim(c(2.5, 5)) +  # Aumentamos espacio a la derecha para las etiquetas\n  theme_void() +\n  scale_fill_manual(values = c(\"#D55E00\", \"#E69F00\", \"#F0E442\", \"#56B4E9\", \"#009E73\", \"#0072B2\", \"#CECCCC\")) +\n  geom_text_repel(\n    aes(x = 4.5, y = label_pos, label = labs),\n    size = 4,\n    nudge_x = 0.5,\n    direction = \"y\",\n    segment.size = 0.3,\n    show.legend = FALSE,\n    min.segment.length = 0,\n    box.padding = 0.3\n  ) +\n  theme(legend.position = \"none\")\n\ndonutchart_custom\n\n\n\n\nUnir graficas\n\n# Insertar el donut plot dentro del barplot\nFig2B_combined_plot &lt;- ggdraw() +\n  draw_plot(barplot_2b) +  # GrÃ¡fico base\n  draw_plot(donutchart_custom, \n            x = 0.35, y = 0.05,       # PosiciÃ³n dentro del lienzo (ajustable)\n            width = 0.8, height = 0.8)  # TamaÃ±o del donut ployt (ajustable)\n\nFig2B_combined_plot"
  },
  {
    "objectID": "Figura2.html#figura-2c-anÃ¡lisis-de-longitudes-de-mge-solitarios",
    "href": "Figura2.html#figura-2c-anÃ¡lisis-de-longitudes-de-mge-solitarios",
    "title": "Figura 2",
    "section": "Figura 2C AnÃ¡lisis de longitudes de MGE solitarios",
    "text": "Figura 2C AnÃ¡lisis de longitudes de MGE solitarios\n\nPASO 11: Obtener las longitudes (todos los genomas)\n\nmge_solitary_length_all &lt;- mge_solitary %&gt;% \n  select(1:11) %&gt;%  # Selecciona las primeras 11 columnas\n  gather(mge, mge_pa, 1:9) %&gt;%  # Convierte las columnas 1 a 9 a formato largo\n  filter(mge_pa == 1) %&gt;%  # Filtra solo las filas donde el MGE estÃ¡ presente\n  filter(., !grepl(\"UC\", mge)) %&gt;%  # Elimina filas con \"UC\" en el nombre del MGE\n  filter(., !grepl(\"Hotspot\", mge))  # Elimina filas con \"Hotspot\" en el nombre del MGE\n\n\n\nPASO 12: Obtener la longitud de MGEs de los genomas de alta calidad\n\nmge_solitary_length &lt;- mge_solitary %&gt;% \n  select(1:11) %&gt;%  # Selecciona las primeras 11 columnas\n  gather(mge, mge_pa, 1:9) %&gt;%  # Convierte las columnas 1 a 9 a formato largo\n  filter(mge_pa == 1) %&gt;%  # Filtra solo las filas donde el MGE estÃ¡ presente\n  filter(., !grepl(\"UC\", mge)) %&gt;%  # Elimina filas con \"UC\" en el nombre del MGE\n  filter(., !grepl(\"Hotspot\", mge)) %&gt;%  # Elimina filas con \"Hotspot\" en el nombre del MGE\n  separate(island, c(\"g1\", \"g2\", \"g3\")) %&gt;%  # Divide el nombre de la isla en tres partes\n  mutate(genome = paste(g1, g2, sep = \".\")) %&gt;%  # Re-crea el nombre del genoma usando g1 y g2\n  select(-g1, -g2, -g3) %&gt;%  # Elimina las columnas g1, g2 y g3\n  filter(genome %in% glist_high$genome)  # Filtra solo los genomas de alta calidad\n\n# Eliminar filas con NA\nmge_solitary_length_clean &lt;- mge_solitary_length %&gt;% na.omit()\n\n\n\nPASO 13: Graficar de caja de las longitudes de islas por tipo de MGE\n\nmge_length_boxplot &lt;- ggplot(mge_solitary_length, aes(x = reorder(mge, -island_size, median), y = island_size, fill = mge)) + \n  geom_boxplot(outlier.shape = NA, notch = FALSE, lwd = 1) +  # Crea un grÃ¡fico de caja sin mostrar los valores atÃ­picos\n  scale_fill_manual(\"MGE\", values = colc, guide = FALSE) +  # Asigna colores personalizados para cada tipo de MGE\n  scale_y_continuous(limits = quantile(mge_solitary_length$island_size, c(0.1, 0.9))) +  # Limita el eje Y entre el percentil 10 y 90\n  coord_flip() +  # Rota el grÃ¡fico para que las categorÃ­as estÃ©n en el eje Y\n  labs(y = \"Length (bp)\", x = \"\") +  # AÃ±ade etiquetas a los ejes\n  theme_cowplot(font_size = 20)  # Aplica un tema limpio y ajusta el tamaÃ±o de fuente\n\n# Mostrar el grÃ¡fico\nmge_length_boxplot\n\n\n\n\n\n\nPASO 14: Unir la grafica final\n\n # Figura A en el lado izquierdo\nizquierda_plot &lt;- plot_grid(rclass_mge_alluvial, \n                            labels = 'A', label_size = 12,\n                            ncol = 1)# Establecer una sola columna para B y C\n\n# Figura B y C en el lado derecho\nderecha_plot &lt;- plot_grid(Fig2B_combined_plot, mge_length_boxplot, \n                            labels = c('B', 'C'), label_size = 12,\n                            ncol = 1)# Establecer una sola columna para B y C\n\n# Unir los grÃ¡ficos\nFigura2_final_plot &lt;- plot_grid(\n  izquierda_plot,                      # Figura A en el lado izquierdo\n  derecha_plot,                    # Figura B y C en el lado derecho\n  ncol = 2,                         # DiseÃ±o en dos columnas\n  rel_widths = c(1, 1.5)        # Ajustar las proporciones de los anchos (A es mÃ¡s pequeÃ±o)\n)\n\n# Mostrar el grÃ¡fico final\nFigura2_final_plot\n\n\n\n\nPuedes encontrar el script completo en Figura2_modificado.R."
  },
  {
    "objectID": "Figura3.html",
    "href": "Figura3.html",
    "title": "Figura 3",
    "section": "",
    "text": "Figura 3. DistribuciÃ³n taxonÃ³mica de los MGEs\n\n\nA. Prevalencia de las categorÃ­as de MGEs y predominio de los elementos transponibles en distintas clases taxonÃ³micas (con al menos 10 genomas), ordenadas segÃºn la filogenia basada en genes marcadores taxonÃ³micos (38).\nB. AsociaciÃ³n de las categorÃ­as de MGEs (promedio de MGEs por especie) con diferentes clases taxonÃ³micas (prueba de rango de Wilcoxon, * indica un valor de P &lt; 0.05 despuÃ©s de la correcciÃ³n de Bonferroni).\n\nlibrary(tidyverse) # Manipulacion de datos\nlibrary(reshape2)\nlibrary(phytools)  # Manipulacion de arboles filogeneticos\nlibrary(ape)\nlibrary(viridisLite)\nlibrary(viridis)\nlibrary(scales)\nlibrary(cowplot)"
  },
  {
    "objectID": "Figura3.html#distribuciÃ³n-taxonÃ³mica-de-los-elementos-genÃ©ticos-mÃ³viles",
    "href": "Figura3.html#distribuciÃ³n-taxonÃ³mica-de-los-elementos-genÃ©ticos-mÃ³viles",
    "title": "Figura 3",
    "section": "",
    "text": "Figura 3. DistribuciÃ³n taxonÃ³mica de los MGEs\n\n\nA. Prevalencia de las categorÃ­as de MGEs y predominio de los elementos transponibles en distintas clases taxonÃ³micas (con al menos 10 genomas), ordenadas segÃºn la filogenia basada en genes marcadores taxonÃ³micos (38).\nB. AsociaciÃ³n de las categorÃ­as de MGEs (promedio de MGEs por especie) con diferentes clases taxonÃ³micas (prueba de rango de Wilcoxon, * indica un valor de P &lt; 0.05 despuÃ©s de la correcciÃ³n de Bonferroni).\n\nlibrary(tidyverse) # Manipulacion de datos\nlibrary(reshape2)\nlibrary(phytools)  # Manipulacion de arboles filogeneticos\nlibrary(ape)\nlibrary(viridisLite)\nlibrary(viridis)\nlibrary(scales)\nlibrary(cowplot)"
  },
  {
    "objectID": "Figura3.html#paso-1-importar-datos",
    "href": "Figura3.html#paso-1-importar-datos",
    "title": "Figura 3",
    "section": "PASO 1: Importar datos",
    "text": "PASO 1: Importar datos\n\ntax &lt;- read_tsv(\"data/raw_data/species_with_atleast_2genomes.list.gz\", col_names=F)\ndb &lt;-read_tsv(\"data/processed_data/mge_bins_per_genome_final.txt.gz\", col_names = T)\ngs &lt;-read_tsv(\"data/raw_data/genome_size.txt.gz\", col_names = T)\nclass_tree &lt;- read.tree(\"data/raw_data/progenomes2_class_tree.nwk\")\nglist &lt;- read_tsv(\"data/raw_data/genome_status_supplementary_tableS2.txt.gz\", col_names = T)\n\nCargar paleta de colores\n\n# Paleta general de colores\ncolc &lt;- c(\"#D55E00\", \"#E69F00\", \"#F0E442\", \"#56B4E9\", \"#009E73\", \"#0072B2\",\"#CECCCC\")\nnames(colc) &lt;- c(\"IS_Tn\", \"Phage\", \"Phage_like\", \"CE\", \"Integron\", \"MI\", \"Cellular\") \n\nCargar funciones\n\nsource(\"scripts/phylo_function.R\")"
  },
  {
    "objectID": "Figura3.html#paso-2-manipulaciÃ³n-y-limpieza-de-los-datos",
    "href": "Figura3.html#paso-2-manipulaciÃ³n-y-limpieza-de-los-datos",
    "title": "Figura 3",
    "section": "PASO 2: ManipulaciÃ³n y Limpieza de los datos",
    "text": "PASO 2: ManipulaciÃ³n y Limpieza de los datos\n\n# Obtener los genomas con la mas alta calidad\nglist_high &lt;- glist %&gt;% \n  filter(genome_quality == \"high\")\n\n\n# Renombra las columnas del dataframe tax para un nombre mÃ¡s legible\ncolnames(tax) &lt;- c(\"specI\", \"genomeID\", \"kingdom\", \"phylum\", \"class\", \"genus\")\n\n# Reestructura la base de datos 'db' de formato ancho a largo usando reshape2::melt\nmdb &lt;- db %&gt;% reshape2::melt() \n\n# Renombra las columnas de la base de datos reestructurada para claridad\nmdb &lt;- mdb %&gt;% \n  dplyr::rename(mge = variable, count = value, genomeID = 'Genome') %&gt;% \n  # Filtra para incluir solo los genomas de alta calidad (genomas en glist_high$genome)\n  filter(genomeID %in% glist_high$genome)"
  },
  {
    "objectID": "Figura3.html#paso-3-data.frame-con-combinaciones",
    "href": "Figura3.html#paso-3-data.frame-con-combinaciones",
    "title": "Figura 3",
    "section": "PASO 3: Data.frame con combinaciones",
    "text": "PASO 3: Data.frame con combinaciones\n\nDatos de formato\nCrear un data.frame que contenga para cada specI para cada MGE: recuentos genÃ³micos (genomeCnt),\n\nconteos totales (cnt_tot),\npromedio de recuentos entre genomas (avg_cnt),\nnÃºmero de genomas en los que estaba presente el MGE (pa),\nla fracciÃ³n de genomas con el MGE presente (frac) mÃ¡s informaciÃ³n taxonÃ³mica\n\n\n# Selecciona las columnas necesarias para trabajar con los datos\nmdb_cnt &lt;- mdb %&gt;% select(1, 7, 8)\n# Obtiene los valores Ãºnicos de MGE\nall_mge &lt;- unique(mdb$mge)\n\n# Inicializa un data.frame vacÃ­o donde se almacenarÃ¡n las combinaciones\ndb_tax &lt;- NULL       \n\n# Itera sobre todos los valores Ãºnicos de MGE\nfor(i in 1:length(all_mge)){\n  # Para cada MGE, se agrega una nueva columna 'mge' con el valor del MGE actual\n  db_tax_sing &lt;- tax %&gt;% add_column(mge = all_mge[i])\n  # Une el data.frame actual con el anterior (rbind), creando una tabla con todas las combinaciones\n  db_tax &lt;- rbind(db_tax, db_tax_sing)\n}\n# Muestra las primeras filas del data.frame resultante\nhead(db_tax)\n\n# A tibble: 6 Ã— 7\n  specI               genomeID             kingdom  phylum         class               genus            mge  \n  &lt;chr&gt;               &lt;chr&gt;                &lt;chr&gt;    &lt;chr&gt;          &lt;chr&gt;               &lt;chr&gt;            &lt;fct&gt;\n1 specI_v3_Cluster1   100053.SAMN02947772  Bacteria Spirochaetes   Spirochaetia        Leptospirales    IS_Tn\n2 specI_v3_Cluster201 1000561.SAMN02471202 Bacteria Proteobacteria Gammaproteobacteria Pseudomonadales  IS_Tn\n3 specI_v3_Cluster361 1000562.SAMN03114893 Bacteria Firmicutes     Bacilli             Lactobacillales  IS_Tn\n4 specI_v3_Cluster371 1000565.SAMN02471991 Bacteria Proteobacteria Betaproteobacteria  Nitrosomonadales IS_Tn\n5 specI_v3_Cluster564 1000568.SAMN00255229 Bacteria Firmicutes     Negativicutes       Veillonellales   IS_Tn\n6 specI_v3_Cluster565 1000569.SAMN00255226 Bacteria Firmicutes     Negativicutes       Veillonellales   IS_Tn"
  },
  {
    "objectID": "Figura3.html#paso-4-contar-el-nÃºmero-de-genomas-por-especie-y-clase-taxonÃ³mica",
    "href": "Figura3.html#paso-4-contar-el-nÃºmero-de-genomas-por-especie-y-clase-taxonÃ³mica",
    "title": "Figura 3",
    "section": "PASO 4: Contar el nÃºmero de genomas por especie y clase taxonÃ³mica",
    "text": "PASO 4: Contar el nÃºmero de genomas por especie y clase taxonÃ³mica\n\n# Filtra los genomas que estÃ¡n en 'glist_high$genome' y los combina con los recuentos de MGE\ndb_cnt_all &lt;- db_tax %&gt;% \n  filter(genomeID %in% glist_high$genome) %&gt;%   # Filtra para obtener solo los genomas que estÃ¡n en 'glist_high$genome'\n  left_join(., mdb_cnt, by = c(\"genomeID\", \"mge\"))  # Realiza una uniÃ³n de izquierda con 'mdb_cnt' usando 'genomeID' y 'mge'\n\n# Reemplaza todos los valores NA en el data.frame por 0\ndb_cnt_all[is.na(db_cnt_all)] &lt;- 0\n\n# Contar el nÃºmero de genomas por especie y clase taxonÃ³mica\ndb_cnt_all %&gt;% \n  # Selecciona las columnas relevantes: 'specI', 'genomeID', y 'class'\n  select(specI, genomeID, class) %&gt;%\n  # Elimina duplicados, dejando solo combinaciones Ãºnicas de especie, genoma y clase\n  unique() %&gt;%    \n  # Agrupa los datos por clase taxonÃ³mica ('class')\n  group_by(class) %&gt;%   \n  # Cuenta el nÃºmero de genomas por cada clase\n  summarise(count = n()) %&gt;%       \n  # Filtra para solo mostrar las clases que tienen mÃ¡s de 9 genomas\n  filter(count &gt; 9) %&gt;%                  \n  head()\n\n# A tibble: 6 Ã— 2\n  class               count\n  &lt;chr&gt;               &lt;int&gt;\n1 Acidithiobacillia      18\n2 Actinobacteria       9859\n3 Alphaproteobacteria  2001\n4 Bacilli             25644\n5 Bacteroidia           570\n6 Betaproteobacteria   3998\n\n# Crear un data.frame de presencia y ausencia\n## Agregar informaciÃ³n de presencia y ausencia\ndb_pa_all &lt;- db_cnt_all %&gt;% mutate(presAbs = ifelse(count &gt; 0, 1, 0))\n\nhead(db_pa_all)\n\n# A tibble: 6 Ã— 9\n  specI               genomeID             kingdom  phylum         class               genus         mge   count presAbs\n  &lt;chr&gt;               &lt;chr&gt;                &lt;chr&gt;    &lt;chr&gt;          &lt;chr&gt;               &lt;chr&gt;         &lt;fct&gt; &lt;dbl&gt;   &lt;dbl&gt;\n1 specI_v3_Cluster1   100053.SAMN02947772  Bacteria Spirochaetes   Spirochaetia        Leptospirales IS_Tn    22       1\n2 specI_v3_Cluster201 1000561.SAMN02471202 Bacteria Proteobacteria Gammaproteobacteria Pseudomonadaâ€¦ IS_Tn     5       1\n3 specI_v3_Cluster361 1000562.SAMN03114893 Bacteria Firmicutes     Bacilli             Lactobacillaâ€¦ IS_Tn     5       1\n4 specI_v3_Cluster371 1000565.SAMN02471991 Bacteria Proteobacteria Betaproteobacteria  Nitrosomonadâ€¦ IS_Tn    24       1\n5 specI_v3_Cluster564 1000568.SAMN00255229 Bacteria Firmicutes     Negativicutes       Veillonellalâ€¦ IS_Tn     3       1\n6 specI_v3_Cluster565 1000569.SAMN00255226 Bacteria Firmicutes     Negativicutes       Veillonellalâ€¦ IS_Tn     2       1"
  },
  {
    "objectID": "Figura3.html#paso-5-agrupar-todos-los-genomas-por-especie-speci",
    "href": "Figura3.html#paso-5-agrupar-todos-los-genomas-por-especie-speci",
    "title": "Figura 3",
    "section": "PASO 5: Agrupar todos los genomas por especie (specI)",
    "text": "PASO 5: Agrupar todos los genomas por especie (specI)\n\n## Resumir: avg_cnt = promedio de recuento por MGE por especie (specI), frac = fracciÃ³n de genomas por especie con cada MGE\ndb_specI &lt;- db_pa_all %&gt;% \n  # Agrupar los datos por especie (specI) y MGE\n  group_by(specI, mge) %&gt;%\n  # Contar el nÃºmero de genomas por combinaciÃ³n de 'specI' y 'mge'\n  summarise(genomeCnt = n(),   \n            # Calcular el promedio de recuento por MGE por especie\n            avg_cnt = mean(count),      \n            # Calcular la presencia (1) total para cada MGE por especie\n            pa = sum(presAbs),    \n            # Calcular el total de recuentos para cada MGE por especie\n            cnt_tot = sum(count)) %&gt;% \n   # Calcular la fracciÃ³n de genomas por especie que tienen el MGE\n  mutate(frac = pa / genomeCnt) %&gt;%        \n  # Unir los datos con la informaciÃ³n taxonÃ³mica de 'tax' utilizando 'specI'\n  left_join(., tax, by = \"specI\") %&gt;%  \n  # Eliminar la columna 'genomeID' que no es necesaria\n  select(-genomeID) %&gt;%         \n  # Eliminar filas duplicadas\n  unique(.)                                 \n\n\n## Resumir: avg_cnt = promedio de recuento por MGE por genoma, frac = fracciÃ³n de genomas con cada MGE\ndb_genome &lt;- db_pa_all %&gt;% \n  # Agrupar los datos por genoma (genomeID) y MGE\n  group_by(genomeID, mge) %&gt;%       \n  # Contar el nÃºmero de combinaciones de genoma y MGE\n  summarise(genomeCnt = n(),   \n            # Calcular el promedio de recuento de cada MGE por genoma\n            avg_cnt = mean(count),  \n            # Calcular la presencia total de MGE en cada genoma\n            pa = sum(presAbs),         \n            # Calcular el total de recuentos de MGE por genoma\n            cnt_tot = sum(count)) %&gt;%  \n  # Calcular la fracciÃ³n de genomas con el MGE\n  mutate(frac = pa / genomeCnt) %&gt;%       \n  # Unir los datos con la informaciÃ³n taxonÃ³mica utilizando 'genomeID'\n  left_join(., tax, by = \"genomeID\") %&gt;%     \n  # Eliminar filas duplicadas\n  unique(.)                                  \n\nCrear data frames separados para los recuentos de MGE y las fracciones de MGE.\n\n# Promedio de recuentos de cada MGE por especie (specI), donde los MGEs son las columnas y las especies (specI) las filas\nall_cnt_specI &lt;- db_specI %&gt;% \n  select(specI, mge, avg_cnt)   # Selecciona las columnas 'specI' (especie), 'mge' (MGE), y 'avg_cnt' (promedio de recuentos)\n\nall_frac_specI &lt;- db_specI %&gt;% \n  select(specI, mge, frac)      # Selecciona las columnas 'specI' (especie), 'mge' (MGE), y 'frac' (fracciÃ³n de genomas con el MGE)\n\nall_cnt_genome &lt;- db_genome %&gt;% \n  select(genomeID, mge, avg_cnt) # Selecciona las columnas 'genomeID' (ID de genoma), 'mge' (MGE), y 'avg_cnt' (promedio de recuentos)"
  },
  {
    "objectID": "Figura3.html#paso-6-anÃ¡lisis-por-especie-speci-a-nivel-de-clase",
    "href": "Figura3.html#paso-6-anÃ¡lisis-por-especie-speci-a-nivel-de-clase",
    "title": "Figura 3",
    "section": "PASO 6: AnÃ¡lisis por especie (specI) a nivel de clase",
    "text": "PASO 6: AnÃ¡lisis por especie (specI) a nivel de clase\nSe utiliza la prueba de Mann-Whitney para analizar asociaciones de los MGEs a nivel de clase. El anÃ¡lisis se basa en la fracciÃ³n de genomas por especiaciÃ³n (SpecI) que contiene el MGE para evitar sesgos de muestreo.\n\n# entrada de datos\nall_avg_cnt_tax_class &lt;-  db_specI %&gt;% \n  select(specI, mge, avg_cnt, class) %&gt;%   # Selecciona las columnas: 'specI', 'mge', 'avg_cnt' y 'class'\n  filter(., !grepl(\"Hotspot\", mge)) %&gt;%    # Filtra para excluir los MGEs que contienen \"Hotspot\" en su nombre\n  filter(., !grepl(\"Cellular\", mge))       # Filtra para excluir los MGEs que contienen \"Cellular\" en su nombre\n\nallMges &lt;- unique(all_avg_cnt_tax_class$mge)  # Extrae los valores Ãºnicos de MGEs\n\n# Filtrar para clases con al menos 10 genomas\nallClasses &lt;- all_avg_cnt_tax_class %&gt;% \n  filter(mge == all_avg_cnt_tax_class$mge[1]) %&gt;%  # Filtra para mantener solo el primer MGE\n  group_by(class) %&gt;%   # Agrupa los datos por clase\n  summarise(cntClass = n()) %&gt;%  # Cuenta cuÃ¡ntos genomas existen por clase\n  filter(cntClass &gt; 9)   # Filtra las clases con mÃ¡s de 9 genomas\n\n# SelecciÃ³n final de datos para el anÃ¡lisis\nall_avg_cnt_tax_class_sel_pre &lt;- all_avg_cnt_tax_class %&gt;% \n  filter(class %in% allClasses$class)   # Filtra las especies para incluir solo aquellas pertenecientes a clases con al menos 10 genomas"
  },
  {
    "objectID": "Figura3.html#paso-7-normalizaciÃ³n-por-tamaÃ±o-de-genoma",
    "href": "Figura3.html#paso-7-normalizaciÃ³n-por-tamaÃ±o-de-genoma",
    "title": "Figura 3",
    "section": "PASO 7: NormalizaciÃ³n por tamaÃ±o de genoma",
    "text": "PASO 7: NormalizaciÃ³n por tamaÃ±o de genoma\nSe calcula el tamaÃ±o promedio del genoma por cada especie (SpecI) y se normaliza el recuento de MGEs por el tamaÃ±o del genoma.\n\n# Promedio de tamaÃ±o de genoma por especie (SpecI)\ngs_int &lt;- gs %&gt;% \n  group_by(SpecI_id_v3) %&gt;% \n  summarise(avg_gs = mean(ProteinGeneCounts)) %&gt;% \n  dplyr::rename(specI = SpecI_id_v3)\n\n# Unir la informaciÃ³n de tamaÃ±o de genoma con el promedio de recuentos de MGEs por especie y normalizar los recuentos por tamaÃ±o de genoma\nall_avg_cnt_tax_class_sel &lt;- left_join(all_avg_cnt_tax_class_sel_pre, gs_int, by = \"specI\") %&gt;% \n  mutate(norm_count = avg_cnt / avg_gs) %&gt;%  # NormalizaciÃ³n: se divide el recuento promedio por el tamaÃ±o del genoma\n  dplyr::rename(count = avg_cnt, avg_cnt = norm_count)  # Renombrar las columnas para mayor claridad\n\nRealizar la prueba de Mann-Whitney para comparar recuentos de MGE entre clases.\n\nMW_all &lt;- NULL\nfor(i in 1:length(allMges)){  # Iterar sobre todos los MGEs\n  mgeX &lt;- allMges[i]  # Seleccionar el MGE actual\n  mgeDat &lt;- all_avg_cnt_tax_class_sel %&gt;% filter(mge == mgeX)  # Filtrar los datos para el MGE seleccionado\n  \n  MW &lt;- sapply(seq_along(allClasses$class), function(j){\n    class_sel &lt;- allClasses$class[j]  # Seleccionar la clase actual\n    ingroup &lt;- mgeDat %&gt;% filter(class == class_sel)  # Filtrar datos de la clase seleccionada (ingroup)\n    outgroup &lt;- mgeDat %&gt;% filter(class != class_sel)  # Filtrar datos de las clases no seleccionadas (outgroup)\n    \n    # Realizar la prueba de Mann-Whitney para comparar los recuentos promedio de MGE entre las clases\n    MWout &lt;- wilcox.test(ingroup$avg_cnt, outgroup$avg_cnt, alternative = \"greater\")\n    out &lt;- c(class_sel, MWout$p.value)  # Guardar el resultado de la prueba (clase y p-value)\n    return(out)\n  })\n  \n  MWOut &lt;- as.data.frame(t(MW[2,]))  # Convertir los resultados de la prueba en un data frame\n  colnames(MWOut) &lt;- MW[1,]  # Asignar los nombres de las clases como nombres de columna\n  rownames(MWOut) &lt;- mgeX  # Asignar el nombre del MGE como nombre de fila\n  MW_all &lt;- rbind(MW_all, MWOut)  # Unir los resultados de la prueba para todos los MGEs\n}\n\n# Transponer los resultados finales de la prueba\nMW_all_mod &lt;- as.data.frame(t(MW_all))\n\nhead(MW_all_mod)\n\n                                   IS_Tn                Phage           Phage_like                   CE\nActinobacteria         0.999999917916124                    1                    1                    1\nAlphaproteobacteria   0.0178414060867117   0.0001231858382891   0.0588004481841716 8.61021742019938e-11\nBacilli             1.98748444995478e-06 8.27765421556004e-16 7.42579596027798e-13    0.854734318526737\nBacteroidia          0.00833722978655579                    1    0.902740265915529 1.19966727801307e-41\nBetaproteobacteria     0.107452414634065 2.00283676907074e-05    0.746214226095515    0.999999817280502\nChlamydiia             0.997521561347641     0.99991406834231    0.988672166822885    0.999936175938603\n                                Integron                   MI\nActinobacteria                         1    0.999999678245156\nAlphaproteobacteria  0.00014653261414839    0.999997587920911\nBacilli                                1 2.06109350055861e-10\nBacteroidia         9.34842687990597e-06 9.19715441949629e-44\nBetaproteobacteria  0.000506083290088997    0.788218472081803\nChlamydiia             0.962626875393123    0.999998724073782\n\n\nAjuste de valores p para mÃºltiples comparaciones.\n\nMW_all_adj &lt;- NULL  # Inicializar un objeto vacÃ­o para almacenar los resultados ajustados\n\n# Iterar sobre cada columna de los resultados de la prueba de Mann-Whitney\nfor(k in 1:ncol(MW_all_mod)){\n  MW_all_mod2 &lt;- as.matrix(MW_all_mod)  # Convertir el data frame en una matriz para facilitar el acceso a las columnas\n  pVec &lt;- c(MW_all_mod2[,k])  # Extraer la columna k, que contiene los valores p de la prueba de Mann-Whitney\n  adjP &lt;- p.adjust(pVec, \"BH\")  # Ajustar los valores p utilizando el mÃ©todo de Benjamini-Hochberg (\"BH\")\n  MW_all_adj &lt;- cbind(MW_all_adj, adjP)  # Unir los valores p ajustados a la matriz final\n}\n\n# Asignar los nombres de las columnas originales a los resultados ajustados\ncolnames(MW_all_adj) &lt;- colnames(MW_all_mod)\n\n# Convertir el resultado final en un data frame\nMW_all_fin &lt;- as.data.frame(MW_all_adj)\n\nCrear una tabla binaria con valores p &lt; 0.1 --&gt; 1, de lo contrario 0\n\nMW_all_stat &lt;- NULL  # Inicializar un objeto vacÃ­o para almacenar los resultados binarios\n\n# Iterar sobre cada columna de los resultados ajustados (MW_all_fin)\nfor(l in 1:ncol(MW_all_fin)){\n  # Crear una columna \"signP\" con valor 1 si el valor p es menor a 0.1, y 0 en caso contrario\n  MW_test &lt;- MW_all_fin %&gt;% mutate(signP=ifelse(MW_all_fin[,l]&gt;0.1,0,1))  \n  MW_all_stat &lt;- cbind(MW_all_stat, MW_test$signP)  # Unir los resultados binarios\n}\n\n# Convertir la matriz a un data frame\nMW_all_stat &lt;- as.data.frame(MW_all_stat)\n\n# Asignar los nombres de las columnas y filas a la tabla binaria\ncolnames(MW_all_stat) &lt;- colnames(MW_all_fin)\nrownames(MW_all_stat) &lt;- rownames(MW_all_fin)\n\n# Sumar los valores de \"signP\" por fila para obtener el nÃºmero total de pruebas significativas por MGE\nMW_all_stat_sum &lt;- MW_all_stat %&gt;% mutate(sumSign=rowSums(.))\n\n# Agregar los nombres de las filas a la tabla para obtener un formato adecuado\nMW_all_stat2 &lt;- cbind(rownames(MW_all_stat), MW_all_stat)\ncolnames(MW_all_stat2)[1] &lt;- \"class\"  # Renombrar la primera columna como \"class\"\n\nMW_all_fin2 &lt;- cbind(rownames(MW_all_fin), MW_all_fin)\ncolnames(MW_all_fin2)[1] &lt;- \"class\""
  },
  {
    "objectID": "Figura3.html#paso-8-tabla-con-pvalues-y-especies",
    "href": "Figura3.html#paso-8-tabla-con-pvalues-y-especies",
    "title": "Figura 3",
    "section": "PASO 8: Tabla con pvalues y especies",
    "text": "PASO 8: Tabla con pvalues y especies\n\n#  1. Reorganizar el dataframe 'MW_all_fin2' de formato ancho a largo (long format).\n# Esto es Ãºtil para preparar los datos para ggplot o anÃ¡lisis por variable.\nmelted_specI_class &lt;- reshape2::melt(MW_all_fin2)\n\n# 2. AÃ±adir una columna 'signP' que marque con \"*\" si el valor (p-valor) es significativo (menor o igual a 0.05).\n# Si el valor es mayor a 0.05, deja la celda vacÃ­a.\nmelted_specI_class1 &lt;- melted_specI_class %&gt;%\n  mutate(signP = ifelse(value &gt; 0.05, \"\", \"*\"))\n\n# 3. Calcular el promedio de 'count' por combinaciÃ³n de clase taxonÃ³mica ('class') y elemento genÃ©tico mÃ³vil ('mge'),\n# y renombrar la columna 'mge' como 'variable' para que coincida con el dataframe anterior.\nall_avg_cnt_tax_class_sel1 &lt;- all_avg_cnt_tax_class_sel %&gt;%\n  group_by(class, mge) %&gt;%\n  summarise(avg_class = mean(count), .groups = \"drop\") %&gt;%\n  dplyr::rename(variable = mge)\n\n# 4. Unir los datos con los valores derretidos y la informaciÃ³n de significancia.\n# La uniÃ³n se hace por las columnas 'class' y 'variable'.\nplot_table_w_g9 &lt;- left_join(melted_specI_class1, all_avg_cnt_tax_class_sel1, by = c(\"class\", \"variable\"))\n\n# 5. (Redundante) Se repite la uniÃ³n anterior. Puedes eliminar esta lÃ­nea si no necesitas tener dos versiones del mismo objeto.\nplot_table &lt;- left_join(melted_specI_class1, all_avg_cnt_tax_class_sel1, by = c(\"class\", \"variable\"))"
  },
  {
    "objectID": "Figura3.html#paso-9-datos-para-mapa-de-colores-para-filogenia",
    "href": "Figura3.html#paso-9-datos-para-mapa-de-colores-para-filogenia",
    "title": "Figura 3",
    "section": "PASO 9: Datos para Mapa de colores para filogenia",
    "text": "PASO 9: Datos para Mapa de colores para filogenia\nCrear el mapa de calor filogenÃ©tico con normalizaciÃ³n de los valores\n\nnormalize &lt;- function(x) {  # FunciÃ³n para normalizar los valores entre 0 y 1\n  x/max(x)\n}\n\n# Crear la matriz de datos para el mapa de calor filogenÃ©tico\nphylo_heatmap_mat &lt;- all_avg_cnt_tax_class_sel1 %&gt;% \n  # Filtrar clases que no contienen \"NA\"\n  filter(!grepl(\"NA \", class)) %&gt;%  \n  # Convertir los datos en formato ancho (cada variable como columna)\n  spread(variable, avg_class) %&gt;%  \n  # Seleccionar las variables de interÃ©s\n  dplyr::select(class, IS_Tn, Phage, Phage_like, CE, Integron, MI) %&gt;%  \n  # Establecer las clases como nombres de fila\n  column_to_rownames(var = \"class\")  \n\n\n# Crear el Ã¡rbol filogenÃ©tico manteniendo solo las especies que estÃ¡n en la matriz de datos del mapa de calor\nclass_tree_w_g9 &lt;- keep.tip(class_tree, tip = rownames(phylo_heatmap_mat))\n\n## Ajuste de colores para el mapa de calor filogenÃ©tico para datos sesgados\nsmall_value &lt;- unique(sort(unlist(phylo_heatmap_mat)))[2]  # Encuentra el segundo valor mÃ¡s pequeÃ±o en la matriz de datos para establecer un umbral\nsmall_value &lt;- small_value - small_value %% 0.001  # Redondea el valor a 3 decimales para crear un valor pequeÃ±o ajustado\n\n# Definir los puntos de corte para el mapa de calor segÃºn la distribuciÃ³n de los datos\nheatmap_breaks &lt;- c(0, small_value, 1, 2, 3, 4, seq(5, 55, 10))\n\n# Definir una paleta de colores basada en viridis, con un sesgo hacia valores mÃ¡s bajos\nplot_colors &lt;- c(\"white\", colorRampPalette((viridis(10)), bias = 5)(length(heatmap_breaks) - 2))\n\n# Crear una matriz de significancia (signP) para etiquetar el mapa de calor\nsig_mat &lt;- plot_table_w_g9 %&gt;% \n  select(class, variable, signP)  # Selecciona las columnas relevantes de los datos\n\n# Filtra las filas que contienen \"NA\" en la columna \"class\" y transforma los datos a formato ancho\nsig_mat &lt;- sig_mat %&gt;% \n  filter(!grepl(\"NA \", class)) %&gt;%\n  spread(variable, signP) %&gt;%  # Transforma los datos para que las variables sean columnas\n  column_to_rownames(var = \"class\")  # Establece la columna \"class\" como nombres de fila\n\n# Alinea la matriz de significancia con el Ã¡rbol filogenÃ©tico\nsig_mat &lt;- sig_mat[class_tree_w_g9$tip.label, colnames(phylo_heatmap_mat)]"
  },
  {
    "objectID": "Figura3.html#figura-3b.-mapa-de-colores",
    "href": "Figura3.html#figura-3b.-mapa-de-colores",
    "title": "Figura 3",
    "section": "Figura 3B. Mapa de colores",
    "text": "Figura 3B. Mapa de colores\n\n# 1. Extraer coordenadas del heatmap filogenÃ©tico para aÃ±adir anotaciones manuales posteriormente\nxx_yy &lt;- phylo.heatmap.coords(\n  class_tree_w_g9,           # Ã¡rbol filogenÃ©tico de clases\n  phylo_heatmap_mat,         # matriz de abundancias promedio por clase y MGE\n  fsize = c(0.8, 0.9, 0.7),  # tamaÃ±os de fuente (Ã¡rbol, heatmap, leyenda)\n  colors = plot_colors,      # colores personalizados para el heatmap\n  grid = TRUE,               # mostrar rejilla en el heatmap\n  split = c(0.7, 0.3),       # proporciÃ³n de espacio entre Ã¡rbol y heatmap\n  lwd = 1,                   # grosor de lÃ­neas\n  breaks = heatmap_breaks,   # puntos de corte para los colores\n  mar = c(1.2,1.2,1.2,1.2)   # mÃ¡rgenes\n)\n\n## 2. Generar el heatmap con leyenda incluida, usando los mismos parÃ¡metros que el paso anterior\nphylo.heatmap.legendmod(\n  class_tree_w_g9,\n  phylo_heatmap_mat,\n  fsize = c(0.8, 0.9, 0.7),\n  colors = plot_colors,\n  grid = TRUE,\n  split = c(0.7, 0.3),\n  lwd = 1,\n  breaks = heatmap_breaks,\n  mar = c(1.2,1.2,1.2,1.2)\n)\n\n## 3. AÃ±adir sÃ­mbolos de significancia (\"*\") en cada celda de la matriz que lo indique (en 'sig_mat')\nfor(i in 1:nrow(sig_mat)) {\n  for(j in 1:ncol(sig_mat)) {\n    if(sig_mat[i,j] == \"*\") {\n      rnm &lt;- rownames(sig_mat)[i]  # nombre de la fila (clase taxonÃ³mica)\n      cnm &lt;- colnames(sig_mat)[j]  # nombre de la columna (MGE)\n      \n      # AÃ±adir el sÃ­mbolo \"*\" en la posiciÃ³n correspondiente del heatmap\n      points(\n        xx_yy$xx[j], xx_yy$yy[i],   # coordenadas x, y para esa celda\n        cex = 1.5,                  # tamaÃ±o del sÃ­mbolo\n        col = if (phylo_heatmap_mat[rnm, cnm] &lt; heatmap_breaks[3]) \"white\" else \"black\", \n        pch = \"*\"                   # sÃ­mbolo a dibujar\n      )\n    }\n  }\n}"
  },
  {
    "objectID": "Figura3.html#figura-3a-filogenia",
    "href": "Figura3.html#figura-3a-filogenia",
    "title": "Figura 3",
    "section": "Figura 3A: Filogenia",
    "text": "Figura 3A: Filogenia\nObtener el numero de genomas por Class:\n\ngenomes_per_class &lt;- db_genome %&gt;%\n  distinct(genomeID, class) %&gt;%  # eliminar duplicados por genomeID y class\n  group_by(class) %&gt;%\n  summarise(n_genomes = n()) %&gt;%\n  arrange(desc(n_genomes))\n\ngenomes_per_class\n\n# A tibble: 60 Ã— 2\n   class                 n_genomes\n   &lt;chr&gt;                     &lt;int&gt;\n 1 Gammaproteobacteria       27249\n 2 Bacilli                   25644\n 3 Actinobacteria             9859\n 4 Betaproteobacteria         3998\n 5 Epsilonproteobacteria      2693\n 6 Alphaproteobacteria        2001\n 7 Clostridia                 1621\n 8 Bacteroidia                 570\n 9 Spirochaetia                501\n10 Flavobacteriia              375\n# â„¹ 50 more rows\n\n\nModificar los nombres en el Ã¡rbol:\n\n# -------------- Modificaciones de las etiquetas de las especies (numero de geneomas) -------------\n\nspecies_labels &lt;- class_tree_w_g9$tip.label\n# Crear nombres con el nÃºmero de genomas\nnew_labels &lt;- paste0(genomes_per_class$class, \" (\", genomes_per_class$n_genomes, \")\")\n\n# Cambiar nombres en el Ã¡rbol\nmatch_idx &lt;- match(class_tree_w_g9$tip.label, genomes_per_class$class)\n\n# AsegÃºrate que no hay NA antes de continuar\nclass_tree_w_g9$tip.label &lt;- ifelse(\n  !is.na(match_idx),\n  new_labels[match_idx],\n  class_tree_w_g9$tip.label\n)\n\n# -------------- Obtener el nodo mÃ¡s reciente comÃºn (MRCA) para cada grupo -------------------------\n\n# &gt; Obtener el numero del nodo Archaea\nnode_archaea &lt;- getMRCA(class_tree_w_g9, c(\"Halobacteria (95)\", \"Methanomicrobia (89)\"))\n\n# &gt; Obtener el numero del nodo Bacterias\n# Obtener todos los nodos\nall_classes &lt;- class_tree_w_g9$tip.label\n\n# 2. Excluir los que no quieres\nexcluded &lt;- c(\"Halobacteria (95)\", \"Methanomicrobia (89)\")\nincluded_classes &lt;- setdiff(all_classes, excluded)\n\n# 3. Obtener el nodo comÃºn para los restantes\nnode_bacteria &lt;- getMRCA(class_tree_w_g9, included_classes)\n\nExtraer coordenadas del heatmap filogenÃ©tico para aÃ±adir anotaciones manuales posteriormente:\n\n# Guardar la figura como archivo temporal\ntmp_file &lt;- tempfile(fileext = \".png\")\n\n# Crear la imagen del Ã¡rbol + heatmap\npng(tmp_file, width = 1000, height = 1500, res = 150)  \n\n# Filogenia\nxx_yy &lt;- phylo.heatmap.coords(\n  class_tree_w_g9,\n  phylo_heatmap_mat,\n  fsize = c(0.8, 0.9, 0.7),\n  colors = plot_colors,\n  grid = TRUE,\n  split = c(0.7, 0.3),\n  lwd = 1,\n  breaks = heatmap_breaks,\n  mar = c(1.2,1.2,1.2,1.2)\n)\n# Agregar titulos de los nodos\nnodelabels(\"Bacteria\", node = node_bacteria, frame = \"none\", adj = c(1.1, -0.1), font = 2, cex = 1)\nnodelabels(\"Archaea\", node = node_archaea, frame = \"none\", adj = c(1.1, -0.1), font = 2, cex = 1)\n\ndev.off()\n\npng \n  2 \n\n# Leer imagen y convertirla en un objeto ggdraw\np_phylo_heatmap &lt;- ggdraw() + draw_image(tmp_file)\np_phylo_heatmap"
  },
  {
    "objectID": "Figura3.html#figura-3a-barplot-de-abundancia-relativa-de-mges-por-clase-taxonÃ³mica",
    "href": "Figura3.html#figura-3a-barplot-de-abundancia-relativa-de-mges-por-clase-taxonÃ³mica",
    "title": "Figura 3",
    "section": "Figura 3A Barplot de abundancia relativa de MGEs por clase taxonÃ³mica",
    "text": "Figura 3A Barplot de abundancia relativa de MGEs por clase taxonÃ³mica\n\n# 1. Seleccionar clases que aparecen al menos 10 veces para asegurar una representaciÃ³n confiable.\nallclass_all &lt;- all_avg_cnt_tax_class %&gt;%\n  # Usar una sola MGE como referencia para el conteo por clase\n  filter(mge == all_avg_cnt_tax_class$mge[1]) %&gt;%          \n  group_by(class) %&gt;%\n  summarise(cntclass = n()) %&gt;%\n  # Incluir solo clases con al menos 10 ocurrencias\n  filter(cntclass &gt; 9)                                     \n\n# 2. Filtrar datos: eliminar MGEs de tipo \"Cellular\" o \"Hotspot\" y mantener solo las clases seleccionadas previamente.\nall_avg_cnt_tax_class_sel_all &lt;- all_avg_cnt_tax_class %&gt;%\n  filter(!grepl(\"Cellular\", mge)) %&gt;%\n  filter(!grepl(\"Hotspot\", mge)) %&gt;%\n  filter(class %in% allclass_all$class) %&gt;%\n  group_by(mge, class) %&gt;%\n  # Promediar por combinaciÃ³n de clase y MGE\n  summarise(avg_class = mean(avg_cnt), .groups = \"drop\")   \n\n# 3. Calcular la suma total de abundancia de MGEs por clase (para obtener proporciones despuÃ©s)\nall_avg_cnt_tax_class_sel_all_mge_all &lt;- all_avg_cnt_tax_class_sel_all %&gt;%\n  group_by(class) %&gt;%\n  summarise(total_mge = sum(avg_class), .groups = \"drop\")\n\n# 4. Combinar abundancia promedio por clase y MGE con el total por clase\n#    Calcular la fracciÃ³n relativa de cada MGE dentro de cada clase\nall_avg_cnt_tax_class_sel_4bar_all &lt;- left_join(\n  all_avg_cnt_tax_class_sel_all,\n  all_avg_cnt_tax_class_sel_all_mge_all,\n  by = \"class\"\n) %&gt;%\n  group_by(class, mge, total_mge) %&gt;%\n  summarise(frac = avg_class / total_mge, .groups = \"drop\")\n\n# 5. Limpiar datos y ordenar clases segÃºn el orden filogenÃ©tico del Ã¡rbol\nbarplot_mat &lt;- all_avg_cnt_tax_class_sel_4bar_all %&gt;%\n  # Eliminar clases no identificadas\n  filter(!grepl(\"NA \", class))  \n\n# Mantener orden del Ã¡rbol filogenÃ©tico\nbarplot_mat$class &lt;- factor(barplot_mat$class,\n                            levels = species_labels)  \n\n# 6. Preparar datos auxiliares para anotaciones en el barplot (por ejemplo, totales por clase)\nbarplot_mat_for_n &lt;- all_avg_cnt_tax_class_sel_all_mge_all %&gt;%\n  filter(!grepl(\"NA \", class))\nbarplot_mat_for_n$class &lt;- factor(barplot_mat_for_n$class,\n                                  levels = species_labels)\n\nCrear barplot apilado (horizontal) de la proporciÃ³n relativa de MGEs por clase taxonÃ³mica\n\n# Define el orden deseado de las categorÃ­as en la leyenda (de MI a IS_Tn)\ncategory_order &lt;- c(\"MI\", \"Integron\", \"CE\", \"Phage_like\", \"Phage\", \"IS_Tn\")\n\n# Generar la grafica base\nbarplot_specI_class_count_all &lt;- ggplot(barplot_mat, aes(y = class, x = frac, fill = mge)) +  \n   # Barras horizontales, borde gris\n  geom_bar(stat = \"identity\", color = \"grey60\") +                         \n  # Colores personalizados para los MGEs\n  scale_fill_manual(\"MGE\", values = colc)                                   \n\n## AÃ±adir detalles estÃ©ticos y anotaciones\nFig3A_barplot &lt;- barplot_specI_class_count_all +\n  # LÃ­mite extendido para espacio de anotaciones\n  scale_x_continuous(\n    breaks = c(0, 0.25, 0.5, 0.75, 1.0),\n    limits = c(0, 1.1)                                                     \n  ) +\n  geom_text(\n    data = barplot_mat_for_n,\n    # Mostrar suma total de MGEs por clase\n    mapping = aes(y = class, x = 1.05, label = paste(\"\", round(total_mge))), \n    inherit.aes = FALSE,\n    col = \"black\",\n    size = 6) +\n  # Agregar un tÃ­tulo en una posiciÃ³n personalizada\n  annotate(\"text\", x = 1.05, y = 23.5, label = \"Avg. MGE\", size = 6, fontface = \"bold\", color = \"black\") +\n  # etiquetas\n  labs(title = \"Relative proportion\",y = \"\",  x = \"\") +\n   # EstÃ©tica limpia estilo Cowplot\n  theme_cowplot(font_size = 20) + \n  # Etiquetas del eje X horizontales\n  theme(\n    axis.text.y = element_blank(), #  axis.text.y = element_text(hjust = 0, vjust = 0.5) # Alinear texto del eje Y\n    axis.text.x = element_text(angle = 0),   \n    legend.position = \"bottom\",       # Leyenda abajo \n    legend.direction = \"horizontal\",  # DisposiciÃ³n horizontal de la leyenda\n    plot.title = element_text(hjust = 0.5, size = 24)  # Centrar y estilizar el tÃ­tulo\n    ) +  \n  # Asegura que las categorÃ­as estÃ©n en una sola fila\n guides(fill = guide_legend(ncol = length(category_order)))  \n\nFig3A_barplot\n\n\n\n\n\nUnir figura\n\nFig3A_final_plot &lt;- plot_grid(p_phylo_heatmap, Fig3A_barplot, ncol = 2, align = \"v\", rel_widths = c(1.5, 1))\nFig3A_final_plot\n\n\n\n\nPuedes encontrar el script completo en Figura3_modificado.R."
  },
  {
    "objectID": "Figura4.html",
    "href": "Figura4.html",
    "title": "Figura 4",
    "section": "",
    "text": "Figura 4. Transferencia horizontal de genes mediada por MGEs (HGT)\n\n\n\nLa ocurrencia de eventos recientes de HGT mediada por MGEs disminuye considerablemente con la distancia taxonÃ³mica.\nResumen de los eventos de HGT mediada por MGEs a travÃ©s de un Ã¡rbol filogenÃ©tico (basado en genes marcadores filogenÃ©ticos) de clases taxonÃ³micas. El mapa de calor cuantifica los eventos de HGT (coloreados segÃºn la leyenda en la parte inferior) entre las clases taxonÃ³micas y los arcos indican la contribuciÃ³n de los elementos transponibles (en rojo) sobre otras categorÃ­as de MGEs (en gris).\nAnÃ¡lisis de anidamiento de integrones con diferentes categorÃ­as de MGEs muestra su anidamiento significativo con CE-Elementos conjugativos (razÃ³n de probabilidades de Fisher 4.3, valor P = 2.9eâˆ’86) en el subconjunto de HGT en comparaciÃ³n con todas las ocurrencias anidadas.\nMapas de calor que ilustran la transferencia horizontal promiscuosa de elementos transponibles a travÃ©s de hÃ¡bitats en comparaciÃ³n con otras categorÃ­as de MGEs. Todas las categorÃ­as de MGEs muestran una alta dinÃ¡mica de MGE\n\n\nlibrary(tidyverse)\nlibrary(cowplot)\nlibrary(reshape)\nlibrary(RColorBrewer)\nlibrary(phytools) \nlibrary(viridis)"
  },
  {
    "objectID": "Figura4.html#transferencia-horizontal-de-genes-mediado-por-mges-hgt",
    "href": "Figura4.html#transferencia-horizontal-de-genes-mediado-por-mges-hgt",
    "title": "Figura 4",
    "section": "",
    "text": "Figura 4. Transferencia horizontal de genes mediada por MGEs (HGT)\n\n\n\nLa ocurrencia de eventos recientes de HGT mediada por MGEs disminuye considerablemente con la distancia taxonÃ³mica.\nResumen de los eventos de HGT mediada por MGEs a travÃ©s de un Ã¡rbol filogenÃ©tico (basado en genes marcadores filogenÃ©ticos) de clases taxonÃ³micas. El mapa de calor cuantifica los eventos de HGT (coloreados segÃºn la leyenda en la parte inferior) entre las clases taxonÃ³micas y los arcos indican la contribuciÃ³n de los elementos transponibles (en rojo) sobre otras categorÃ­as de MGEs (en gris).\nAnÃ¡lisis de anidamiento de integrones con diferentes categorÃ­as de MGEs muestra su anidamiento significativo con CE-Elementos conjugativos (razÃ³n de probabilidades de Fisher 4.3, valor P = 2.9eâˆ’86) en el subconjunto de HGT en comparaciÃ³n con todas las ocurrencias anidadas.\nMapas de calor que ilustran la transferencia horizontal promiscuosa de elementos transponibles a travÃ©s de hÃ¡bitats en comparaciÃ³n con otras categorÃ­as de MGEs. Todas las categorÃ­as de MGEs muestran una alta dinÃ¡mica de MGE\n\n\nlibrary(tidyverse)\nlibrary(cowplot)\nlibrary(reshape)\nlibrary(RColorBrewer)\nlibrary(phytools) \nlibrary(viridis)"
  },
  {
    "objectID": "Figura4.html#paso-1-importar-datos",
    "href": "Figura4.html#paso-1-importar-datos",
    "title": "Figura 4",
    "section": "PASO 1: Importar datos",
    "text": "PASO 1: Importar datos\n\ndata_mf &lt;- read_tsv(\"data/raw_data/recombinase_hgt_cluster_master_file.txt.gz\", col_names = F)\nmge_bins &lt;- read_tsv(\"data/raw_data/mge_bins_final.txt.gz\",col_names = T)\ntax &lt;- read_tsv(\"data/raw_data/hgt_species.list.gz\", col_names = F)\nclass_tree &lt;- read.tree(\"data/raw_data/progenomes2_class_tree.nwk\")\nglist &lt;- read_tsv(\"data/raw_data/genome_status_supplementary_tableS2.txt.gz\", col_names = T)\n# datos anotados sobre elementos genÃ©ticos mÃ³viles (MGE)\ndat_mge &lt;- read_tsv(\"data/processed_data/resolved_MGE_hgt_top_tax_final.txt.gz\", col_names = F)\n# recombinasas asociadas a distintos tipos de MGE\ndata_mge_class &lt;- read_tsv(\"data/processed_data/resolved_MGE_hgt_class_level_final.txt.gz\", col_names = F)\n# Datos para la Figura 4C\ndatacl &lt;- read_tsv(\"data/raw_data/all_recombinase_clusters_mge_resolved.txt.gz\", col_names = F)\n\nCargar paleta de colores\n\n# Paleta general de colores\ncolc &lt;- c(\"#D55E00\", \"#E69F00\", \"#F0E442\", \"#56B4E9\", \"#009E73\", \"#0072B2\",\"#CECCCC\")\nnames(colc) &lt;- c(\"IS_Tn\", \"Phage\", \"Phage_like\", \"CE\", \"Integron\", \"MI\", \"Cellular\") \n\nPreparaciÃ³n de variables para exportar datasets de conexiones (arcos) a iTOL\n\nmges &lt;- c(\"IS_Tn\", \"Phage\", \"Phage_like\", \"CE\", \"Integron\", \"MI\")\ncolc_grey &lt;- c(\"#D55E00\", \"#808080\", \"#808080\", \"#808080\", \"#808080\", \"#808080\")\nnames(colc_grey) &lt;- c(\"IS_Tn\", \"Phage\", \"Phage_like\", \"CE\", \"Integron\", \"MI\")\n\nCargar funciones\n\nsource(\"scripts/phylo_heatmap_function.R\")"
  },
  {
    "objectID": "Figura4.html#paso-2-seleccion-de-genomas-de-alta-calidad",
    "href": "Figura4.html#paso-2-seleccion-de-genomas-de-alta-calidad",
    "title": "Figura 4",
    "section": "PASO 2: Seleccion de genomas de alta calidad",
    "text": "PASO 2: Seleccion de genomas de alta calidad\n\n# Obtener los genomas con la mas alta calidad\nglist_high &lt;- glist %&gt;% \n  filter(genome_quality == \"high\")\n\n# Cambio de formato y limpieza de datos\nmge_bins_melted &lt;- mge_bins %&gt;% \n  select(1:6,9,10) %&gt;% \n  # Reestructuramos el dataframe de formato ancho a largo\n  gather(\"mge\",\"count\",1:7) %&gt;% # Convertimos las columnas 1 a 7 en dos columnas: 'mge' (nombre original de la columna) y 'count' (su valor)\n  filter(count &gt; 0) %&gt;% \n  mutate(island1 = island) %&gt;% \n  separate(island1, c(\"g1\",\"g2\",\"g3\")) %&gt;% # Separamos 'island1' en tres componentes\n  # Unimos las dos primeras partes para crear un identificador Ãºnico de genoma (e.g., \"gen1.gen2\")\n  mutate(genome = paste(g1, g2, sep = \".\")) %&gt;%  \n   # Eliminamos las columnas auxiliares g1, g2 y g3\n  select(-g1,-g2,-g3) %&gt;% \n  # Filtramos solo los genomas que estÃ¡n presentes en la lista `glist_high$genome`\n  filter(genome %in% glist_high$genome) %&gt;% \n  select(-genome)\n\nGuardar datos\n\nwrite.table(mge_bins_melted,file = \"data/processed_data/mge_bins_final_collapsed.txt\", sep = \"\\t\", row.names = F, col.names = T, quote = F)"
  },
  {
    "objectID": "Figura4.html#paso-3-manipulaciÃ³n-y-limpieza-de-los-datos",
    "href": "Figura4.html#paso-3-manipulaciÃ³n-y-limpieza-de-los-datos",
    "title": "Figura 4",
    "section": "PASO 3: ManipulaciÃ³n y Limpieza de los datos",
    "text": "PASO 3: ManipulaciÃ³n y Limpieza de los datos\n\n# Renombramos las columnas de `data_mf` con nombres significativos\ndata_mf_rename &lt;- data_mf %&gt;% \n  dplyr::rename(rec_cluster = X1, prot = X2, specI = X3, kingdom = X4, phylum = X5, class = X6, order = X7, family = X8, genus = X9) \n\n# Renombramos las columnas de `tax` para que tengan nombres descriptivos.\n# Luego seleccionamos solo la columna 'genome' y filtramos los que estÃ¡n presentes en `glist_high`.\ntax &lt;- tax %&gt;% \n  dplyr::rename(specI = X1, genome = X2, kingdom = X3, phylum = X4, class = X5, family = X6) %&gt;% \n  select(genome) %&gt;% \n  filter(genome %in% glist_high$genome) \n\n# Renombramos las columnas para hacerlas mÃ¡s interpretables\ndata_mge_class_rename &lt;- data_mge_class %&gt;% \n  dplyr::rename(cor_mge = X1, island = X2, mge = X3, rec = X4, rec_cluster = X5, family = X6, class = X7, prot = X8)"
  },
  {
    "objectID": "Figura4.html#paso-4-asignar-informaciÃ³n-taxonÃ³mica-y-filtrar-genomas-de-interÃ©s",
    "href": "Figura4.html#paso-4-asignar-informaciÃ³n-taxonÃ³mica-y-filtrar-genomas-de-interÃ©s",
    "title": "Figura 4",
    "section": "PASO 4: Asignar informaciÃ³n taxonÃ³mica y filtrar genomas de interÃ©s",
    "text": "PASO 4: Asignar informaciÃ³n taxonÃ³mica y filtrar genomas de interÃ©s\n\n# Extraemos el ID del genoma a partir del identificador de proteÃ­na\n# (se asume que 'prot' tiene formato como \"X.Y.Z\" donde X.Y es el ID de genoma)\ndatar_phy &lt;- data_mf_rename %&gt;% \n  mutate(prot1 = prot) %&gt;%\n  separate(prot1, c(\"one\",\"two\",\"three\"), sep = \"\\\\.\", extra = \"merge\") %&gt;% \n  unite(.,genome, c(\"one\",\"two\"), sep = \".\") %&gt;% \n  select(-three) %&gt;% \n  filter(genome %in% glist_high$genome) \n\n## Unimos informaciÃ³n taxonÃ³mica con los datos de proteÃ­nas ##\ndatar &lt;- left_join(tax,datar_phy, by = \"genome\") %&gt;% \n  drop_na()  # eliminamos filas con valores NA despuÃ©s del join"
  },
  {
    "objectID": "Figura4.html#paso-5-identificar-hgt-a-cada-nivel-taxonÃ³mico",
    "href": "Figura4.html#paso-5-identificar-hgt-a-cada-nivel-taxonÃ³mico",
    "title": "Figura 4",
    "section": "PASO 5: Identificar HGT a cada nivel taxonÃ³mico",
    "text": "PASO 5: Identificar HGT a cada nivel taxonÃ³mico\nFiltramos los clusters de recombinaciÃ³n (rec_cluster) que contienen mÃ¡s de una entrada, y que tienen variaciÃ³n en el nivel taxonÃ³mico â€œfamilyâ€.\nEsto sugiere la presencia de transferencia horizontal entre diferentes familias.\n\ndatar_melt &lt;- datar %&gt;% \n  select(-genus) %&gt;%         # Eliminamos columna de genus (no se usa aquÃ­)\n  group_by(rec_cluster) %&gt;%  # Agrupamos por cluster de recombinaciÃ³n\n  filter(n() &gt; 1) %&gt;%        # Nos quedamos solo con clusters que tienen mÃ¡s de una entrada\n  filter_at(vars(family), any_vars(length(unique(.)) &gt; 1)) %&gt;% # Que haya al menos dos familias distintas\n  ungroup() \n\n# Contamos el nÃºmero de taxones distintos por nivel (kingdom a family) por cada cluster\ndatar_tax &lt;- datar_melt %&gt;% \n  group_by(rec_cluster) %&gt;% \n  summarise_at(vars(kingdom:family), n_distinct) # Cuenta cuÃ¡ntos taxones distintos hay en cada nivel\n\n# Preparamos un resumen del nivel taxonÃ³mico mÃ¡s alto en el que ocurre variaciÃ³n\ndatar_top &lt;- datar_tax %&gt;% \n  mutate_at(vars(kingdom:family), ~ . - 1) %&gt;%  # Restamos 1 (para que 0 indique sin variaciÃ³n)\n  mutate(cumul = rowSums(.[2:6])) %&gt;%           # Suma total de variaciÃ³n en niveles taxonÃ³micos\n  pivot_longer(kingdom:family, names_to = \"key\", values_to = \"value\") %&gt;% # Reorganiza a formato largo\n  group_by(rec_cluster) %&gt;% \n  mutate(top_tax = key[which(value &gt; 0)[1]]) %&gt;% # Identifica el primer nivel donde hay variaciÃ³n\n  ungroup() %&gt;% \n  pivot_wider(names_from = key, values_from = value) # Regresa a formato ancho\n\n# Combinamos con informaciÃ³n de proteÃ­nas para cada cluster\nsub_datar &lt;- datar %&gt;% select(rec_cluster,prot)\ncombine_mge &lt;- left_join(datar_top,sub_datar, by = \"rec_cluster\")\n\nGuardar datos\n\nwrite.table(combine_mge,file= \"data/processed_data/pre_MGE_top_tax_file_final.txt\", sep = \"\\t\", quote = F, col.names = T, row.names = F)"
  },
  {
    "objectID": "Figura4.html#paso-6-estratificaciÃ³n-basada-en-mges-de-los-clusters-de-recombinasas",
    "href": "Figura4.html#paso-6-estratificaciÃ³n-basada-en-mges-de-los-clusters-de-recombinasas",
    "title": "Figura 4",
    "section": "PASO 6: EstratificaciÃ³n basada en MGEs de los clusters de recombinasas",
    "text": "PASO 6: EstratificaciÃ³n basada en MGEs de los clusters de recombinasas\nLimpiamos y formateamos el archivo: - Quitamos el encabezado repetido - Renombramos columnas para claridad - Extraemos el nombre del genoma a partir del identificador de proteÃ­na - Filtramos los genomas de interÃ©s y descartamos islas no definidas\n\ndat_mge_f &lt;- dat_mge %&gt;% \n  filter(!X5 == \"rec_cluster\") %&gt;% \n  dplyr::rename(MGE = X1, ISLAND = X2, MGE_ND = X3, rec = X4, rec_cluster = X5, cumul = X6, top_tax = X7,   kingdom = X8,   phylum = X9, class = X10,   order = X11, family = X12, prot = X13) %&gt;% \n  mutate(prot1 = prot) %&gt;%\n  separate(prot1, c(\"one\",\"two\",\"three\"), sep = \"\\\\.\", extra = \"merge\") %&gt;% \n  unite(.,genome, c(\"one\",\"two\"), sep = \".\") %&gt;% \n  select(-three) %&gt;% \n  filter(genome %in% glist_high$genome) %&gt;% \n  filter(ISLAND != \"ISLAND_ND\") # Excluye islas no definidas\n\nPreparamos una versiÃ³n mÃ¡s restringida del conjunto de datos, conservando solo genomas que estÃ¡n tambiÃ©n en datar.\n\ndat_mge_pref &lt;- dat_mge_f %&gt;%\n  mutate(prot1 = prot) %&gt;%\n  separate(prot1, c(\"one\",\"two\",\"three\"), sep = \"\\\\.\", extra = \"merge\") %&gt;% \n  unite(.,genome, c(\"one\",\"two\"), sep = \".\") %&gt;% \n  select(-three) %&gt;%\n  filter(genome %in% datar$genome)\n\n# Quitamos las columnas taxonÃ³micas redundantes para fusionar luego con datos actualizados\ndat_mge_f1 &lt;- dat_mge_pref %&gt;% select(-kingdom,-phylum,-class,-order,-family)\n\n# Fusionamos los datos de MGE con la anotaciÃ³n taxonÃ³mica por proteÃ­na y cluster\n# Luego, reorganizamos los datos en formato largo para obtener el valor en el nivel taxonÃ³mico mÃ¡s informativo\ndat_with_tax &lt;- left_join(dat_mge_f1,datar, by = c(\"rec_cluster\",\"prot\")) %&gt;%\n  select(MGE, rec_cluster, top_tax,prot, kingdom:family) %&gt;%\n  reshape2::melt(id = c(\"MGE\", \"rec_cluster\", \"top_tax\",\"prot\")) %&gt;%\n  # Filtramos solo el nivel taxonÃ³mico que fue identificado como el mÃ¡s informativo\n  filter(variable == top_tax)"
  },
  {
    "objectID": "Figura4.html#paso-7-generaciÃ³n-de-datos-para-las-figuras-4c-y-5",
    "href": "Figura4.html#paso-7-generaciÃ³n-de-datos-para-las-figuras-4c-y-5",
    "title": "Figura 4",
    "section": "PASO 7: GeneraciÃ³n de datos para las figuras 4C y 5",
    "text": "PASO 7: GeneraciÃ³n de datos para las figuras 4C y 5\n\n# Fusionamos datos de recombinasas y MGEs con anotaciÃ³n taxonÃ³mica\n# Luego transformamos a formato largo, conservando solo el nivel taxonÃ³mico mÃ¡s informativo\ndat_with_tax2n &lt;- left_join(dat_mge_f1,datar, by = c(\"rec_cluster\",\"prot\")) %&gt;%\n  select(MGE, MGE_ND, ISLAND, rec_cluster, top_tax,prot, kingdom:family) %&gt;%\n  reshape2::melt(id = c(\"MGE\", \"MGE_ND\",\"rec_cluster\", \"ISLAND\", \"top_tax\",\"prot\")) %&gt;%\n  filter(variable == top_tax) #  Solo nos quedamos con la categorÃ­a taxonÃ³mica mÃ¡s relevante\n\n# Preparamos subconjunto con informaciÃ³n de familia para cada recombinasa\ntemp_datar &lt;- datar %&gt;% select(rec_cluster,prot,family)\n# AÃ±adimos la informaciÃ³n de familia a los datos largos con MGEs\ntemp_data_with_tax2n &lt;- left_join(dat_with_tax2n,temp_datar, by = c(\"rec_cluster\",\"prot\")) \n\n# Filtramos clusters de recombinasas asociadas a MGEs mÃ³viles (excluyendo \"Cellular\" y \"nested\")\n# Luego, identificamos clusters que presentan diversidad en el nivel taxonÃ³mico relevante\ndat_with_tax3_testn &lt;- temp_data_with_tax2n %&gt;%\n  filter(MGE != \"Cellular\" & MGE != \"nested\") %&gt;%              # Nos centramos en MGEs no celulares\n  group_by(rec_cluster, MGE) %&gt;%                               # Agrupamos por cluster y tipo de MGE\n  mutate(val = n_distinct(value) &gt; 1) %&gt;%                      # Evaluamos si hay mÃ¡s de un taxÃ³n distinto\n  filter(val == \"TRUE\") %&gt;%                                    # Conservamos solo aquellos con diversidad taxonÃ³mica\n  ungroup()\n\nGuardar datos.\n\n# Guardar datos\nwrite.table(dat_with_tax3_testn,file=\"processed_data/all_hgt_data_family_expanded_redundant_final.txt\", sep = \"\\t\", col.names = T, row.names = F, quote = F)"
  },
  {
    "objectID": "Figura4.html#paso-8-preparaciÃ³n-de-datos-para-cuantificar-hgt-segÃºn-el-tipo-de-mge-y-el-nivel-taxonÃ³mico-afectado",
    "href": "Figura4.html#paso-8-preparaciÃ³n-de-datos-para-cuantificar-hgt-segÃºn-el-tipo-de-mge-y-el-nivel-taxonÃ³mico-afectado",
    "title": "Figura 4",
    "section": "PASO 8: PreparaciÃ³n de datos para cuantificar HGT segÃºn el tipo de MGE y el nivel taxonÃ³mico afectado",
    "text": "PASO 8: PreparaciÃ³n de datos para cuantificar HGT segÃºn el tipo de MGE y el nivel taxonÃ³mico afectado\n\n# Extraemos informaciÃ³n relevante (cluster, proteÃ­na, familia) desde los datos anotados\ntemp_datar &lt;- datar %&gt;% select(rec_cluster,prot,family)\n# Unimos esta informaciÃ³n a los datos previos con anotaciÃ³n taxonÃ³mica\ntemp_data_with_tax &lt;- left_join(dat_with_tax,temp_datar, by = c(\"rec_cluster\",\"prot\")) \n\n# Filtramos MGEs mÃ³viles (excluyendo los de origen celular o sin clasificar),\n# luego identificamos recombinasas que estÃ¡n distribuidas en mÃ¡s de un taxÃ³n distinto\ndat_with_tax_mge &lt;- temp_data_with_tax %&gt;%\n  filter(MGE != \"Cellular\" & MGE != \"nested\") %&gt;%        # Solo MGEs mÃ³viles\n  group_by(rec_cluster, MGE) %&gt;%                         # Agrupamos por cluster y tipo de MGE\n  mutate(val = n_distinct(value) &gt; 1) %&gt;%                # Evaluamos si hay diversidad taxonÃ³mica\n  filter(val == \"TRUE\") %&gt;%                              # Conservamos solo los casos con diversidad\n  summarise(top_tax_new = unique(top_tax)) %&gt;%           # Extraemos el nivel taxonÃ³mico mÃ¡s informativo\n  ungroup() %&gt;%\n  group_by(MGE, top_tax_new) %&gt;%                         # Agrupamos por tipo de MGE y nivel taxonÃ³mico\n  summarise(final = n()) %&gt;%                             # Contamos nÃºmero de clusters con diversidad\n  mutate(tot = sum(final)) %&gt;%                           # Calculamos total por MGE\n  ungroup()\n\n## Ajuste manual: Forzamos a que haya al menos 3 eventos a nivel de reino (kingdom)\n## para reflejar transferencias entre arqueas y bacterias aunque sean pocas pero significativas\ndat_with_tax_mge &lt;- dat_with_tax_mge %&gt;%\n  mutate(final = if_else(top_tax_new == \"kingdom\",3,as.numeric(final))) \n\n# Ordenamos niveles de factores para visualizaciÃ³n ordenada\ndat_with_tax_mge$top_tax_new &lt;- factor(dat_with_tax_mge$top_tax_new, levels = rev(c(\"kingdom\",\"phylum\",\"class\",\"order\",\"family\")))\ndat_with_tax_mge$MGE &lt;- factor(dat_with_tax_mge$MGE,levels = c(\"IS_Tn\",\"CE\",\"MI\",\"Phage\",\"Phage_like\",\"Integron\"))\n\n\nFigure 4A - HGT line plot\nGeneramos un grÃ¡fico de lÃ­nea con puntos para visualizar los eventos de HGT por nivel taxonÃ³mico (kingdom, phylum, etc.) estratificados por tipo de MGE.\n\nmge_tax_log &lt;- ggplot(dat_with_tax_mge, aes(x = top_tax_new, y = final, color = MGE)) + \n  geom_point(aes(group = MGE), size = 3) +   # Puntos grandes para cada tipo de MGE\n  geom_line(aes(group = MGE), size = 1) +    # Conectamos puntos con lÃ­neas para cada tipo de MGE\n  scale_colour_manual(values = colc) +       # Usamos una paleta de colores personalizada\n  scale_y_log10()                            # Escala logarÃ­tmica para visualizar mejor las diferencias\n\n# Personalizamos el grÃ¡fico con un tema limpio y rotaciÃ³n de etiquetas\nmge_tax_log + \n  theme_cowplot(font_size = 15) +            # Estilo claro y moderno\n  theme(legend.position = \"bottom\",\n    axis.text.x = element_text(angle = 90,hjust = 1,vjust = 0.5)) + # Rotamos etiquetas del eje X\n  labs(y = \"#HGT events\", x = \"\")            # Etiquetas de los ejes"
  },
  {
    "objectID": "Figura4.html#paso-9-generaciÃ³n-de-datos-para-las-figuras-4b",
    "href": "Figura4.html#paso-9-generaciÃ³n-de-datos-para-las-figuras-4b",
    "title": "Figura 4",
    "section": "PASO 9: GeneraciÃ³n de datos para las figuras 4B",
    "text": "PASO 9: GeneraciÃ³n de datos para las figuras 4B\n\n# Preprocesamiento de la tabla con informaciÃ³n de clases taxonÃ³micas y MGEs\ndata_mge_class_phy &lt;- data_mge_class_rename %&gt;% \n  mutate(prot1 = prot) %&gt;%  # Guardamos la columna original de proteÃ­nas en una nueva columna\n  separate(prot1, c(\"one\",\"two\",\"three\"), sep = \"\\\\.\", extra = \"merge\") %&gt;% \n  unite(.,genome, c(\"one\",\"two\"), sep = \".\") %&gt;%  # Reunimos los dos primeros fragmentos para identificar el genoma\n  select(-three) %&gt;%  # Eliminamos el componente restante de la separaciÃ³n\n  filter(genome %in% tax$genome) %&gt;%  # Filtramos solo los genomas presentes en la lista filtrada de taxonomÃ­a\n  filter(.,!grepl(\"Cellular\",cor_mge))  # Excluimos elementos que no son MGEs mÃ³viles (\"Cellular\")\n\n## IdentificaciÃ³n de recombinasas compartidas entre genomas (potenciales eventos de HGT) ##\ndata_mge_class_hgt &lt;- data_mge_class_phy %&gt;% \n  group_by(rec_cluster) %&gt;%  # Agrupamos por clÃºster de recombinasa\n  summarise(count = n()) %&gt;%  # Contamos cuÃ¡ntos genomas comparten ese clÃºster\n  filter(., count &gt; 1)  # Nos quedamos solo con aquellos compartidos por mÃ¡s de un genoma (indicador de HGT)\n\n# Filtramos la tabla original para quedarnos solo con los clÃºsteres que muestran posible HGT\ndata_hgt &lt;- left_join(data_mge_class_hgt, data_mge_class_phy, by = \"rec_cluster\")"
  },
  {
    "objectID": "Figura4.html#paso-10-contar-combinaciones-de-familias-por-recombinasa",
    "href": "Figura4.html#paso-10-contar-combinaciones-de-familias-por-recombinasa",
    "title": "Figura 4",
    "section": "PASO 10: Contar combinaciones de familias por recombinasa",
    "text": "PASO 10: Contar combinaciones de familias por recombinasa\n\n# Numero de cluster por recombinadas\npre_hgt &lt;- data_hgt %&gt;% \n  group_by(rec_cluster) %&gt;% \n  summarise(family = paste(family, collapse = \":\")) %&gt;% \n  group_by(rec_cluster,family) %&gt;% \n  summarise(count = n()) \n\n# Normalizar combinaciones de familias (A:B â‰¡ B:A)\npre_hgt_decoupled &lt;- pre_hgt %&gt;% \n  group_by(family) %&gt;% \n  mutate(nfamily = duo_maker(family)) %&gt;% \n  ungroup() %&gt;% \n  separate_rows(nfamily, sep = \";\") %&gt;% group_by(rec_cluster,nfamily) %&gt;% summarise(ncount = sum(count)) %&gt;% \n  mutate(nfamily = map_chr(nfamily,~toString(sort(str_split(.x, \":\")[[1]]))))  %&gt;% \n  group_by(nfamily, rec_cluster)  %&gt;% \n  summarise(final_count = sum(ncount)) %&gt;%\n  ungroup() %&gt;%\n  filter(.,!grepl(\"NA \",nfamily))\n\n# Extrae las combinaciones Ãºnicas de familia y clase de los genomas involucrados en HGT\nrel_family_class &lt;- data_hgt %&gt;% \n  select(family, class) %&gt;% \n  unique(.) %&gt;% \n  mutate(family1 = family, family2 = family) %&gt;%  # Duplica la columna 'family' para facilitar joins posteriores\n  select(-family)  # Elimina la columna original 'family'\n\n# Separa las combinaciones de familias (tipo \"famA, famB\") en dos columnas distintas\npre_hgt_decoupled_family &lt;- pre_hgt_decoupled %&gt;% \n  separate(nfamily, c(\"family1\", \"family2\"), sep = \", \", extra = \"merge\")\n\n# Asocia 'family1' con su clase taxonÃ³mica (class.x)\npre_hgt_class1 &lt;- left_join(pre_hgt_decoupled_family, rel_family_class, by = \"family1\") %&gt;% \n  select(-family1) %&gt;%  # Elimina columna original family1 tras el join\n  dplyr::rename(family2 = family2.x)  # Renombra para mantener consistencia\n\n# Asocia 'family2' con su clase taxonÃ³mica (class.y), filtra pares con clases distintas,\n# agrupa por pares de clases y suma los eventos HGT\npre_hgt_class2 &lt;- left_join(pre_hgt_class1, rel_family_class, by = \"family2\") %&gt;% \n  select(-family2, -family2.y, -family1) %&gt;%  # Limpia columnas intermedias no necesarias\n  filter(., class.x != class.y) %&gt;%  # Conserva solo los pares donde hay diferencia de clase (potencial HGT entre clases)\n  group_by(class.x, class.y) %&gt;% \n  summarise(hgt_count = sum(final_count)) %&gt;%\n  \n  # Combina las clases en un nombre de par (ej. \"Gammaproteobacteria:Bacilli\")\n  unite(name_new, class.x:class.y, sep = \":\") %&gt;%\n  \n  # Ordena alfabÃ©ticamente las clases en cada par (para que \"A:B\" y \"B:A\" cuenten como uno solo)\n  mutate(name_new = map_chr(name_new, ~toString(sort(str_split(.x, \":\")[[1]])))) %&gt;% \n  \n  # Agrupa por el par Ãºnico ordenado y suma los eventos HGT redundantes\n  group_by(name_new) %&gt;% \n  summarise(final_count = sum(hgt_count)) %&gt;% \n  ungroup()\n\n# Muestra el total de eventos HGT entre clases\npre_hgt_class2 %&gt;% mutate(tot = sum(final_count)) %&gt;% head() # Resultado esperado: 2823 eventos para genomas de alta calidad\n\n# A tibble: 6 Ã— 3\n  name_new                               final_count   tot\n  &lt;chr&gt;                                        &lt;int&gt; &lt;int&gt;\n1 Acidithiobacillia, Betaproteobacteria            1  2823\n2 Acidithiobacillia, Gammaproteobacteria           2  2823\n3 Actinobacteria, Alphaproteobacteria             49  2823\n4 Actinobacteria, Bacilli                        123  2823\n5 Actinobacteria, Bacteroidia                      8  2823\n6 Actinobacteria, Betaproteobacteria              75  2823"
  },
  {
    "objectID": "Figura4.html#paso-11-cÃ¡lculo-de-hgt-basado-en-mge-para-obtener-arcos-de-mapas-tÃ©rmicos",
    "href": "Figura4.html#paso-11-cÃ¡lculo-de-hgt-basado-en-mge-para-obtener-arcos-de-mapas-tÃ©rmicos",
    "title": "Figura 4",
    "section": "PASO 11: CÃ¡lculo de HGT basado en MGE para obtener arcos de mapas tÃ©rmicos",
    "text": "PASO 11: CÃ¡lculo de HGT basado en MGE para obtener arcos de mapas tÃ©rmicos\n\n# Procesa el archivo renombrado para extraer el genoma y filtrar MGEs vÃ¡lidos (excluye \"Cellular\" y \"MGE_ND\")\ndata_mge_class_phy_MGE &lt;- data_mge_class_rename %&gt;% \n  mutate(prot1 = prot) %&gt;%  # Crea una columna auxiliar para separar la proteÃ­na\n  separate(prot1, c(\"one\", \"two\", \"three\"), sep = \"\\\\.\", extra = \"merge\") %&gt;%  # Separa ID de proteÃ­na por puntos\n  unite(., genome, c(\"one\", \"two\"), sep = \".\") %&gt;%  # Une las dos primeras partes como identificador del genoma\n  select(-three) %&gt;%  # Elimina el fragmento sobrante\n  filter(genome %in% tax$genome) %&gt;%  # Filtra por genomas de alta calidad definidos previamente\n  filter(!grepl(\"Cellular\", cor_mge) & !grepl(\"MGE_ND\", cor_mge))  # Excluye MGEs no definidos o de origen celular\n\n# Identifica recombinasas asociadas a MGEs que estÃ¡n presentes en mÃºltiples genomas â†’ potencial HGT\ndata_mge_class_hgt_MGE &lt;- data_mge_class_phy_MGE %&gt;% \n  group_by(rec_cluster) %&gt;% \n  summarise(count = n()) %&gt;%  \n  filter(count &gt; 1)  # Se quedan solo las recombinasas compartidas por mÃ¡s de un genoma\n\n# Extrae los datos completos de esas recombinasas compartidas\ndata_hgt_MGE &lt;- left_join(data_mge_class_hgt_MGE, data_mge_class_phy_MGE, by = \"rec_cluster\")\n\n# Agrupa por recombinasa y MGE, colapsando las familias taxonÃ³micas en texto separado por \":\"\npre_hgt_MGE &lt;- data_hgt %&gt;% \n  group_by(rec_cluster, cor_mge) %&gt;% \n  summarise(family = paste(family, collapse = \":\")) %&gt;% \n  group_by(rec_cluster, cor_mge, family) %&gt;% \n  summarise(count = n())  # Cuenta cuÃ¡ntas veces se da esa combinaciÃ³n\n\n# Descompone combinaciones de â‰¥3 familias en pares, elimina redundancias (A:B â‰¡ B:A)\npre_hgt_decoupled_MGE &lt;- pre_hgt_MGE %&gt;% \n  group_by(family) %&gt;% \n  mutate(nfamily = duo_maker(family)) %&gt;%  # Aplica funciÃ³n para generar pares de familias\n  ungroup() %&gt;% \n  separate_rows(nfamily, sep = \";\") %&gt;%  # Separa cada par generado\n  group_by(cor_mge, nfamily) %&gt;% \n  summarise(ncount = sum(count)) %&gt;%  # Suma ocurrencias por par y MGE\n  mutate(nfamily = map_chr(nfamily, ~toString(sort(str_split(.x, \":\")[[1]])))) %&gt;%  # Ordena alfabÃ©ticamente para unificar A:B y B:A\n  group_by(nfamily, cor_mge) %&gt;% \n  summarise(final_count = sum(ncount)) %&gt;% \n  ungroup() %&gt;% \n  filter(!grepl(\"NA \", nfamily))  # Elimina combinaciones que incluyan NA\n\nhead(pre_hgt_decoupled_MGE)\n\n# A tibble: 6 Ã— 3\n  nfamily                              cor_mge    final_count\n  &lt;chr&gt;                                &lt;chr&gt;            &lt;int&gt;\n1 Acetobacteraceae                     nested               1\n2 Acetobacteraceae, Enterobacteriaceae IS_Tn                3\n3 Acetobacteraceae, Lactobacillaceae   Phage_like           1\n4 Acetobacteraceae, Leuconostocaceae   IS_Tn                1\n5 Acetobacteraceae, Moraxellaceae      IS_Tn                1\n6 Acetobacteraceae, Pseudomonadaceae   IS_Tn                1"
  },
  {
    "objectID": "Figura4.html#paso-12-cÃ¡lculo-de-eventos-de-transferencia-horizontal-hgt-mediados-por-mge-entre-clases-taxonÃ³micas",
    "href": "Figura4.html#paso-12-cÃ¡lculo-de-eventos-de-transferencia-horizontal-hgt-mediados-por-mge-entre-clases-taxonÃ³micas",
    "title": "Figura 4",
    "section": "PASO 12: CÃ¡lculo de eventos de transferencia horizontal (HGT) mediados por MGE entre clases taxonÃ³micas",
    "text": "PASO 12: CÃ¡lculo de eventos de transferencia horizontal (HGT) mediados por MGE entre clases taxonÃ³micas\n\n# Crea una tabla Ãºnica de relaciÃ³n entre familia y clase para asignar clases taxonÃ³micas a pares de familias\nrel_family_class_MGE &lt;- data_hgt %&gt;% \n  select(family, class) %&gt;% \n  unique(.) %&gt;% \n  mutate(family1 = family, family2 = family) %&gt;%  # Prepara columnas duplicadas para unir por ambos lados del par\n  select(-family)\n\n# Separa las combinaciones de familias en pares individuales: columna \"family1\" y \"family2\"\npre_hgt_decoupled_family_MGE &lt;- pre_hgt_decoupled_MGE %&gt;% \n  separate(nfamily, c(\"family1\", \"family2\"), sep = \", \", extra = \"merge\")\n\n# Une cada \"family1\" con su clase correspondiente\npre_hgt_class1_MGE &lt;- left_join(pre_hgt_decoupled_family_MGE, rel_family_class_MGE, by = \"family1\") %&gt;% \n  select(-family1) %&gt;% \n  dplyr::rename(family2 = family2.x)  # Ajuste de nombres para evitar duplicados\n\n# Une cada \"family2\" con su clase correspondiente, y filtra las que pertenecen a clases distintas\npre_hgt_class2_MGE &lt;- left_join(pre_hgt_class1_MGE, rel_family_class_MGE, by = \"family2\") %&gt;% \n  select(-family2, -family2.y, -family1) %&gt;% \n  filter(class.x != class.y) %&gt;%  # Solo eventos entre clases diferentes\n  group_by(class.x, class.y, cor_mge) %&gt;% \n  summarise(hgt_count = sum(final_count))  # Cuenta total de eventos entre cada par de clases por tipo de MGE\n\n# Une los nombres de clase para formar un identificador de par, agrupa, y descompone combinaciones A:B y B:A\npre_hgt_decoupled_class_MGE &lt;- pre_hgt_class2_MGE %&gt;% \n  unite(new, class.x:class.y, sep = \":\") %&gt;%  # Combina el nombre de ambas clases\n  group_by(new, cor_mge) %&gt;% \n  mutate(name_new = duo_maker(new)) %&gt;%  # Genera pares Ãºnicos (A:B = B:A)\n  ungroup() %&gt;% \n  separate_rows(name_new, sep = \";\") %&gt;%  # Separa mÃºltiples combinaciones si hay\n  group_by(name_new, cor_mge) %&gt;%\n  summarize(hgt_count = sum(hgt_count)) %&gt;%  # Suma los eventos para cada combinaciÃ³n de clases por MGE\n  ungroup() %&gt;%\n  mutate(name_new = map_chr(name_new, ~toString(sort(str_split(.x, \":\")[[1]])))) %&gt;%  # Ordena los nombres de clase alfabÃ©ticamente\n  group_by(name_new, cor_mge) %&gt;% \n  summarise(final_count = sum(hgt_count)) %&gt;%  # Suma eventos redundantes unificados\n  ungroup() %&gt;%\n  separate(name_new, c(\"class.x\", \"class.y\"))  # Vuelve a separar en columnas para posterior anÃ¡lisis o visualizaciÃ³n\n\nhead(pre_hgt_decoupled_class_MGE)\n\n# A tibble: 6 Ã— 4\n  class.x           class.y             cor_mge    final_count\n  &lt;chr&gt;             &lt;chr&gt;               &lt;chr&gt;            &lt;int&gt;\n1 Acidithiobacillia Gammaproteobacteria CE                   2\n2 Actinobacteria    Alphaproteobacteria CE                   1\n3 Actinobacteria    Alphaproteobacteria IS_Tn               18\n4 Actinobacteria    Alphaproteobacteria Integron             4\n5 Actinobacteria    Alphaproteobacteria Phage_like          26\n6 Actinobacteria    Bacilli             CE                  10"
  },
  {
    "objectID": "Figura4.html#paso-13-arcos-hgt-figura-4b-para-itol",
    "href": "Figura4.html#paso-13-arcos-hgt-figura-4b-para-itol",
    "title": "Figura 4",
    "section": "PASO 13: Arcos HGT Figura 4B para iTOL",
    "text": "PASO 13: Arcos HGT Figura 4B para iTOL\n\n# ConstrucciÃ³n de la tabla de clases HGT por MGE\nclass_tab &lt;- pre_hgt_decoupled_class_MGE %&gt;% \n  unite(new, class.x:class.y, sep = \":\") %&gt;%\n  group_by(new,cor_mge) %&gt;% \n  mutate(name_new = duo_maker(new)) %&gt;% \n  ungroup() %&gt;% \n  separate_rows(name_new, sep = \";\") %&gt;% \n  group_by(name_new,cor_mge) %&gt;%\n  summarize(hgt_count = sum(final_count)) %&gt;%\n  select(name_new,cor_mge, hgt_count) %&gt;%\n  ungroup() %&gt;% \n  separate(name_new, c(\"class.x\",\"class.y\"))\n\n# CÃ¡lculo del porcentaje de eventos HGT por categorÃ­a de MGE\nclass_tab %&gt;% \n  group_by(cor_mge) %&gt;% \n  summarise(f = sum(hgt_count)) %&gt;% \n  mutate(frac = (f/sum(f))*100)\n\n# A tibble: 7 Ã— 3\n  cor_mge        f   frac\n  &lt;chr&gt;      &lt;int&gt;  &lt;dbl&gt;\n1 CE           523 21.9  \n2 IS_Tn       1218 50.9  \n3 Integron      97  4.05 \n4 MI            53  2.21 \n5 Phage         10  0.418\n6 Phage_like   475 19.8  \n7 nested        17  0.710\n\n\nDescripciÃ³n paso a paso:\n\nAgrupa los datos por categorÃ­a MGE (cor_mge).\nSuma el nÃºmero total de eventos HGT (hgt_count) por MGE (f).\nCalcula el porcentaje que representa cada MGE respecto al total de eventos (frac).\n\n\n# Resumen para grÃ¡ficas\nclass_tab_plot &lt;- class_tab %&gt;% \n  group_by(cor_mge) %&gt;% \n  summarise(count = sum(hgt_count)) \n\nSe crea un resumen del nÃºmero total de eventos HGT (count) por cada categorÃ­a de MGE (cor_mge), Ãºtil para graficar.\nGuardar archivos\n\n# AsignaciÃ³n de Ã¡ngulos personalizados para los arcos\nangles &lt;- seq(32,80,12)\n# GeneraciÃ³n de archivos para cada categorÃ­a de MGE\nfor(i in 1:length(mges)) {\n  separator &lt;- c(\"DATASET_CONNECTION\",\"SEPARATOR COMMA\")\n  dataset_label &lt;- paste0(\"DATASET_LABEL,\",mges[i])\n  # Asignar un color a cada conjunto de datos, usando el valor correspondiente de 'colc'\n  dcolor &lt;- paste0(\"COLOR,\",colc_grey[mges[i]])\n  optional &lt;- c(\"DRAW_ARROWS,0\",paste0(\"CURVE_ANGLE,\",angles[i]),\"CENTER_CURVES,1\",\"ALIGN_TO_LABELS,1\")\n# DescripciÃ³n: Opciones adicionales de formato para iTOL:\n# - DRAW_ARROWS,0: No dibujar flechas.\n# - CURVE_ANGLE: Define el Ã¡ngulo del arco.\n# - CENTER_CURVES,1: Centra los arcos.\n# - ALIGN_TO_LABELS,1: Alinea los extremos a las etiquetas del Ã¡rbol.\n  data_lines &lt;- c(\"DATA\")\n  data_oi &lt;- class_tab %&gt;% filter(cor_mge==mges[i])\n  # Inicializar las lÃ­neas de salida con los parÃ¡metros de encabezado y configuraciÃ³n\n  out_lines &lt;- c(separator, dataset_label, dcolor, optional, data_lines)\n  for(j in 1:nrow(data_oi)){\n    line_oi &lt;- paste(data_oi[j,1],data_oi[j,2],\"2\",colc_grey[mges[i]],\"normal\",sep = \",\")\n     # AÃ±adir la lÃ­nea de conexiÃ³n a las lÃ­neas de salida\n    out_lines &lt;- c(out_lines,line_oi)\n  }\n  # Guardar archivos - Salida de los archivos\n  writeLines(out_lines, paste0(mges[i],\"_class_sub_grey_itol_connections_fig4B.txt\"))\n}"
  },
  {
    "objectID": "Figura4.html#paso-14-preparaciÃ³n-de-los-datos-para-el-grÃ¡fico-de-calor-heatmap-de-hgt-transferencia-horizontal-de-genes",
    "href": "Figura4.html#paso-14-preparaciÃ³n-de-los-datos-para-el-grÃ¡fico-de-calor-heatmap-de-hgt-transferencia-horizontal-de-genes",
    "title": "Figura 4",
    "section": "PASO 14: PreparaciÃ³n de los datos para el grÃ¡fico de calor (heatmap) de HGT (Transferencia Horizontal de Genes)",
    "text": "PASO 14: PreparaciÃ³n de los datos para el grÃ¡fico de calor (heatmap) de HGT (Transferencia Horizontal de Genes)\n\n# Separar la columna 'name_new' en dos nuevas columnas: 'class1' y 'class2'\nhgt_class_level &lt;- pre_hgt_class2 %&gt;% \n  separate(name_new, into = c(\"class1\", \"class2\"), sep = \", \") \n# La funciÃ³n 'separate' divide la columna 'name_new' en dos nuevas columnas 'class1' y 'class2' usando la coma y el espacio como delimitador.\n\n# Filtrar los datos para excluir filas con valores \"NA\" en las columnas 'class1', 'class2' y 'final_count'\nhgt_class_level_spread &lt;- hgt_class_level %&gt;%\n  filter(!grepl(\"NA\", class1)) %&gt;%  # Excluir filas donde 'class1' contiene \"NA\"\n  filter(!grepl(\"NA\", class2)) %&gt;%  # Excluir filas donde 'class2' contiene \"NA\"\n  filter(!grepl(\"NA\", final_count)) %&gt;%  # Excluir filas donde 'final_count' contiene \"NA\"\n  # Pivotar los datos para que 'class1' sea la columna identificadora y las combinaciones de 'class2' sean las nuevas columnas\n  pivot_wider(id_cols = class1, names_from = class2, values_from = final_count) %&gt;%\n  # Convertir 'class1' en las filas del dataframe\n  column_to_rownames(var = \"class1\") %&gt;%\n  # Reemplazar los valores NA por 0\n  replace(is.na(.), 0)\n\n# Crear una lista con todas las clases Ãºnicas en 'class1' y 'class2'\nallClasses &lt;- unique(c(hgt_class_level$class1, hgt_class_level$class2)) \n# 'unique' se usa para obtener las clases Ãºnicas en ambas columnas, 'class1' y 'class2'\n\n# Eliminar cualquier \"NA\" de la lista de clases\nallClasses &lt;- allClasses[!grepl(\"NA\", allClasses)] \n\n# Mantener solo las clases presentes en el Ã¡rbol filogenÃ©tico 'class_tree'\nclass_tree_rooted &lt;- keep.tip(class_tree, as.vector(allClasses)) \n# 'keep.tip' selecciona solo los elementos de 'class_tree' que estÃ¡n en la lista 'allClasses'\n\nGuadar archivo de filogenia\n\nwrite.tree(class_tree_rooted,file=\"data/processed_data/hgt_tree.nwk\")\n\n\nFigura 4B: Matriz SimÃ©trica para VisualizaciÃ³n de HGT en un Ãrbol FilogenÃ©tico\nCrear una nueva matriz con ceros, donde las filas y las columnas son las etiquetas de las puntas del Ã¡rbol filogenÃ©tico â€˜class_tree_rootedâ€™\n\n# Nueva matriz\nnew_matrix &lt;- matrix(0, nrow = Ntip(class_tree_rooted), ncol = Ntip(class_tree_rooted), \n                     dimnames = list(class_tree_rooted$tip.label, rev(class_tree_rooted$tip.label)))\n# 'Ntip(class_tree_rooted)' devuelve el nÃºmero de puntas (tips) en el Ã¡rbol filogenÃ©tico 'class_tree_rooted'\n# La matriz tiene el mismo nÃºmero de filas y columnas, con las etiquetas de las puntas en ambas dimensiones.\n# 'rev' invierte el orden de las etiquetas de las puntas para las columnas.\n\n# Bucle para iterar sobre cada fila (i) y columna (j) de la matriz de datos 'hgt_class_level_spread'\nfor(i in rownames(hgt_class_level_spread )) {\n  for(j in colnames(hgt_class_level_spread )) {\n    \n    # Obtener el valor de 'final_count' en la intersecciÃ³n de la fila 'i' y la columna 'j'\n    value &lt;- hgt_class_level_spread[i,j]\n    \n    # Si el valor es mayor que 0, actualizar la matriz nueva\n    if(value &gt; 0) {\n      new_matrix[i,j] &lt;- (value)  # Asignar el valor en la posiciÃ³n (i, j)\n      new_matrix[j,i] &lt;- (value)  # Asignar el mismo valor en la posiciÃ³n (j, i) (simetrÃ­a)\n    }\n  }\n}\n\n# Establecer un pequeÃ±o valor para mejorar la visualizaciÃ³n en el grÃ¡fico de calor\nsmall_value &lt;- unique(sort(unlist(new_matrix)))[2]\n# 'unlist' convierte la matriz en un vector, 'sort' ordena los valores, 'unique' elimina duplicados\n# El segundo valor mÃ¡s pequeÃ±o se asigna a 'small_value' para usarlo como referencia visual en el grÃ¡fico.\n\nsmall_value &lt;- small_value - small_value %% 0.001\n# Ajustar 'small_value' a un valor redondeado a tres decimales (eliminando el residuo de la divisiÃ³n por 0.001)\n# Esto es Ãºtil para establecer un umbral mÃ­nimo visual en el grÃ¡fico.\n\n# Definir los puntos de corte (breaks) para el grÃ¡fico de calor\nheatmap_breaks &lt;- c(0, small_value, lseq(1, max(new_matrix), length.out = 18))\n# El primer valor es 0, el segundo es 'small_value' (valor pequeÃ±o para mejorar la visualizaciÃ³n), \n# y el tercero es una secuencia logarÃ­tmica entre 1 y el valor mÃ¡ximo de 'new_matrix', dividida en 18 puntos.\n\n# Definir la paleta de colores para el grÃ¡fico de calor\nplot_colors &lt;- c(\"white\", colorRampPalette((viridis(10)), bias = 5)(length(heatmap_breaks) - 2))\n# 'viridis(10)' genera una paleta de 10 colores usando la paleta 'viridis'.\n# 'colorRampPalette' expande esta paleta segÃºn la longitud de 'heatmap_breaks' menos 2 (porque ya se definen 0 y 'small_value').\n# 'bias = 5' ajusta la distribuciÃ³n de los colores, dÃ¡ndole mÃ¡s Ã©nfasis a los valores mÃ¡s altos.\n\nVisualizacion grafica\n\nphylo.heatmap.orient(class_tree_rooted, \n                     new_matrix, fsize = c(0.9, 0.9, 1), \n                     colors = plot_colors, grid = T, split = c(0.6, 0.4), breaks = heatmap_breaks, lwd = 1)\n\n\n\n\nPuedes encontrar el script completo en Figura4_modificado.R."
  },
  {
    "objectID": "Figura5.html",
    "href": "Figura5.html",
    "title": "Figura 5",
    "section": "",
    "text": "NOTA: Agregar el diagrama con descripcion del analisis.\n\n\n\n\nFigure 5.Antibiotic Resistance Genes (ARGs) carrying potential of MGEs.\n\n\n\nEl anÃ¡lisis de MGEs (por categorÃ­a) que transportan ARGs muestra un enriquecimiento de ARGs en elementos transponibles en comparaciÃ³n con otras regiones genÃ³micas, lo que indica a los elementos transponibles como los principales transportadores de ARGs asociados a MGEs.\nAsociaciÃ³n de los mecanismos de resistencia a antibiÃ³ticos con diferentes categorÃ­as de MGEs. Los asteriscos indican un enriquecimiento significativo segÃºn la prueba exacta de Fisher unilateral (valor P &lt; 0.05 despuÃ©s de la correcciÃ³n de Bonferroni).\n\nPuedes encontrar el script completo en Figura5_modificado.R."
  },
  {
    "objectID": "Figura5.html#potencial-de-los-mges-para-transportar-genes-de-resistencia-a-antibiÃ³ticos-args",
    "href": "Figura5.html#potencial-de-los-mges-para-transportar-genes-de-resistencia-a-antibiÃ³ticos-args",
    "title": "Figura 5",
    "section": "",
    "text": "NOTA: Agregar el diagrama con descripcion del analisis.\n\n\n\n\nFigure 5.Antibiotic Resistance Genes (ARGs) carrying potential of MGEs.\n\n\n\nEl anÃ¡lisis de MGEs (por categorÃ­a) que transportan ARGs muestra un enriquecimiento de ARGs en elementos transponibles en comparaciÃ³n con otras regiones genÃ³micas, lo que indica a los elementos transponibles como los principales transportadores de ARGs asociados a MGEs.\nAsociaciÃ³n de los mecanismos de resistencia a antibiÃ³ticos con diferentes categorÃ­as de MGEs. Los asteriscos indican un enriquecimiento significativo segÃºn la prueba exacta de Fisher unilateral (valor P &lt; 0.05 despuÃ©s de la correcciÃ³n de Bonferroni).\n\nPuedes encontrar el script completo en Figura5_modificado.R."
  },
  {
    "objectID": "glosario.html",
    "href": "glosario.html",
    "title": "Glosario",
    "section": "",
    "text": "Escrito por: Diana BarcelÃ³ y Marisol Navarro\n\n\n\n\nSusceptibilidad antibiÃ³ticaÂ se refiere a la capacidad de un microorganismo para ser afectado o inhibido por un determinado antibiÃ³tico (o agente antimicrobiano). Es una medida de su eficacia frente el microorganismo en cuestiÃ³n. La susceptibilidad se determina mediante pruebas de laboratorio, en los que se expone el microorganismo a una o varias concentraciones de agentes antimicrobianos y se evalÃºa su crecimiento o inhibiciÃ³n.\n\n\n\n\n\nSensibilidad antibiÃ³tica: La sensibilidad antibiÃ³tica se utiliza para indicar la respuesta clÃ­nica de una patologÃ­a a un antibiÃ³tico especÃ­fico. La sensibilidad antibiÃ³tica se evalÃºa en funciÃ³n de la susceptibilidad del microorganismo causante de la infecciÃ³n, pero tambiÃ©n puede depender de otros factores, como la concentraciÃ³n del antibiÃ³tico en el tejido infectado, la capacidad del antibiÃ³tico para llegar al sitio de la infecciÃ³n, la respuesta inmunolÃ³gica del paciente, etc.\nConjugaciÃ³n: Una bacteria transfiere DNA a otra a travÃ©s de un â€œpuenteâ€ formado por estructuras llamadas pilis.Â \nTransducciÃ³n: Un virus (bacteriÃ³fago) infecta una bacteria y luego introduce el DNA de otra bacteria infectada previamente en una nueva cÃ©lula.Â \nTransformaciÃ³n: Una bacteria puede incorporar fragmentos de ADN libre del entorno, provenientes de otras bacterias muertas o de su medio."
  },
  {
    "objectID": "glosario.html#conceptos-importantes-del-articulo",
    "href": "glosario.html#conceptos-importantes-del-articulo",
    "title": "Glosario",
    "section": "",
    "text": "Escrito por: Diana BarcelÃ³ y Marisol Navarro\n\n\n\n\nSusceptibilidad antibiÃ³ticaÂ se refiere a la capacidad de un microorganismo para ser afectado o inhibido por un determinado antibiÃ³tico (o agente antimicrobiano). Es una medida de su eficacia frente el microorganismo en cuestiÃ³n. La susceptibilidad se determina mediante pruebas de laboratorio, en los que se expone el microorganismo a una o varias concentraciones de agentes antimicrobianos y se evalÃºa su crecimiento o inhibiciÃ³n.\n\n\n\n\n\nSensibilidad antibiÃ³tica: La sensibilidad antibiÃ³tica se utiliza para indicar la respuesta clÃ­nica de una patologÃ­a a un antibiÃ³tico especÃ­fico. La sensibilidad antibiÃ³tica se evalÃºa en funciÃ³n de la susceptibilidad del microorganismo causante de la infecciÃ³n, pero tambiÃ©n puede depender de otros factores, como la concentraciÃ³n del antibiÃ³tico en el tejido infectado, la capacidad del antibiÃ³tico para llegar al sitio de la infecciÃ³n, la respuesta inmunolÃ³gica del paciente, etc.\nConjugaciÃ³n: Una bacteria transfiere DNA a otra a travÃ©s de un â€œpuenteâ€ formado por estructuras llamadas pilis.Â \nTransducciÃ³n: Un virus (bacteriÃ³fago) infecta una bacteria y luego introduce el DNA de otra bacteria infectada previamente en una nueva cÃ©lula.Â \nTransformaciÃ³n: Una bacteria puede incorporar fragmentos de ADN libre del entorno, provenientes de otras bacterias muertas o de su medio."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Sobre nosotras",
    "section": "",
    "text": "Esta sesiÃ³n promueve la reproducibilidad del cÃ³digo, la buena documentaciÃ³n del cÃ³digo y buenas prÃ¡cticas para generar un mejor futuro en la ciencia con acceso libre a la informaciÃ³n. Siendo parte del Reprohack2025 de R-Ladies Morelia y RSG_Mexico."
  },
  {
    "objectID": "index.html#un-enfoque-computacional-para-el-estudio-de-los-elementos-genÃ©ticos-mÃ³viles-en-procariotas",
    "href": "index.html#un-enfoque-computacional-para-el-estudio-de-los-elementos-genÃ©ticos-mÃ³viles-en-procariotas",
    "title": "Sobre nosotras",
    "section": "Un enfoque computacional para el estudio de los elementos genÃ©ticos mÃ³viles en procariotas",
    "text": "Un enfoque computacional para el estudio de los elementos genÃ©ticos mÃ³viles en procariotas\nEl artÃ­culo explora cÃ³mo los elementos genÃ©ticos mÃ³viles (MGEs), como transposones, integrones, fagos y plÃ¡smidos, contribuyen a la evoluciÃ³n procariota y a la dispersiÃ³n de resistencia a antibiÃ³ticos. Usando un enfoque computacional basado en recombinasas y datos de pangenomas, analizaron ~84,000 genomas, identificando 2.8 millones de MGEs. Descubrieron que los elementos transponibles son los mÃ¡s abundantes y los principales portadores de genes de resistencia. AdemÃ¡s, presentan una base de datos (http://promge.embl.de/) para futuras investigaciones.\nAquÃ­ puedes encontrar el artÃ­culo completo: Landscape of mobile genetic elements and their antibiotic resistance cargo in prokaryotic genomes"
  },
  {
    "objectID": "index.html#integrantes",
    "href": "index.html#integrantes",
    "title": "Sobre nosotras",
    "section": "Integrantes",
    "text": "Integrantes\n\nInstructores\n\nEvelia Coss - posdoctoral LIIGH-UNAM. Miembro de LupusRGMX, Project JAGUAR, RiaBio, CDSB-Mexico, RSG-MÃ©xico y RLadies Morelia. Coordinadora de los VieRnes de Bioinformatica en el LIIGH. Instructora Certificada de The Carpentries. Contacto: correo, pagina web\nMarisol Navarro - RSG-MÃ©xico y RLadies Morelia.\nDiana BarcelÃ³ - Profesor investigador de tiempo completo de la Escuela de Medicina de la Universidad Quetzalcoatl. Editora en Jefe de la revista INVESMED (InvestigaciÃ³n y EducaciÃ³n MÃ©dica). Miembro del cuerpo acadÃ©mico del AMFEM (AsociaciÃ³n Mexicana de Facultades y Escuelas de Medicina, A.C.)\nJohana CastelÃ¡n - RSG-MÃ©xico y RLadies Morelia.\n\n\n\nAyudantes\n\nMayela Fosado - Instituto de NeurobiologÃ­a (INB)-UNAM.\nEmilio OrtÃ­z - Instituto de NeurobiologÃ­a (INB)-UNAM.\nMariana Devon - Departamento de BioinformÃ¡tica en Enfermedades Infecciosas, ESPM-INSP.\nAndrÃ©s Arredondo - Ciencias AgrogenÃ³micas, ENES LeÃ³n-UNAM."
  },
  {
    "objectID": "index.html#citar-y-reutilizar-el-material-del-curso",
    "href": "index.html#citar-y-reutilizar-el-material-del-curso",
    "title": "Sobre nosotras",
    "section": "Citar y reutilizar el material del curso",
    "text": "Citar y reutilizar el material del curso\nLos datos del curso se pueden reutilizar y adaptar libremente con la debida atribuciÃ³n. Todos los datos de los cursos de estos repositorios estÃ¡n sujetos a la licencia Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)."
  },
  {
    "objectID": "index.html#patrocinadores",
    "href": "index.html#patrocinadores",
    "title": "Sobre nosotras",
    "section": "Patrocinadores",
    "text": "Patrocinadores\n\n    \n\n\nCursos hechos con amor ğŸ’œ"
  },
  {
    "objectID": "resumen.html",
    "href": "resumen.html",
    "title": "Resumen",
    "section": "",
    "text": "Escrito por: Diana BarcelÃ³\n\nAutores: Supriya Khedkar, Georgy Smyshlyaev, Ivica Letunic, Oleksandr M. Maistrenko, Luis Pedro Coelho, Askarbek Orakov, Sofia K. Forslund, Falk Hildebrand, Mechthild Luetge, Thomas S.B. Schmidt, Orsolya Barabas and Peer Bork.\nLos Elementos GenÃ©ticos MÃ³viles (MGE por sus siglas en inglÃ©s) en procariotas, como transposones, integrones, fagos y plÃ¡smidos, desempeÃ±an un papel importante en la evoluciÃ³n procariota y en la dispersiÃ³n de funciones de carga, como la resistencia a los antibiÃ³ticos. Sin embargo, cada uno de estos tipos de MGE suele anotarse y analizarse individualmente, lo que dificulta una comprensiÃ³n global de los patrones filogenÃ©ticos y ambientales de la dispersiÃ³n de MGE. En consecuencia, se desarrollÃ³ un marco computacional que captura diversos tipos de MGE, sus cargas y los eventos de transferencia horizontal mediados por MGE. Para ello se utilizaron recombinasas como genes marcadores de MGE ubicuos, asÃ­ como informaciÃ³n pangenÃ³mica para la estimaciÃ³n de los lÃ­mites de MGE. Este estudio fue aplicado a aproximadamente 84,000 genomas con anotaciÃ³n de hÃ¡bitat, mapeando 2,8 millones de recombinasas especÃ­ficas de MGE a seis tipos operativos de MGE, que juntos contienen, en promedio, el 13% de todos los genes de un genoma. Los elementos transponibles (TE por sus siglas en inglÃ©s) predominaron en todos los taxones (âˆ¼1.7 millones de ocurrencias), superando en nÃºmero a los fagos y elementos similares a fagos (&lt;0.4 millones). Se registraron numerosos eventos de transferencia horizontal mediados por MEG en diversos filos y hÃ¡bitats que involucran todos los tipos de MGE; se aclarÃ³ y cuantificÃ³ el grado de interacciÃ³n de MGE (17%) e integrones (63%) con otras categorÃ­as de MGE, y se estableciÃ³ que los MGE son portadores dominantes de genes de resistencia a antibiÃ³ticos. Todos esos hallazgos se integraron en un recurso (proMGE.embl.de), el cual deberÃ­a facilitar futuros estudios sobre la gran parte mÃ³vil de los genomas y su dispersiÃ³n horizontal.\nAquÃ­ puedes encontrar el artÃ­culo completo: Landscape of mobile genetic elements and their antibiotic resistance cargo in prokaryotic genomes\n\n\n\n\n\nTabla CategorÃ­as de Elementos GenÃ©ticos MÃ³viles\n\n\n\n\n\nCollage de Resistencia a antibiÃ³ticos\n\n\n\n\n\nDiagrama Tipos de Recombinasas\n\n\nPresentaciÃ³n completa"
  },
  {
    "objectID": "resumen.html#reprohack-landscape-of-mobile-genetic-elements-and-their-antibiotic-resistance-cargo-in-prokaryotic-genomes",
    "href": "resumen.html#reprohack-landscape-of-mobile-genetic-elements-and-their-antibiotic-resistance-cargo-in-prokaryotic-genomes",
    "title": "Resumen",
    "section": "",
    "text": "Escrito por: Diana BarcelÃ³\n\nAutores: Supriya Khedkar, Georgy Smyshlyaev, Ivica Letunic, Oleksandr M. Maistrenko, Luis Pedro Coelho, Askarbek Orakov, Sofia K. Forslund, Falk Hildebrand, Mechthild Luetge, Thomas S.B. Schmidt, Orsolya Barabas and Peer Bork.\nLos Elementos GenÃ©ticos MÃ³viles (MGE por sus siglas en inglÃ©s) en procariotas, como transposones, integrones, fagos y plÃ¡smidos, desempeÃ±an un papel importante en la evoluciÃ³n procariota y en la dispersiÃ³n de funciones de carga, como la resistencia a los antibiÃ³ticos. Sin embargo, cada uno de estos tipos de MGE suele anotarse y analizarse individualmente, lo que dificulta una comprensiÃ³n global de los patrones filogenÃ©ticos y ambientales de la dispersiÃ³n de MGE. En consecuencia, se desarrollÃ³ un marco computacional que captura diversos tipos de MGE, sus cargas y los eventos de transferencia horizontal mediados por MGE. Para ello se utilizaron recombinasas como genes marcadores de MGE ubicuos, asÃ­ como informaciÃ³n pangenÃ³mica para la estimaciÃ³n de los lÃ­mites de MGE. Este estudio fue aplicado a aproximadamente 84,000 genomas con anotaciÃ³n de hÃ¡bitat, mapeando 2,8 millones de recombinasas especÃ­ficas de MGE a seis tipos operativos de MGE, que juntos contienen, en promedio, el 13% de todos los genes de un genoma. Los elementos transponibles (TE por sus siglas en inglÃ©s) predominaron en todos los taxones (âˆ¼1.7 millones de ocurrencias), superando en nÃºmero a los fagos y elementos similares a fagos (&lt;0.4 millones). Se registraron numerosos eventos de transferencia horizontal mediados por MEG en diversos filos y hÃ¡bitats que involucran todos los tipos de MGE; se aclarÃ³ y cuantificÃ³ el grado de interacciÃ³n de MGE (17%) e integrones (63%) con otras categorÃ­as de MGE, y se estableciÃ³ que los MGE son portadores dominantes de genes de resistencia a antibiÃ³ticos. Todos esos hallazgos se integraron en un recurso (proMGE.embl.de), el cual deberÃ­a facilitar futuros estudios sobre la gran parte mÃ³vil de los genomas y su dispersiÃ³n horizontal.\nAquÃ­ puedes encontrar el artÃ­culo completo: Landscape of mobile genetic elements and their antibiotic resistance cargo in prokaryotic genomes\n\n\n\n\n\nTabla CategorÃ­as de Elementos GenÃ©ticos MÃ³viles\n\n\n\n\n\nCollage de Resistencia a antibiÃ³ticos\n\n\n\n\n\nDiagrama Tipos de Recombinasas\n\n\nPresentaciÃ³n completa"
  },
  {
    "objectID": "retos.html",
    "href": "retos.html",
    "title": "Retos y problemas con el cÃ³digo",
    "section": "",
    "text": "Notas clave:\n\nUso de Archivos Comprimidos: Cuando trabajen con archivos comprimidos (por ejemplo, con extensiÃ³n .gz), no es necesario descomprimirlos manualmente antes de cargarlos en R.\nCÃ³digo Correcto para Cargar Archivos Comprimidos: Para cargar archivos comprimidos sin descomprimirlos previamente, utilicen el siguiente cÃ³digo:\n\n\nmge_pg &lt;- read_tsv(\"data/processed_data/mge_bins_per_genome_final.txt.gz\", col_names = TRUE)\n\n\nDiferencia con el CÃ³digo Original: En el cÃ³digo original, el archivo estaba descomprimido. Sin embargo, con la extensiÃ³n .gz, se puede leer directamente el archivo comprimido sin la necesidad de usar herramientas adicionales para descomprimirlo.\nArchivos muy pesados."
  },
  {
    "objectID": "retos.html#carga-de-archivos-comprimidos-en-r",
    "href": "retos.html#carga-de-archivos-comprimidos-en-r",
    "title": "Retos y problemas con el cÃ³digo",
    "section": "",
    "text": "Notas clave:\n\nUso de Archivos Comprimidos: Cuando trabajen con archivos comprimidos (por ejemplo, con extensiÃ³n .gz), no es necesario descomprimirlos manualmente antes de cargarlos en R.\nCÃ³digo Correcto para Cargar Archivos Comprimidos: Para cargar archivos comprimidos sin descomprimirlos previamente, utilicen el siguiente cÃ³digo:\n\n\nmge_pg &lt;- read_tsv(\"data/processed_data/mge_bins_per_genome_final.txt.gz\", col_names = TRUE)\n\n\nDiferencia con el CÃ³digo Original: En el cÃ³digo original, el archivo estaba descomprimido. Sin embargo, con la extensiÃ³n .gz, se puede leer directamente el archivo comprimido sin la necesidad de usar herramientas adicionales para descomprimirlo.\nArchivos muy pesados."
  },
  {
    "objectID": "tema2.html",
    "href": "tema2.html",
    "title": "Buenas prÃ¡cticas en la bioinformÃ¡tica",
    "section": "",
    "text": "La bioinformÃ¡tica, en relaciÃ³n con la genÃ©tica y la genÃ³mica ğŸ”¬, es una subdisciplina cientÃ­fica que implica el uso de ciencias informÃ¡ticas ğŸ“ˆ para recopilar, almacenar, analizar y diseminar datos biolÃ³gicos, como secuencias de ADN y aminoÃ¡cidos o anotaciones sobre esas secuencias NIH, 2023.\nUno de sus objetivos es: Aumentar el entendimiento de la salud y la enfermedad, en ciertos casos, se usan para proveer mejor atenciÃ³n mÃ©dica NIH, 2023.\nNIH: National Human Genome Research Institute\n\n\nHacia una biologÃ­a computacional mÃ¡s reproducible, transparente y colaborativa ğŸ’œ\n\nâ€œLos hechos individuales no reproducibles no tienen ninguna importancia para la cienciaâ€\nKarl Popper\n\nMÃ¡s informaciÃ³n aquÃ­."
  },
  {
    "objectID": "tema2.html#bioinformÃ¡tica-se-conforma-de-la-computaciÃ³n-biolÃ³gica-matemÃ¡ticas-y-estadÃ­stica",
    "href": "tema2.html#bioinformÃ¡tica-se-conforma-de-la-computaciÃ³n-biolÃ³gica-matemÃ¡ticas-y-estadÃ­stica",
    "title": "Buenas prÃ¡cticas en la bioinformÃ¡tica",
    "section": "",
    "text": "La bioinformÃ¡tica, en relaciÃ³n con la genÃ©tica y la genÃ³mica ğŸ”¬, es una subdisciplina cientÃ­fica que implica el uso de ciencias informÃ¡ticas ğŸ“ˆ para recopilar, almacenar, analizar y diseminar datos biolÃ³gicos, como secuencias de ADN y aminoÃ¡cidos o anotaciones sobre esas secuencias NIH, 2023.\nUno de sus objetivos es: Aumentar el entendimiento de la salud y la enfermedad, en ciertos casos, se usan para proveer mejor atenciÃ³n mÃ©dica NIH, 2023.\nNIH: National Human Genome Research Institute\n\n\nHacia una biologÃ­a computacional mÃ¡s reproducible, transparente y colaborativa ğŸ’œ\n\nâ€œLos hechos individuales no reproducibles no tienen ninguna importancia para la cienciaâ€\nKarl Popper\n\nMÃ¡s informaciÃ³n aquÃ­."
  },
  {
    "objectID": "tema2.html#un-algoritmo-nos-permite-resolver-un-problema",
    "href": "tema2.html#un-algoritmo-nos-permite-resolver-un-problema",
    "title": "Buenas prÃ¡cticas en la bioinformÃ¡tica",
    "section": "Un algoritmo nos permite resolver un problema â­",
    "text": "Un algoritmo nos permite resolver un problema â­\nUn algoritmo es un mÃ©todo para resolver un problema mediante una serie de pasos definidos, precisos y finitos.\n\nDefinido: si se sigue dos veces, se obtiene el mismo resultado. Es reproducible.\nPreciso: implica el orden de realizaciÃ³n de cada uno de los pasos.\nFinito: Tiene un numero determinado de pasos, implica que tiene un fin.\n\n\nUn algoritmo podemos definirlo como un programa o software."
  },
  {
    "objectID": "tema2.html#para-escribir-un-buen-software-necesitas",
    "href": "tema2.html#para-escribir-un-buen-software-necesitas",
    "title": "Buenas prÃ¡cticas en la bioinformÃ¡tica",
    "section": "Para escribir un buen software necesitas:",
    "text": "Para escribir un buen software necesitas:\n\nEscribir cÃ³digo mantenible (maintainable code), usar control de versiones (version control) y rastreadores de problemas (issue trackers), revisiones de cÃ³digo (code reviews), pruebas unitarias (unit testing) y automatizaciÃ³n de tareas (task automation).\nWilson, et al.Â 2014. PLOS Biology\n\nCon el fin de previnir retracciones.\nMÃ¡s informaciÃ³n en Best Practices for Scientific Computing - The Carpentries."
  },
  {
    "objectID": "tema2.html#cÃ³digo-reproducible",
    "href": "tema2.html#cÃ³digo-reproducible",
    "title": "Buenas prÃ¡cticas en la bioinformÃ¡tica",
    "section": "CÃ³digo reproducible ğŸŒŸ",
    "text": "CÃ³digo reproducible ğŸŒŸ\n\nContenedores âš¡\n\nDocker\nSingularity\nApptainer\n\nSe puede almacenar todo el workflow, archivos, generando codigo reproducible y cooperativo.\n\nMinicurso del uso de Docker.\n\n\n\nCrear pipelines completos ğŸŒ€\n\nNextflow\nSnakemake"
  },
  {
    "objectID": "tema2.html#pasos-para-escribir-un-buen-software",
    "href": "tema2.html#pasos-para-escribir-un-buen-software",
    "title": "Buenas prÃ¡cticas en la bioinformÃ¡tica",
    "section": "Pasos para escribir un buen software",
    "text": "Pasos para escribir un buen software\n\nAnÃ¡lisis del problema / Definir el problema\nDiseÃ±o del algoritmo / DiseÃ±o del programa\nCodificaciÃ³n / Escribir el cÃ³digo\nCompilaciÃ³n y ejecuciÃ³n del programa\nVerificaciÃ³n / Realizar pruebas\nDepuraciÃ³n / Detectar los errores y corregirlos\n\n\nProgramacion defensiva\n\n\nDocumentaciÃ³n"
  },
  {
    "objectID": "tema2.html#puntos-claves-para-buenas-practicas-en-bioinfo",
    "href": "tema2.html#puntos-claves-para-buenas-practicas-en-bioinfo",
    "title": "Buenas prÃ¡cticas en la bioinformÃ¡tica",
    "section": "Puntos claves para buenas practicas en bioinfo â­",
    "text": "Puntos claves para buenas practicas en bioinfo â­\n\nEscriba programas para personas, no para computadoras (Documenta quÃ© hace y por quÃ©). - Se coherente en la nomenclatura, indentaciÃ³n y otros aspectos del estilo.\nDivide los programas en *funciones cortas de un solo propÃ³sito. ğŸ’» ğŸ“š\nNo repitas tu cÃ³digo. Crea pasos reproducibles o que se repitan por si solas. â°\nPlanifique los errores (Programacion defensiva) ğŸš©\nOptimice el software sÃ³lo despuÃ©s de que funcione correctamente. - Si funciona no lo modifiques, simplificalo.\nColaborar - Busque siempre bibliotecas de software bien mantenidas que hagan lo que necesita. ğŸ‘¥"
  },
  {
    "objectID": "tema3.html",
    "href": "tema3.html",
    "title": "Reprocesamiento de los datos",
    "section": "",
    "text": "A partir de la pagina web de Git proMGE realizamos modificaciones de los scripts para mejorar la documentaciÃ³n de los mismos."
  },
  {
    "objectID": "tema3.html#datos",
    "href": "tema3.html#datos",
    "title": "Reprocesamiento de los datos",
    "section": "Datos",
    "text": "Datos\n\nModificado por: Evelia Coss\n\nTodos los datos utilizados en este estudio estÃ¡n publicados y a disposiciÃ³n del pÃºblico, como se indica en la secciÃ³n de material y mÃ©todos del manuscrito.\n\nLos datos de todos los genomas procariotas utilizados en el estudio estÃ¡n disponibles en https://progenomes.embl.de/.\nLa informaciÃ³n sobre el hÃ¡bitat estÃ¡ disponible en GMGC.\n\n\n\n\nFlujo de trabajo para la identificaciÃ³n de elementos genÃ©ticos mÃ³viles (MGEs) en procariotas y anÃ¡lisis de carga genÃ©tica. (A) Se anotaron cinco familias principales de recombinasas en proGenomes2 usando HMMs a nivel de subfamilia y validaciÃ³n con EggNOG y RefSeq. (B) Se asignaron recombinasas a seis categorÃ­as de MGEs y se diferenciaron de recombinasas celulares mediante anÃ¡lisis de lÃ­mites de pangenomas, asociaciÃ³n con subfamilias y la presencia de genes accesorios especÃ­ficos. (C) Se presentan ejemplos de MGEs con genes de resistencia a antibiÃ³ticos (ARG), destacando su novedad en aspectos como diversificaciÃ³n funcional, MGEs anidados, transferencia horizontal de genes entre dominios de vida y nuevas asociaciones de dominios proteicos."
  },
  {
    "objectID": "tema3.html#procesamiento-de-datos-para-la-figuras",
    "href": "tema3.html#procesamiento-de-datos-para-la-figuras",
    "title": "Reprocesamiento de los datos",
    "section": "Procesamiento de datos para la Figuras",
    "text": "Procesamiento de datos para la Figuras\nLos autores nos informan que se realizaron modificacione sobre los inputs para generar las Figuras 2 a 5 empleando codigo de perl. Para mas informacion vista la fuente original del Git."
  },
  {
    "objectID": "tema4.html",
    "href": "tema4.html",
    "title": "ReproducciÃ³n de figuras",
    "section": "",
    "text": "A partir de la pagina web de Git proMGE realizamos modificaciones de los scripts para mejorar la documentaciÃ³n de los mismos."
  },
  {
    "objectID": "tema4.html#figuras-y-scripts",
    "href": "tema4.html#figuras-y-scripts",
    "title": "ReproducciÃ³n de figuras",
    "section": "Figuras y scripts",
    "text": "Figuras y scripts\n\nModificado por: Evelia Coss\n\n\n\n\nFigura\nScript original\nScript modificado (en espaÃ±ol)\n\n\n\n\nFigura 2\nR/Figure2.R\nscripts/Figure2_modificado.R\n\n\nFigura 3\nR/Figure3.R\nscripts/Figure3_modificado.R\n\n\nFigura 4\nR/Figure4.R\nscripts/Figure4_modificado.R\n\n\nFigura 5\nR/Figure5.R\nscripts/Figure5_modificado.R"
  }
]