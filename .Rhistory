# Convertir los datos en formato ancho (cada variable como columna)
spread(variable, avg_class) %>%
# Convertir en tibble y establecer las clases como nombres de fila
column_to_rownames(var = "class")%>%
# Seleccionar las variables de interés
dplyr::select(class, IS_Tn, Phage, Phage_like, CE, Integron, MI) %>%
# Establecer las clases como nombres de fila
column_to_rownames(var = "class")
# Crear la matriz de datos para el mapa de calor filogenético
phylo_heatmap_mat <- all_avg_cnt_tax_class_sel1 %>%
# Filtrar clases que no contienen "NA"
filter(!grepl("NA ", class)) %>%
# Convertir los datos en formato ancho (cada variable como columna)
spread(variable, avg_class) %>%
# Seleccionar las variables de interés
dplyr::select(class, IS_Tn, Phage, Phage_like, CE, Integron, MI) %>%
# Establecer las clases como nombres de fila
column_to_rownames(var = "class")
# Crear el árbol filogenético manteniendo solo las especies que están en la matriz de datos del mapa de calor
class_tree_w_g9 <- keep.tip(class_tree, tip = rownames(phylo_heatmap_mat))
## Ajuste de colores para el mapa de calor filogenético para datos sesgados
small_value <- unique(sort(unlist(phylo_heatmap_mat)))[2]  # Encuentra el segundo valor más pequeño en la matriz de datos para establecer un umbral
small_value <- small_value - small_value %% 0.001  # Redondea el valor a 3 decimales para crear un valor pequeño ajustado
# Histograma para visualizar la distribución de los datos en la matriz
hist(unlist(phylo_heatmap_mat), nclass = 50)
# Definir los puntos de corte para el mapa de calor según la distribución de los datos
heatmap_breaks <- c(0, small_value, 1, 2, 3, 4, seq(5, 55, 10))
# Histograma con los puntos de corte definidos para el mapa de calor
hist(unlist(phylo_heatmap_mat), breaks = heatmap_breaks, freq = T)
# Definir una paleta de colores basada en viridis, con un sesgo hacia valores más bajos
plot_colors <- c("white", colorRampPalette((viridis(10)), bias = 5)(length(heatmap_breaks) - 2))
# Crear una matriz de significancia (signP) para etiquetar el mapa de calor
sig_mat <- plot_table_w_g9 %>%
select(class, variable, signP)  # Selecciona las columnas relevantes de los datos
# Filtra las filas que contienen "NA" en la columna "class" y transforma los datos a formato ancho
sig_mat <- sig_mat %>%
filter(!grepl("NA ", class)) %>%
spread(variable, signP) %>%  # Transforma los datos para que las variables sean columnas
column_to_rownames(var = "class")  # Establece la columna "class" como nombres de fila
# Alinea la matriz de significancia con el árbol filogenético
sig_mat <- sig_mat[class_tree_w_g9$tip.label, colnames(phylo_heatmap_mat)]
# ---------- phylo.heatmap.coords() --------------------
#' Extract X and Y coordinates from phylogenetic heatmap
#'
#' This function computes the x and y coordinates for plotting a phylogenetic heatmap. It also allows the customization of font size, color schemes, and standardization of the data.
#' The coordinates are returned as a list for use in further plotting or data analysis.
#'
#' @param tree A phylogenetic tree of class `phylo` from the `ape` package.
#' @param X A matrix of data (variables x samples) to be visualized in the heatmap.
#' @param fsize A numeric vector of length 3 specifying the font size for different components of the plot.
#' @param colors A character vector of colors to be used in the heatmap. Defaults to `NULL`, in which case the `heat.colors` palette is used.
#' @param standardize A logical indicating whether to standardize the data (default is `FALSE`).
#' @param legend A logical indicating whether to display a legend (default is `TRUE`).
#' @param labels A logical indicating whether to display labels (default is `TRUE`).
#' @param split A numeric vector of length 2 indicating how to split the plot. Defaults to `c(0.5, 0.5)`.
#' @param xlim A numeric vector of length 2 specifying the x-axis limits (default is `NULL`).
#' @param ylim A numeric vector of length 2 specifying the y-axis limits (default is `NULL`).
#' @param mar A numeric vector of length 4 specifying the plot margins (default is `rep(1.1, 4)`).
#' @param grid A logical indicating whether to add a grid to the plot (default is `FALSE`).
#' @param ... Additional parameters passed to the `phylogram` function or other plotting functions.
#'
#' @return A list containing two elements:
#' \item{xx}{A numeric vector of x coordinates for the heatmap.}
#' \item{yy}{A numeric vector of y coordinates for the heatmap.}
#'
#' @examples
#' # Example usage:
#' # Load a phylogenetic tree (example from the ape package)
#' library(ape)
#' data(bird.orders)
#'
#' # Create some random data for the heatmap
#' set.seed(123)
#' X <- matrix(rnorm(100), ncol = 10)
#'
#' # Get the coordinates for the heatmap
#' coords <- phylo.heatmap.coords(tree = bird.orders, X = X, fsize = 1.5)
#'
#' # Plot the heatmap (not shown in this example)
#' plot(coords$xx, coords$yy, type = "n")  # Placeholder plot
#'
#' @export
# Función para obtener las coordenadas x e y del mapa de calor filogenético
phylo.heatmap.coords <- function (tree, X, fsize = 1, colors = NULL, standardize = FALSE, ...)
{
# Verifica que el tamaño de la fuente tenga 3 valores
if (length(fsize) != 3)
fsize <- rep(fsize, 3)
# Si se pasa el parámetro "legend", se extrae
if (hasArg(legend))
legend <- list(...)$legend
else legend <- TRUE # La leyenda por defecto es TRUE
# Si se pasa el parámetro "labels", se extrae
if (hasArg(labels))
labels <- list(...)$labels
else labels <- TRUE
# Si se pasa el parámetro "split", se extrae
if (hasArg(split))
split <- list(...)$split
else split <- c(0.5, 0.5) # Por defecto, el gráfico se divide 50-50
split <- split/sum(split) # Normaliza el valor de la división
# Si la matriz X no tiene nombres de columnas, asigna valores predeterminados
if (is.null(colnames(X)))
colnames(X) <- paste("var", 1:ncol(X), sep = "")
# Si la normalización es requerida, estandariza los datos
if (standardize) {
sd <- apply(X, 2, function(x) sqrt(var(x, na.rm = TRUE))) # Calcula la desviación estándar
X <- (X - matrix(rep(1, Ntip(tree)), Ntip(tree), 1) %*%
colMeans(X, na.rm = TRUE))/(matrix(rep(1, Ntip(tree)),
Ntip(tree), 1) %*% sd)
}
# Si se pasa un límite para el eje X, se utiliza; de lo contrario, se define uno predeterminado
if (hasArg(xlim))
xlim <- list(...)$xlim
else xlim <- c(-0.5, (2 - 0.5) * split[2]/split[1] + 0.5)
# Si se pasa un límite para el eje Y, se utiliza; de lo contrario, se define uno predeterminado
if (hasArg(ylim))
ylim <- list(...)$ylim
else ylim <- if (legend)
c(if (standardize) -0.15 else -0.1, if (labels) 1.1 else 1)
else c(0, if (labels) 1.1 else 1)
# Si se pasa un margen para el gráfico, se utiliza; de lo contrario, se define uno predeterminado
if (hasArg(mar))
mar <- list(...)$mar
else mar <- rep(1.1, 4)
# Si no se define una paleta de colores, se utiliza la paleta predeterminada
if (is.null(colors))
colors <- heat.colors(n = 20)[20:1]
# Si se pasa la opción para añadir una cuadrícula, se extrae
if (hasArg(grid))
add.grid <- list(...)$grid
else add.grid <- FALSE
# Desenreda el árbol filogenético
cw <- untangle(tree, "read.tree")
# Inicializa el gráfico
plot.new()
par(mar = mar)
plot.window(xlim = xlim, ylim = ylim)
# Dibuja el árbol filogenético
h <- phylogram(cw, fsize = fsize[1], ...)
# Calcula las coordenadas de inicio y fin del mapa de calor
START <- h + 1/2 * ((2 - 0.5) * split[2]/split[1] + 0.5 -
h)/(ncol(X) - 1) + 0.5 * strwidth("W") * fsize[1]
END <- (2 - 0.5) * split[2]/split[1] + 0.5 - 1/2 * ((2 - 0.5) * split[2]/split[1] + 0.5 - START)/(ncol(X) - 1)
# Calcula las coordenadas y para las especies/clases
nTips <- length(tree$tip.label)
y <- c(-1/(2 * (nTips - 1)), seq(0, 1, length = nTips) + 2/(2 * (nTips - 1)))
# Calcula las coordenadas x para las variables
x <- seq(START, END, by = (END - START)/(ncol(X) - 1))
# Devuelve las coordenadas
list(xx = x, yy = y)
}
# Establece el entorno de la función
environment(phylo.heatmap.coords) <- environment(phylo.heatmap)
# ---------- phylo.heatmap.legendmod() --------------------
#' Modified Phylogenetic Heatmap with Custom Legend
#'
#' This function generates a phylogenetic heatmap with an optional legend and additional customization options. It allows for standardization of data, color selection, and the addition of a grid to the plot. The function also includes the ability to customize the font size and labels.
#'
#' @param tree A phylogenetic tree of class `phylo` from the `ape` package.
#' @param X A matrix of data (variables x samples) to be visualized in the heatmap.
#' @param fsize A numeric vector of length 3 specifying the font size for different components of the plot.
#' @param colors A character vector of colors to be used in the heatmap. Defaults to `NULL`, in which case the `heat.colors` palette is used.
#' @param standardize A logical indicating whether to standardize the data (default is `FALSE`).
#' @param legend A logical indicating whether to display a legend (default is `TRUE`).
#' @param labels A logical indicating whether to display labels (default is `TRUE`).
#' @param split A numeric vector of length 2 indicating how to split the plot. Defaults to `c(0.5, 0.5)`.
#' @param xlim A numeric vector of length 2 specifying the x-axis limits (default is `NULL`).
#' @param ylim A numeric vector of length 2 specifying the y-axis limits (default is `NULL`).
#' @param mar A numeric vector of length 4 specifying the plot margins (default is `rep(1.1, 4)`).
#' @param grid A logical indicating whether to add a grid to the plot (default is `FALSE`).
#' @param ... Additional parameters passed to the `phylogram` function or other plotting functions.
#'
#' @return A plot with a phylogenetic heatmap, a modified legend, and optional customizations.
#'
#' @examples
#' # Example usage:
#' # Load a phylogenetic tree (example from the ape package)
#' library(ape)
#' data(bird.orders)
#'
#' # Create some random data for the heatmap
#' set.seed(123)
#' X <- matrix(rnorm(100), ncol = 10)
#'
#' # Plot the modified phylogenetic heatmap with custom legend
#' phylo.heatmap.legendmod(tree = bird.orders, X = X, fsize = 1.5)
#'
#' @export
# Función para crear un mapa de calor filogenético con leyenda interactiva
phylo.heatmap.legendmod <- function (tree, X, fsize = 1, colors = NULL, standardize = FALSE, ...)
{
# Verifica que el tamaño de la fuente tenga 3 valores
if (length(fsize) != 3)
fsize <- rep(fsize, 3)
# Si se pasa el parámetro "legend", se extrae
if (hasArg(legend))
legend <- list(...)$legend
else legend <- TRUE
# Si se pasa el parámetro "labels", se extrae
if (hasArg(labels))
labels <- list(...)$labels
else labels <- TRUE
# Si se pasa el parámetro "split", se extrae
if (hasArg(split))
split <- list(...)$split
else split <- c(0.5, 0.5) # Por defecto, el gráfico se divide 50-50
split <- split/sum(split)# Normaliza el valor de la división
# Si la matriz X no tiene nombres de columnas, asigna valores predeterminados
if (is.null(colnames(X)))
colnames(X) <- paste("var", 1:ncol(X), sep = "")
# Si la normalización es requerida, estandariza los datos
if (standardize) {
sd <- apply(X, 2, function(x) sqrt(var(x, na.rm = TRUE))) # Calcula la desviación estándar
X <- (X - matrix(rep(1, Ntip(tree)), Ntip(tree), 1) %*%
colMeans(X, na.rm = TRUE))/(matrix(rep(1, Ntip(tree)), Ntip(tree), 1) %*% sd)
}
# Si se pasa un límite para el eje X, se utiliza; de lo contrario, se define uno predeterminado
if (hasArg(xlim))
xlim <- list(...)$xlim
else xlim <- c(-0.5, (2 - 0.5) * split[2]/split[1] + 0.5)
# Si se pasa un límite para el eje Y, se utiliza; de lo contrario, se define uno predeterminado
if (hasArg(ylim))
ylim <- list(...)$ylim
else ylim <- if (legend)
c(if (standardize) -0.15 else -0.1, if (labels) 1.1 else 1)
else c(0, if (labels) 1.1 else 1)
# Si se pasa un margen para el gráfico, se utiliza; de lo contrario, se define uno predeterminado
if (hasArg(mar))
mar <- list(...)$mar
else mar <- rep(1.1, 4)
# Si no se define una paleta de colores, se utiliza la paleta predeterminada
if (is.null(colors))
colors <- heat.colors(n = 20)[20:1]
# Si se pasa la opción para añadir una cuadrícula, se extrae
if (hasArg(grid))
add.grid <- list(...)$grid
else add.grid <- FALSE
# Desenreda el árbol filogenético
cw <- untangle(tree, "read.tree")
# Inicializa el gráfico
plot.new()
par(mar = mar)
plot.window(xlim = xlim, ylim = ylim)
# Dibuja el árbol filogenético
h <- phylogram(cw, fsize = fsize[1], ...)
# Calcula las coordenadas de inicio y fin del mapa de calor
START <- h + 1/2 * ((2 - 0.5) * split[2]/split[1] + 0.5 - h)/(ncol(X) - 1) + 0.5 * strwidth("W") * fsize[1]
END <- (2 - 0.5) * split[2]/split[1] + 0.5 - 1/2 * ((2 - 0.5) * split[2]/split[1] + 0.5 - START)/(ncol(X) - 1)
# Ajusta los valores de X a las etiquetas del árbol
X <- X[cw$tip.label, ]
# Dibuja el mapa de calor
image(x = seq(START, END, by = (END - START)/(ncol(X) - 1)),
z = t(X[cw$tip.label, ]), add = TRUE, col = colors, right = T, ...)
# Si se desea, añade una cuadrícula
if (add.grid) {
dx <- (END - START)/(ncol(X) - 1)
x <- seq(START - dx/2, END + dx/2, by = dx)
nTips <- length(tree$tip.label)
y <- c(-1/(2 * (nTips - 1)), seq(0, 1, length = nTips) +
1/(2 * (nTips - 1)))
segments(x, y[1], x, y[length(y)])
segments(x[1], y, x[length(x)], y)
}
if (legend)
add.color.bar(leg = END - START, cols = colors, lims = range(X, na.rm = TRUE), title = if (standardize) "standardized value" else "value", subtitle = if (standardize) "SD units" else "", prompt = F, digits = if (max(abs(X),na.rm = TRUE) < 1) round(log10(1/max(abs(X), na.rm = TRUE))) + 1 else 2, fsize = fsize[3], lwd = 20, outline = T, x = START, y = -1/(2 * (Ntip(cw) - 1)) - 3 * fsize[3] * strheight("W"))
if (labels)
text(x = seq(START, END, by = (END - START)/(ncol(X) - 1)), y = rep(1 + 1/(2 * (Ntip(cw) - 1)) + 0.4 * fsize[2] * strwidth("I"), ncol(X)), colnames(X), srt = 70, adj = c(0,0.5), cex = fsize[2])
if (any(is.na(X))) {
ii <- which(is.na(X), arr.ind = TRUE)
x.na <- seq(START, END, by = (END - START)/(ncol(X) - 1))[ii[, 2]]
y.na <- seq(0, 1, by = 1/(nrow(X) - 1))[ii[, 1]]
for (i in 1:length(x.na)) {
xx <- x.na[i] + c(1/2, -1/2) * (END - START)/(ncol(X) - 1)
yy <- y.na[i] + c(-1/2, 1/2) * 1/(nrow(X) - 1)
lines(xx, yy)
}
}
}
# Establece el entorno de la función
environment(phylo.heatmap.legendmod) <- environment(phylo.heatmap)
# 1. Extraer coordenadas del heatmap filogenético para añadir anotaciones manuales posteriormente
xx_yy <- phylo.heatmap.coords(
class_tree_w_g9,           # árbol filogenético de clases
phylo_heatmap_mat,         # matriz de abundancias promedio por clase y MGE
fsize = c(0.8, 0.9, 0.7),  # tamaños de fuente (árbol, heatmap, leyenda)
colors = plot_colors,      # colores personalizados para el heatmap
grid = TRUE,               # mostrar rejilla en el heatmap
split = c(0.7, 0.3),       # proporción de espacio entre árbol y heatmap
lwd = 1,                   # grosor de líneas
breaks = heatmap_breaks,   # puntos de corte para los colores
mar = c(1.2,1.2,1.2,1.2)   # márgenes
)
## 2. Generar el heatmap con leyenda incluida, usando los mismos parámetros que el paso anterior
phylo.heatmap.legendmod(
class_tree_w_g9,
phylo_heatmap_mat,
fsize = c(0.8, 0.9, 0.7),
colors = plot_colors,
grid = TRUE,
split = c(0.7, 0.3),
lwd = 1,
breaks = heatmap_breaks,
mar = c(1.2,1.2,1.2,1.2)
)
## 3. Añadir símbolos de significancia ("*") en cada celda de la matriz que lo indique (en 'sig_mat')
for(i in 1:nrow(sig_mat)) {
for(j in 1:ncol(sig_mat)) {
if(sig_mat[i,j] == "*") {
rnm <- rownames(sig_mat)[i]  # nombre de la fila (clase taxonómica)
cnm <- colnames(sig_mat)[j]  # nombre de la columna (MGE)
# Añadir el símbolo "*" en la posición correspondiente del heatmap
points(
xx_yy$xx[j], xx_yy$yy[i],   # coordenadas x, y para esa celda
cex = 1.5,                  # tamaño del símbolo
col = if (phylo_heatmap_mat[rnm, cnm] < heatmap_breaks[3]) "white" else "black",
pch = "*"                   # símbolo a dibujar
)
}
}
}
# 1. Extraer coordenadas del heatmap filogenético para añadir anotaciones manuales posteriormente
xx_yy <- phylo.heatmap.coords(
class_tree_w_g9,           # árbol filogenético de clases
phylo_heatmap_mat,         # matriz de abundancias promedio por clase y MGE
fsize = c(0.8, 0.9, 0.7),  # tamaños de fuente (árbol, heatmap, leyenda)
colors = plot_colors,      # colores personalizados para el heatmap
grid = TRUE,               # mostrar rejilla en el heatmap
split = c(0.7, 0.3),       # proporción de espacio entre árbol y heatmap
lwd = 1,                   # grosor de líneas
breaks = heatmap_breaks,   # puntos de corte para los colores
mar = c(1.2,1.2,1.2,1.2)   # márgenes
)
## 2. Generar el heatmap con leyenda incluida, usando los mismos parámetros que el paso anterior
phylo.heatmap.legendmod(
class_tree_w_g9,
phylo_heatmap_mat,
fsize = c(0.8, 0.9, 0.7),
colors = plot_colors,
grid = TRUE,
split = c(0.7, 0.3),
lwd = 1,
breaks = heatmap_breaks,
mar = c(1.2,1.2,1.2,1.2)
)
## 3. Añadir símbolos de significancia ("*") en cada celda de la matriz que lo indique (en 'sig_mat')
for(i in 1:nrow(sig_mat)) {
for(j in 1:ncol(sig_mat)) {
if(sig_mat[i,j] == "*") {
rnm <- rownames(sig_mat)[i]  # nombre de la fila (clase taxonómica)
cnm <- colnames(sig_mat)[j]  # nombre de la columna (MGE)
# Añadir el símbolo "*" en la posición correspondiente del heatmap
points(
xx_yy$xx[j], xx_yy$yy[i],   # coordenadas x, y para esa celda
cex = 1.5,                  # tamaño del símbolo
col = if (phylo_heatmap_mat[rnm, cnm] < heatmap_breaks[3]) "white" else "black",
pch = "*"                   # símbolo a dibujar
)
}
}
}
## Crear barplot apilado (horizontal) de la proporción relativa de MGEs por clase taxonómica
barplot_specI_class_count_all <- ggplot(barplot_mat, aes(y = class, x = frac, fill = mge)) +
# Barras horizontales, borde gris
geom_barh(stat = "identity", color = "grey60") +
# Colores personalizados para los MGEs
scale_fill_manual("MGE", values = colc)
# Eliminar clases no identificadas ("NA ") y mantener solo aquellas que están en el árbol filogenético
barplot_mat <- all_avg_cnt_tax_class_sel_4bar_all %>%
filter(!grepl("NA ", class))                                   # Quitar filas con clases "NA "
# 1. Seleccionar clases que aparecen al menos 10 veces para asegurar una representación confiable.
allclass_all <- all_avg_cnt_tax_class %>%
# Usar una sola MGE como referencia para el conteo por clase
filter(mge == all_avg_cnt_tax_class$mge[1]) %>%
group_by(class) %>%
summarise(cntclass = n()) %>%
# Incluir solo clases con al menos 10 ocurrencias
filter(cntclass > 9)
# 2. Filtrar datos: eliminar MGEs de tipo "Cellular" o "Hotspot" y mantener solo las clases seleccionadas previamente.
all_avg_cnt_tax_class_sel_all <- all_avg_cnt_tax_class %>%
filter(!grepl("Cellular", mge)) %>%
filter(!grepl("Hotspot", mge)) %>%
filter(class %in% allclass_all$class) %>%
group_by(mge, class) %>%
# Promediar por combinación de clase y MGE
summarise(avg_class = mean(avg_cnt), .groups = "drop")
# 3. Calcular la suma total de abundancia de MGEs por clase (para obtener proporciones después)
all_avg_cnt_tax_class_sel_all_mge_all <- all_avg_cnt_tax_class_sel_all %>%
group_by(class) %>%
summarise(total_mge = sum(avg_class), .groups = "drop")
# 4. Combinar abundancia promedio por clase y MGE con el total por clase
#    Calcular la fracción relativa de cada MGE dentro de cada clase
all_avg_cnt_tax_class_sel_4bar_all <- left_join(
all_avg_cnt_tax_class_sel_all,
all_avg_cnt_tax_class_sel_all_mge_all,
by = "class"
) %>%
group_by(class, mge, total_mge) %>%
summarise(frac = avg_class / total_mge, .groups = "drop")
# 5. Limpiar datos y ordenar clases según el orden filogenético del árbol
barplot_mat <- all_avg_cnt_tax_class_sel_4bar_all %>%
filter(!grepl("NA ", class))                            # Eliminar clases no identificadas
barplot_mat$class <- factor(barplot_mat$class,
levels = class_tree_w_g9$tip.label)  # Mantener orden del árbol filogenético
# 6. Preparar datos auxiliares para anotaciones en el barplot (por ejemplo, totales por clase)
barplot_mat_for_n <- all_avg_cnt_tax_class_sel_all_mge_all %>%
filter(!grepl("NA ", class))
barplot_mat_for_n$class <- factor(barplot_mat_for_n$class,
levels = class_tree_w_g9$tip.label)
barplot_specI_class_count_all <- ggplot(barplot_mat, aes(y = class, x = frac, fill = mge)) +
# Barras horizontales, borde gris
geom_barh(stat = "identity", color = "grey60") +
# Colores personalizados para los MGEs
scale_fill_manual("MGE", values = colc)
barplot_specI_class_count_all <- ggplot(barplot_mat, aes(y = class, x = frac, fill = mge)) +
# Barras horizontales, borde gris
geom_bar(stat = "identity", color = "grey60") +
# Colores personalizados para los MGEs
scale_fill_manual("MGE", values = colc)
# Paleta general de colores
colc <- c("#D55E00", "#E69F00", "#F0E442", "#56B4E9", "#009E73", "#0072B2","#CECCCC")
names(colc) <- c("IS_Tn", "Phage", "Phage_like", "CE", "Integron", "MI", "Cellular")
barplot_specI_class_count_all <- ggplot(barplot_mat, aes(y = class, x = frac, fill = mge)) +
# Barras horizontales, borde gris
geom_bar(stat = "identity", color = "grey60") +
# Colores personalizados para los MGEs
scale_fill_manual("MGE", values = colc)
## Añadir detalles estéticos y anotaciones
barplot_specI_class_count_all +
# Límite extendido para espacio de anotaciones
scale_x_continuous(
breaks = c(0, 0.25, 0.5, 0.75, 1.0),
limits = c(0, 1.1)
) +
geom_text(
data = barplot_mat_for_n,
# Mostrar suma total de MGEs por clase
mapping = aes(y = class, x = 1.05, label = paste("", round(total_mge))),
inherit.aes = FALSE,
col = "black",
size = 6) +
labs(y = "",  x = "Relative proportion") +
# Estética limpia estilo Cowplot
theme_cowplot(font_size = 20) +
# Etiquetas del eje X horizontales
theme(
axis.text.x = element_text(angle = 0),
legend.position = "bottom",  # Leyenda abajo
axis.text.y = element_text(hjust = 0, vjust = 0.5))  # Alinear texto del eje Y
load("scripts/phylo_function.R")
source("scripts/phylo_function.R")
head(plot_table)
# Histograma con los puntos de corte definidos para el mapa de calor
hist(unlist(phylo_heatmap_mat), breaks = heatmap_breaks, freq = T)
head(barplot_mat)
barplot_mat %>% filter(class == "Actinobacteria ")
barplot_mat %>% filter(class == "Actinobacteria")
head(all_avg_cnt_tax_class_sel_4bar_all)
head(all_avg_cnt_tax_class_sel_all_mge_all)
head(all_avg_cnt_tax_class)
head(mdb)
dim(mdb)
filter(mdb, class == "BActeroidia")
filter(mdb, class == "Bacteroidia")
head(mdb_cnt)
# Muestra las primeras filas del data.frame resultante
head(db_tax)
head(db_cnt_all)
db_pa_all
head(db_pa_all)
head(db_specI)
head(db_genome)
filter(db_genome, class =="Spirochaetia")
db_genome %>%
group_by(class) %>%
summarise(n_genomes = n_distinct(genomeID)) %>%
arrange(desc(n_genomes))
all_cnt_specI
head(all_cnt_specI)
all_frac_specI
head(all_frac_specI)
head(all_cnt_genome)
allMges
all_avg_cnt_tax_class
head(all_avg_cnt_tax_class)
gs_int
head(all_avg_cnt_tax_class_sel)
# 1. Extraer coordenadas del heatmap filogenético para añadir anotaciones manuales posteriormente
xx_yy <- phylo.heatmap.coords(
class_tree_w_g9,           # árbol filogenético de clases
phylo_heatmap_mat,         # matriz de abundancias promedio por clase y MGE
fsize = c(0.8, 0.9, 0.7),  # tamaños de fuente (árbol, heatmap, leyenda)
colors = plot_colors,      # colores personalizados para el heatmap
grid = TRUE,               # mostrar rejilla en el heatmap
split = c(0.7, 0.3),       # proporción de espacio entre árbol y heatmap
lwd = 1,                   # grosor de líneas
breaks = heatmap_breaks,   # puntos de corte para los colores
mar = c(1.2,1.2,1.2,1.2)   # márgenes
)
xx_yy
# 1. Extraer coordenadas del heatmap filogenético para añadir anotaciones manuales posteriormente
xx_yy <- phylo.heatmap.coords(
class_tree_w_g9,           # árbol filogenético de clases
phylo_heatmap_mat,         # matriz de abundancias promedio por clase y MGE
fsize = c(0.8, 0.9, 0.7),  # tamaños de fuente (árbol, heatmap, leyenda)
colors = plot_colors,      # colores personalizados para el heatmap
grid = TRUE,               # mostrar rejilla en el heatmap
split = c(0.7, 0.3),       # proporción de espacio entre árbol y heatmap
lwd = 1,                   # grosor de líneas
breaks = heatmap_breaks,   # puntos de corte para los colores
mar = c(1.2,1.2,1.2,1.2)   # márgenes
)
